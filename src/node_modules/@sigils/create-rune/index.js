import * as _ from '@dev-xp/utils'
import { createOutput } from 'runic'

const fns = { component: 'addControl', input: 'addInput', output: 'addOutput' }

export default ({ name, symbol, fn = _.identity, params = {} }) => tile => {
    const addItems = items => {
        const call = (item, key) =>
            _.invoker(1, fns[item.type])(item.create(tile.editor, key))
        return _.values(_.mapObjIndexed(call, items))
    }
    const solidifyParams = (rune, inputs) =>
        _.mapIndexed((param, key) => {
            if (param.type === 'component') return rune.data[key]

            const connections = inputs[key] || []
            // eslint-disable-next-line no-underscore-dangle
            if (connections.length <= 0) return _.__

            return _.first(connections).value
        }, params)

    return {
        name,
        worker: (rune, originalInputs, outputs) => {
            const { editor } = tile
            const inputs = solidifyParams(rune, originalInputs)

            const value = _.apply(fn, inputs)
            const strValue = _.isFunction(value) ? `${value.name}()` : value

            // eslint-disable-next-line no-console
            console.log(`[${rune.id}] ${rune.name} - ${strValue}`)

            const socket = createOutput(value, 'Result')
            const node = _.find(_.propEq('id', rune.id), editor.nodes)
            const out = node.outputs ? node.outputs.get('result') : undefined
            const needsSocketUpdate = !out || out.socket.name !== socket.name

            outputs.result = { rune, value }
            node.data.result = value

            if (!needsSocketUpdate) return

            if (out) {
                const conns = out.connections
                conns.forEach(conn => editor.removeConnection(conn))
                node.removeOutput(out)
            }

            _.$(node).pipe(addItems({ result: socket }))
            node.update()
        },
        builder: rune => {
            rune.symbol = symbol
            _.$(rune).pipe(addItems(params))
            return rune.update()
        },
    }
}
