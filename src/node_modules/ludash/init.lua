local identity = function(val) return val end

local noop = function() end

local printError = function(err) print(err) end

local isTrue = function(val)
    if (not val) then
        return false
    end

    if (val == '') then
        return false
    end

    if (val == 0) then
        return false
    end

    return true
end

local isFunction = function(val)
    if type(val) == 'function' then
        return true
    end
end

local map = function(t, projection)
    local out = {}

    for k, v in pairs(t) do
        table.insert(out, projection(v))
    end

    return out
end

local filter = function(t, filterIter)
    local out = {}

    for k, v in pairs(t) do
        if filterIter(v, k, t) then table.insert(out, v) end
    end

    return out
end

local onlyTrue = function(table)
    return filter(table, isTrue)
end

local onlyFunctions = function(table)
    return filter(table, isFunction)
end

local foldr = function(fn, result, collection)
    for iterator, value in pairs(collection) do
        result = fn(result, value)
    end
    return result
end

local reduce = function(collection, fn, initialValue)
    return foldr(fn, initialValue, collection)
end

local isTable = function(value)
    return value and type(value) == 'table'
end

local isObservable = function(value)
    return type(value) == 'table'
    and type(value.subscribe) == 'function'
    and type(value.pipe) == 'function'
end

local isObserver = function(value)
    return type(value) == 'table'
    and type(value.next) == 'function'
    and type(value.err) == 'function'
    and type(value.complete) == 'function'
    and type(value.add) == 'function'
end

local isSubscriber = function(value)
    if type(value) == 'function' then
        return false
    end

    return value
    and type(value.next) == 'function'
    and type(value.err) == 'function'
    and type(value.complete) == 'function'
end

local isSubscription = function(value)
    return type(value) == 'table'
    and type(value.unsubscribe) == 'function'
    and type(value.add) == 'function'
end

local onlyObservables = function(table)
    return filter(table, isObservable)
end

local printTable = function(tbl, label, output)
    output = output or print
    output('('..tostring(label or tbl)..') {')
    for key, val in pairs(tbl) do
        output('    ['..key..'] = '..tostring(val))
    end
    output('}')
end

local reverseTable = function(tbl)
    local out = {}

    for i = #tbl, 1, -1 do
        table.insert(out, tbl[i])
    end

    return out
end

-- https://stackoverflow.com/a/25976660
local areTablesEqual = function(table1, table2)
    local avoid_loops = {}
    local function recurse(t1, t2)
        -- compare value types
        if type(t1) ~= type(t2) then return false end
        -- Base case: compare simple values
        if type(t1) ~= "table" then return t1 == t2 end
        -- Now, on to tables.
        -- First, let's avoid looping forever.
        if avoid_loops[t1] then return avoid_loops[t1] == t2 end
        avoid_loops[t1] = t2
        -- Copy keys from t2
        local t2keys = {}
        local t2tablekeys = {}
        for k, _ in pairs(t2) do
            if type(k) == "table" then table.insert(t2tablekeys, k) end
            t2keys[k] = true
        end
        -- Let's iterate keys from t1
        for k1, v1 in pairs(t1) do
            local v2 = t2[k1]
            if type(k1) == "table" then
                -- if key is a table, we need to find an equivalent one.
                local ok = false
                for i, tk in ipairs(t2tablekeys) do
                    if table_eq(k1, tk) and recurse(v1, t2[tk]) then
                        table.remove(t2tablekeys, i)
                        t2keys[tk] = nil
                        ok = true
                        break
                    end
                end
                if not ok then return false end
            else
                -- t1 has a key which t2 doesn't have, fail.
                if v2 == nil then return false end
                t2keys[k1] = nil
                if not recurse(v1, v2) then return false end
            end
        end
        -- if t2 has a key which t1 doesn't have, fail.
        if next(t2keys) then return false end
        return true
    end
    return recurse(table1, table2)
end

-- https://stackoverflow.com/a/55216440
local intersect = function(idTables)
    local intersection = {}
    local firstTable = true
    for key, tbl in pairs(idTables) do
      -- If this is the first table we are looking at, populate
      -- our intersection table as a map, mapping every ID that appears to a flag.
      -- Note that the choice of flag being a bool is somewhat arbitrary
      if firstTable then
        for _, v in ipairs(tbl) do
          intersection[v] = true
        end
        firstTable = false
      else
        -- Otherwise, we already have a table to intersect against, so for every 
        -- ID in our intersection map, lets check this next table, to see if 
        -- every element of this next table against our intersection map
        for knownId,_ in pairs(intersection) do
          local newTableHasKnownId = false
          for _,id in ipairs(tbl) do
            if id == knownId then
              -- This new table of IDs we're iterating does have the current ID of
              -- the intersection table we're looking at. We can flag it as such, and stop
              -- looking for that known ID
              newTableHasKnownId = true
              break
            end
          end
          -- Drop the 'known' ID from the intersection map if it wasn't in the table
          -- we just iterated.
          if not newTableHasKnownId then
            intersection[knownId] = nil
          end
        end
       end
    end

    local results = {}

    for _, val in pairs(intersection) do
        table.insert(results, val)
    end

    return results
end

return {
    reduce = reduce,
    onlyTrue = onlyTrue,
    onlyFunctions = onlyFunctions,
    onlyObservables = onlyObservables,
    filter = filter,
    isFunction = isFunction,
    isTrue = isTrue,
    printError = printError,
    noop = noop,
    identity = identity,
    isSubscriber = isSubscriber,
    isObservable = isObservable,
    isObserver = isObserver,
    isTable = isTable,
    printTable = printTable,
    reverseTable = reverseTable,
    isSubscription = isSubscription,
    areTablesEqual = areTablesEqual,
    intersect = intersect,
}
