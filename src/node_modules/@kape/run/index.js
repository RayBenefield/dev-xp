import transmute from 'transmutation'
import { obj as stream } from 'through2'
import isFunction from 'lodash.isfunction'
import { render } from 'prettyjson'

const serialize = input => render(input, { noColor: true })
const runTest = subject =>
    transmute()
        .extend('actual', ({ input }) => Promise.resolve(subject(...input)))
        .extend('snapshot', ({ actual }) => serialize(actual))

const collectTests = examples => {
    const tests = []
    const skipped = []

    const it = (...args) => {
        const [test, setup] = args

        // TODO: Needs testing for sure
        // Support major variations:
        // it('should string', given => given())
        // it(given => given())
        // it('has snapshots', [[], [], []])
        // snapshot([], [], [])
        // CONSIDER multiple arguments:
        // it('has snapshots', [], [], [], [])

        const { testName, testSetup } =
            typeof test === 'string' && isFunction(setup) // eslint-disable-line no-nested-ternary
                ? { testName: test, testSetup: setup }
                : typeof test === 'string' && Array.isArray(setup) // eslint-disable-line no-nested-ternary
                    ? { testName: test, testSetup: given => given(...setup) }
                    : isFunction(test)
                        ? { testName: 'snapshot', testSetup: test }
                        : /* eslint-disable indent */
                          {
                              testName: 'snapshot',
                              testSetup: given => given(...args),
                          }
        const testOrSkip = (input, i) => {
            const index = i + 1
            if (input) tests.push({ test: testName, index, input })
            else skipped.push({ test: testName, index, skipped: true })
        }

        testSetup((...inputs) => inputs.forEach(testOrSkip))
    }
    examples(it)
    return { tests, skipped }
}

export default (suite, subject, examples) => {
    const testStream = stream()
    const addToStream = result => testStream.push(result)
    const { tests, skipped } = collectTests(examples)

    skipped.forEach(addToStream)
    Promise.all(
        tests.map(test => runTest(subject)(test).then(addToStream))
    ).then(() => testStream.push(null))

    return testStream
}
