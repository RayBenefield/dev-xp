import { from } from 'rxjs'
import find from 'lodash.find'
import {
    tap,
    map,
    skip,
    delay,
    share,
    filter,
    groupBy,
    mergeMap,
    throttleTime,
    debounceTime,
} from 'rxjs/operators'

export default ({
    prefix = '',
    entryThrottle = 600,
    logger: baseLogger,
    db,
    moderator,
}) => {
    const logger = baseLogger.child({ plugin: 'come-at-me' })

    const entryChanges$ = db
        .onCollectionChange(`${prefix}entries`)
        .pipe(skip(1), share())

    entryChanges$
        .pipe(
            filter(({ type }) => type === 'modified'),
            groupBy(change => change.doc.id),
            mergeMap(entrant$ => entrant$.pipe(debounceTime(3000))),
            map(({ doc }) => doc.data()),
            filter(({ name }) => name !== 'raybenefield')
        )
        .subscribe(({ entries, name }) => {
            logger.extend(`${name}: ${entries} entries`)
            moderator.whisper(
                name,
                `You now have [${entries}] #FeverFam entries for giveaways.`
            )
        })

    logger.platform('Entry collection stream setup.')

    entryChanges$
        .pipe(
            filter(({ type }) => type === 'added'),
            map(({ doc }) => doc.data()),
            filter(({ name }) => name !== 'raybenefield')
        )
        .subscribe(({ name }) => {
            logger.platform(`${name} has entered this week's giveaway.`)
            moderator.whisper(
                name,
                `You've been given an entry for #FeverFam giveaways.`
            )
        })

    const onlyMessagesThatContainTags = entry =>
        find(entry.message.message, { type: 'tag' })
    const onlyMessagesWithTagType = ({ type }) => type === 'tag'

    const withTags$ = moderator.pipe(filter(onlyMessagesThatContainTags))
    const withEntries$ = withTags$.pipe(
        map(({ user_id, user_name, message }) => ({
            friend: { id: user_id, name: user_name.toLowerCase() },
            entrants: message.message
                .filter(onlyMessagesWithTagType)
                .map(({ username, id }) => ({ id, name: username })),
        }))
    )
    const entries$ = withEntries$.pipe(
        mergeMap(({ friend, entrants }) =>
            from(entrants).pipe(map(entrant => ({ friend, entrant })))
        )
    )
    const notSelfPromo$ = entries$.pipe(
        filter(({ friend, entrant }) => friend.id !== entrant.id)
    )
    const throttledEntries$ = notSelfPromo$.pipe(
        groupBy(({ friend, entrant }) => `${friend.id} -> ${entrant.id}`),
        mergeMap(entry$ => entry$.pipe(throttleTime(entryThrottle * 1000))),
        tap(({ friend, entrant }) =>
            logger.extend(`${friend.name} -> ${entrant.name}`)
        )
    )

    throttledEntries$.subscribe(({ friend, entrant }) => {
        const database = db.raw
        const entrantRef = database.doc(`${prefix}entries/${entrant.id}`)
        database.runTransaction(t =>
            t.get(entrantRef).then(doc => {
                const data = doc.data()
                if (!data) {
                    return t.set(entrantRef, {
                        name: entrant.name,
                        entries: 1,
                        [friend.id]: { entries: 1, name: friend.name },
                    })
                }
                return t.update(entrantRef, {
                    name: entrant.name,
                    entries: data.entries + 1,
                    [friend.id]: {
                        entries: data[friend.id]
                            ? data[friend.id].entries + 1
                            : 1,
                        name: friend.name,
                    },
                })
            })
        )
    })
    logger.platform('Chat entry stream setup.')

    const onlyMessagesWithTextType = ({ type }) => type === 'text'
    const onlyMessagesWithActualText = ({ text = '' }) => text.trim().length > 0
    const onlyMessagesWithExclusivelyTags = entry =>
        entry.message.message
            .filter(onlyMessagesWithTextType)
            .filter(onlyMessagesWithActualText).length === 0
    const onlyTags$ = withTags$.pipe(
        filter(onlyMessagesWithExclusivelyTags),
        delay(3000),
        tap(({ id }) => moderator.erase(id))
    )
    onlyTags$.subscribe()
    logger.platform('Tag only message stream setup.')
}
