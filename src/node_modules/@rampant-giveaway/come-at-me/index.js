import { from } from 'rxjs'
import find from 'lodash.find'
import {
    tap,
    map,
    delay,
    filter,
    groupBy,
    mergeMap,
    throttleTime,
    debounceTime,
} from 'rxjs/operators'

export default ({ prefix = '', entryThrottle = 10, db, moderator }) => {
    db
        .onCollectionChange(`${prefix}entries`)
        .pipe(
            filter(({ type }) => type === 'modified'),
            groupBy(change => change.doc.id),
            mergeMap(entrant$ => entrant$.pipe(debounceTime(3000))),
            map(({ doc }) => doc.data()),
            filter(({ name }) => name !== 'raybenefield')
        )
        .subscribe(({ entries, name }) =>
            moderator.whisper(
                name,
                `@${name}, You have ${entries} entries in the "Come @ Me" Giveaway.`
            )
        )

    const onlyMessagesThatContainTags = entry =>
        find(entry.message.message, { type: 'tag' })
    const onlyMessagesWithTagType = ({ type }) => type === 'tag'

    const withTags$ = moderator.pipe(filter(onlyMessagesThatContainTags))
    const withEntries$ = withTags$.pipe(
        map(({ user_id, user_name, message }) => ({
            friend: { id: user_id, name: user_name.toLowerCase() },
            entrants: message.message
                .filter(onlyMessagesWithTagType)
                .map(({ username, id }) => ({ id, name: username })),
        })),
        tap(console.log)
    )
    const entries$ = withEntries$.pipe(
        mergeMap(({ friend, entrants }) =>
            from(entrants).pipe(map(entrant => ({ friend, entrant })))
        )
    )
    const notSelfPromo$ = entries$.pipe(
        filter(({ friend, entrant }) => friend.id !== entrant.id)
    )
    const throttledEntries$ = notSelfPromo$.pipe(
        groupBy(({ friend, entrant }) => `${friend.id} -> ${entrant.id}`),
        mergeMap(entry$ => entry$.pipe(throttleTime(entryThrottle * 60 * 1000)))
    )

    throttledEntries$.subscribe(({ friend, entrant }) => {
        const database = db.raw
        const entrantRef = database.doc(`${prefix}entries/${entrant.id}`)
        database.runTransaction(t =>
            t.get(entrantRef).then(doc => {
                const data = doc.data()
                if (!data) {
                    return t.set(entrantRef, {
                        name: entrant.name,
                        entries: 1,
                        [friend.id]: { entries: 1, name: friend.name },
                    })
                }
                return t.update(entrantRef, {
                    name: entrant.name,
                    entries: data.entries + 1,
                    [friend.id]: {
                        entries: data[friend.id]
                            ? data[friend.id].entries + 1
                            : 1,
                        name: friend.name,
                    },
                })
            })
        )
    })

    const onlyMessagesWithTextType = ({ type }) => type === 'text'
    const onlyMessagesWithActualText = ({ text = '' }) => text.trim().length > 0
    const onlyMessagesWithExclusivelyTags = entry =>
        entry.message.message
            .filter(onlyMessagesWithTextType)
            .filter(onlyMessagesWithActualText).length === 0
    const onlyTags$ = withTags$.pipe(
        filter(onlyMessagesWithExclusivelyTags),
        delay(3000),
        tap(({ id }) => moderator.erase(id))
    )
    onlyTags$.subscribe()
}
