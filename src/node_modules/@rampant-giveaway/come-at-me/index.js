import { from } from 'rxjs'
import find from 'lodash.find'
import {
    tap,
    map,
    skip,
    delay,
    share,
    filter,
    groupBy,
    mergeMap,
    throttleTime,
    debounceTime,
} from 'rxjs/operators'
import { firestore } from 'firebase-admin'

const { FieldValue } = firestore

export default ({
    prefix = '',
    entryThrottle = 600,
    logger: baseLogger,
    db,
    moderator,
}) => {
    const logger = baseLogger.child({ plugin: 'come-at-me' })

    const entryChanges$ = db
        .onCollectionChange(`pools/${prefix}/entries`)
        .pipe(debounceTime(1), skip(1), share())

    entryChanges$
        .pipe(
            filter(({ type }) => type === 'modified'),
            groupBy(change => change.doc.id),
            mergeMap(entrant$ => entrant$.pipe(debounceTime(3000))),
            map(({ doc }) => doc.data()),
            filter(({ name }) => name !== 'raybenefield')
        )
        .subscribe(({ entries, name }) => {
            logger.extend(`${name}: ${entries} entries`)
            moderator.whisper(
                name,
                `You now have [${entries}] #FeverFam entries for giveaways.`
            )
        })

    logger.platform('Entry collection stream setup.')

    entryChanges$
        .pipe(
            filter(({ type }) => type === 'added'),
            map(({ doc }) => doc.data()),
            filter(({ name }) => name !== 'raybenefield')
        )
        .subscribe(({ name }) => {
            logger.platform(`${name} has entered this week's giveaway.`)
            moderator.whisper(
                name,
                `You've been given an entry for #FeverFam giveaways.`
            )
        })

    const onlyMessagesThatContainTags = entry =>
        find(entry.message.message, { type: 'tag' })
    const onlyMessagesWithTagType = ({ type }) => type === 'tag'

    const withTags$ = moderator.pipe(filter(onlyMessagesThatContainTags))
    const withEntries$ = withTags$.pipe(
        map(({ userId, userName, message }) => ({
            friend: { id: userId, name: userName.toLowerCase() },
            entrants: message.message
                .filter(onlyMessagesWithTagType)
                .map(({ username, id }) => ({ id, name: username })),
        }))
    )
    const entries$ = withEntries$.pipe(
        mergeMap(({ friend, entrants }) =>
            from(entrants).pipe(map(entrant => ({ friend, entrant })))
        )
    )
    const notSelfPromo$ = entries$.pipe(
        filter(({ friend, entrant }) => friend.id !== entrant.id)
    )
    const throttledEntries$ = notSelfPromo$.pipe(
        groupBy(({ friend, entrant }) => `${friend.id} -> ${entrant.id}`),
        mergeMap(entry$ => entry$.pipe(throttleTime(entryThrottle * 1000))),
        tap(({ friend, entrant }) =>
            logger.extend(`${friend.name} -> ${entrant.name}`)
        )
    )

    throttledEntries$.subscribe(({ friend, entrant }) => {
        Promise.all([
            db.upsert(`pools/${prefix}`, { entries: FieldValue.increment(1) }),
            db.upsert(`pools/${prefix}/entries/${entrant.id}`, {
                name: entrant.name,
                entries: FieldValue.increment(1),
                [friend.id]: {
                    entries: FieldValue.increment(1),
                    name: friend.name,
                },
            }),
        ])
    })
    logger.platform('Chat entry stream setup.')

    const onlyMessagesWithTextType = ({ type }) => type === 'text'
    const onlyMessagesWithActualText = ({ text = '' }) => text.trim().length > 0
    const onlyMessagesWithExclusivelyTags = entry =>
        entry.message.message
            .filter(onlyMessagesWithTextType)
            .filter(onlyMessagesWithActualText).length === 0
    const onlyTags$ = withTags$.pipe(
        filter(onlyMessagesWithExclusivelyTags),
        delay(3000),
        tap(({ id }) => moderator.erase(id))
    )
    onlyTags$.subscribe()
    logger.platform('Tag only message stream setup.')
}
