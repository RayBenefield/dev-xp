
using. /Fortnite.com/Devices
using. /Verse.org/Simulation

using. Tableau

num_test := class(creative_device, test_suite):
    GetName<override>():string = "Num"
    GetTests<override>():[]test_case = array:
        test_case:
            Name := "Should be actual value zero"
            Test := IsZero
        test_case:
            Name := "Should be zero even with an exponent"
            Test := IsZeroWithExponent
        test_case:
            Name := "Should be equal between two values"
            Test := Equals
        test_case:
            Name := "Should always be zero if value is zero"
            Test := NormalizeAlwaysZero
        test_case:
            Name := "Should not normalize an already normalized number"
            Test := NormalizeAlreadyNormalized
        test_case:
            Name := "Should normalize a number less than 1"
            Test := NormalizeLessThanOne
        test_case:
            Name := "Should normalize a number more than 10"
            Test := NormalizeMoreThanTen
        test_case:
            Name := "Should normalize a negative number"
            Test := NormalizeNegativeNumber
        test_case:
            Name := "Should not set normalize a number already set normalized"
            Test := SetNormalizeAlreadyFine
        test_case:
            Name := "Should set normalize a number not yet in a set"
            Test := SetNormalize
        test_case:
            Name := "Should set normalize a number with zero exponent"
            Test := SetNormalizeWithZeroExponent
        test_case:
            Name := "Should add zero properly"
            Test := AddZero
        test_case:
            Name := "Should just values with same exponent"
            Test := AddWithSameExponent
        test_case:
            Name := "Should add up to the next exponent"
            Test := AddUpToNextExponent
        test_case:
            Name := "Should multiply by one and be the same"
            Test := MultiplyByOne
        test_case:
            Name := "Should be able to double"
            Test := MultiplyByTwo
        test_case:
            Name := "Should be able to multiply by 256"
            Test := MultiplyBy256
        test_case:
            Name := "List should sum simple values"
            Test := SumValues
        test_case:
            Name := "Stringified should support zero"
            Test := StringZero
        test_case:
            Name := "Stringified should support single digits"
            Test := StringSingleDigit
        test_case:
            Name := "Stringified should support double digits"
            Test := StringDoubleDigit
        test_case:
            Name := "Stringified should support under 1k"
            Test := StringLessThan1K
        test_case:
            Name := "Stringified should support 1k with decimals"
            Test := String1KWithDecimals
        test_case:
            Name := "Stringified should support over 100k with no decimals"
            Test := StringOver100K
        test_case:
            Name := "Stringified should support over 999q"
            Test := StringOver999Q
        test_case:
            Name := "Stringified should support over 999A"
            Test := StringOver999A
        test_case:
            Name := "Stringified should support a max of 999Zq"
            Test := StringMax
        test_case:
            Name := "Should be equal when compared"
            Test := EqualCompare
        test_case:
            Name := "Should be greater when compared"
            Test := GreaterCompare
        test_case:
            Name := "Should be less then when compared unnormalized"
            Test := GreaterCompareUnnormalized
        test_case:
            Name := "Should be less then when compared to other unnormalized"
            Test := GreaterCompareUnnormalizedOther
        test_case:
            Name := "Should subtract zero properly"
            Test := SubtractZero
        test_case:
            Name := "Should subtract values with same exponent"
            Test := SubtractWithSameExponent
        test_case:
            Name := "Should subtract up to the next exponent"
            Test := SubtractDownToNextExponent
        test_case:
            Name := "Should subtract a larger number from a smaller number"
            Test := SubtractIntoNegative
        test_case:
            Name := "Should stringify negative exponents to zero (TEMP)"
            Test := StringifyNegativeExponentToZero

    IsZero():?failure =
        # Arrange
        Number := num. Value := 0.0

        # Act, Assert
        if (not Number.IsZero[]). return fail("Number should be zero")

        # Pass
        return false

    IsZeroWithExponent():?failure =
        # Arrange
        Number := num{ Value := 0.0, Exponent := 3 }

        # Act, Assert
        if (not Number.IsZero[]). return fail("Number should be zero")

        # Pass
        return false

    Equals():?failure =
        # Arrange
        Number := num{ Value := 2.5, Exponent := 3 }
        Other := num{ Value := 2.5, Exponent := 3 }

        # Act, Assert
        if (not Number.Equals[Other]). return fail("Number should be zero")

        # Pass
        return false

    NormalizeAlwaysZero():?failure =
        # Arrange
        Number := num. Value := 0.0

        # Act
        Result := Number.Normalize()

        # Assert
        if (Result.Value <> 0.0 or Result.Exponent <> 0). return fail("Number should be zero")

        # Pass
        return false

    NormalizeAlreadyNormalized():?failure =
        # Arrange
        Number := num{ Value := 1.42, Exponent := 3 }

        # Act
        Result := Number.Normalize()

        # Assert
        if (Result.Value <> 1.42 or Result.Exponent <> 3). return fail("Number should be the same")

        # Pass
        return false

    NormalizeLessThanOne():?failure =
        # Arrange
        Number := num{ Value := 0.142, Exponent := 4 }

        # Act
        Result := Number.Normalize()

        # Assert
        if (Result.Value <> 1.42). return fail("Number value should have gone up.")
        if (Result.Exponent <> 3). return fail("Number exponent should have gone down.")

        # Pass
        return false

    NormalizeMoreThanTen():?failure =
        # Arrange
        Number := num{ Value := 14.2, Exponent := 2 }

        # Act
        Result := Number.Normalize()

        # Assert
        if (Result.Value <> 1.42). return fail("Number value should have gone down.")
        if (Result.Exponent <> 3). return fail("Number exponent should have gone up.")

        # Pass
        return false

    NormalizeNegativeNumber():?failure =
        # Arrange
        Number := num{ Value := -14.2, Exponent := 2 }

        # Act
        Result := Number.Normalize()

        # Assert
        if (Result.Value <> -1.42). return fail("Number value should still be negative.")
        if (Result.Exponent <> 3). return fail("Number exponent should have gone up.")

        # Pass
        return false

    SetNormalizeAlreadyFine():?failure =
        # Arrange
        Number := num{ Value := 14.2, Exponent := 3 }

        # Act
        Result := Number.SetNormalize()

        # Asser
        if (Result.Value <> 14.2). return fail("Number value should not have changed.")
        if (Result.Exponent <> 3). return fail("Number exponent should not have changed.")

        # Pass
        return false

    SetNormalize():?failure =
        # Arrange
        Number := num{ Value := 14.2, Exponent := 4 }

        # Act
        Result := Number.SetNormalize()

        # Asser
        if (Result.Value <> 142.0). return fail("Number value should have changed.")
        if (Result.Exponent <> 3). return fail("Number exponent should represent a set.")

        # Pass
        return false

    SetNormalizeWithZeroExponent():?failure =
        # Arrange
        Number := num{ Value := 142000.0, Exponent := 0 }

        # Act
        Result := Number.SetNormalize()

        # Asser
        if (Result.Value <> 142.0). return fail("Number value should have changed.")
        if (Result.Exponent <> 3). return fail("Number exponent should represent a set.")

        # Pass
        return false

    AddZero():?failure =
        # Arrange
        Number := num{ Value := 1.42, Exponent := 3 }

        # Act
        Result := Number.Add(num{})

        # Assert
        if (Result.Value <> 1.42). return fail("Number value should be the same")
        if (Result.Exponent <> 3). return fail("Number exponent should be the same.")

        # Pass
        return false

    AddWithSameExponent():?failure =
        # Arrange
        Number := num{ Value := 1.42, Exponent := 3 }

        # Act
        Result := Number.Add(num{ Value := 1.0, Exponent := 3 })

        # Assert
        if (Result.Value <> 2.42). return fail("Number value should be added together")
        if (Result.Exponent <> 3). return fail("Number exponent should be the same.")

        # Pass
        return false

    AddUpToNextExponent():?failure =
        # Arrange
        Number := num{ Value := 1.42, Exponent := 3 }

        # Act
        Result := Number.Add(num{ Value := 8.58, Exponent := 3 })

        # Assert
        if (Result.Value <> 1.0). return fail("Number value should be normalized to one.")
        if (Result.Exponent <> 4). return fail("Number exponent should be increased.")

        # Pass
        return false

    MultiplyByOne():?failure =
        # Arrange
        Number := num{ Value := 1.42, Exponent := 3 }

        # Act
        Result := Number.Multiply(1.0)

        # Assert
        if (Result.Value <> 1.42). return fail("Number value should not change.")
        if (Result.Exponent <> 3). return fail("Number exponent should not change.")

        # Pass
        return false

    MultiplyByTwo():?failure =
        # Arrange
        Number := num{ Value := 1.42, Exponent := 3 }

        # Act
        Result := Number.Multiply(2.0)

        # Assert
        if (Result.Value <> 2.84). return fail("Number value should be doubled.")
        if (Result.Exponent <> 3). return fail("Number exponent should not change.")

        # Pass
        return false

    MultiplyBy256():?failure =
        # Arrange
        Number := num{ Value := 1.42, Exponent := 3 }

        # Act
        Result := Number.Multiply(256.0)

        # Assert
        if (Result.Value < 3.6351 or Result.Value > 3.6353). return fail("Number value should be normalized.")
        if (Result.Exponent <> 5). return fail("Number exponent should have gone up.")

        # Pass
        return false

    SumValues():?failure =
        # Arrange
        Numbers := array:
            num. Value := 1.0
            num. Value := 2.0
            num. Value := 3.0

        # Act
        Result := Numbers.Sum()

        # Assert
        if (Result.Value < 5.9 or Result.Value > 6.1). return fail("Number was added wrong.")
        if (Result.Exponent <> 0). return fail("Number exponent should be zero.")

        # Pass
        return false

    StringZero():?failure =
        # Arrange
        Number := num. Value := 0.0

        # Act
        Result := "{Number}"

        # Assert
        if (not Result = "0"). return fail("Not the right string")

        # Pass
        return false

    StringSingleDigit():?failure =
        # Arrange
        Number := num. Value := 1.0

        # Act
        Result := "{Number}"

        # Assert
        if (not Result = "1"). return fail("Not the right string")

        # Pass
        return false

    StringDoubleDigit():?failure =
        # Arrange
        Number := num{ Value := 1.23, Exponent := 1 }

        # Act
        Result := "{Number}"

        # Assert
        if (not Result = "12"). return fail("Not the right string")

        # Pass
        return false

    StringLessThan1K():?failure =
        # Arrange
        Number := num. Value := 999.0

        # Act
        Result := "{Number}"

        # Assert
        if (not Result = "999"). return fail("Not the right string")

        # Pass
        return false

    String1KWithDecimals():?failure =
        # Arrange
        Number := num{ Value := 1.23456, Exponent := 3 }

        # Act
        Result := "{Number}"

        # Assert
        if (not Result = "1.23k"). return fail("Not the right string")

        # Pass
        return false

    StringOver100K():?failure =
        # Arrange
        Number := num{ Value := 1.23456, Exponent := 5 }

        # Act
        Result := "{Number}"

        # Assert
        if (not Result = "123k"). return fail("Not the right string")

        # Pass
        return false

    StringOver999Q():?failure =
        # Arrange
        Number := num{ Value := 1.23456, Exponent := 18 }

        # Act
        Result := "{Number}"

        # Assert
        if (not Result = "1.23A"). return fail("Not the right string")

        # Pass
        return false

    StringOver999A():?failure =
        # Arrange
        Number := num{ Value := 1.23456, Exponent := 21 }

        # Act
        Result := "{Number}"

        # Assert
        if (not Result = "1.23Ak"). return fail("Not the right string")

        # Pass
        return false

    StringMax():?failure =
        # Arrange
        Number := num{ Value := 9.99, Exponent := 485 }

        # Act
        Result := "{Number}"

        # Assert
        if (not Result = "999Zq"). return fail("Not the right string")

        # Pass
        return false

    EqualCompare():?failure =
        # Arrange
        Number := num{ Value := 1.0, Exponent := 0 }
        Other := num{ Value := 1.0, Exponent := 0 }

        # Act, Assert
        if (not Number.GreaterThanOrEqual[Other]). return fail("Other number is not equal")

        # Pass
        return false

    GreaterCompare():?failure =
        # Arrange
        Number := num{ Value := 2.0, Exponent := 0 }
        Other := num{ Value := 1.0, Exponent := 0 }

        # Act, Assert
        if (not Number.GreaterThanOrEqual[Other]). return fail("Number is not greater than or equal")

        # Pass
        return false

    GreaterCompareUnnormalized():?failure =
        # Arrange
        Number := num{ Value := 100.0, Exponent := 0 }
        Other := num{ Value := 1.67, Exponent := 1 }

        # Act, Assert
        if (not Number.GreaterThanOrEqual[Other]). return fail("Number should be greater than")

        # Pass
        return false

    GreaterCompareUnnormalizedOther():?failure =
        # Arrange
        Number := num{ Value := 1.67, Exponent := 1 }
        Other := num{ Value := 100.0, Exponent := 0 }

        # Act, Assert
        if (Number.GreaterThanOrEqual[Other]). return fail("Other should be greater than")

        # Pass
        return false

    SubtractZero():?failure =
        # Arrange
        Number := num{ Value := 1.42, Exponent := 3 }

        # Act
        Result := Number.Subtract(num{})

        # Assert
        if (Result.Value <> 1.42). return fail("Number value should be the same")
        if (Result.Exponent <> 3). return fail("Number exponent should be the same.")

        # Pass
        return false

    SubtractWithSameExponent():?failure =
        # Arrange
        Number := num{ Value := 2.42, Exponent := 3 }

        # Act
        Result := Number.Subtract(num{ Value := 1.0, Exponent := 3 })

        # Assert
        if (Result.Value <> 1.42). return fail("Number value should be subtracted from each other")
        if (Result.Exponent <> 3). return fail("Number exponent should be the same.")

        # Pass
        return false

    SubtractDownToNextExponent():?failure =
        # Arrange
        Number := num{ Value := 1.0, Exponent := 4 }

        # Act
        Result := Number.Subtract(num{ Value := 2.42, Exponent := 3 })

        # Assert
        if (Result.Value <> 7.58). return fail("Number value should be normalized.")
        if (Result.Exponent <> 3). return fail("Number exponent should be decreased.")

        # Pass
        return false

    SubtractIntoNegative():?failure =
        # Arrange
        InitialAmount := num{ Value := 1.23, Exponent := 3 }
        AmountToRemove := num{ Value := 2.3, Exponent := 3 }

        # Act
        Result := InitialAmount.Subtract(AmountToRemove)

        # Assert
        if (Result.Value <> -1.07). return fail("Number value should be negative.")
        if (Result.Exponent <> 3). return fail("Number exponent should not change.")

        # Pass
        return false

    StringifyNegativeExponentToZero():?failure =
        # Arrange
        Number := num{ Value := 2.0, Exponent := -1 }

        # Act
        Result := "{Number}"

        # Assert
        if (not Result = "0"). return fail("Not the right string")

        # Pass
        return false
