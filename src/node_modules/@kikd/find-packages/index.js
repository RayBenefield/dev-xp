import fs from 'fs';
import unglob from 'glob';
import match from 'minimatch';
import pick from 'lodash.pick';
import promisify from 'es6-promisify';
import { relative, resolve } from 'path';
import { sync as exists } from 'file-exists';

const glob = promisify(unglob);
const lstat = promisify(fs.lstat);
const have = file => path => match(file, path);

export default ({ root = '.', exclude = [] } = {}) =>
    new Promise(async (res, rej) => {
        try {
            const packagesDir = resolve(root, 'src/node_modules');
            const stats = await lstat(packagesDir);

            if (!stats.isDirectory)
                return rej('The `src/node_modules` directory does not exist!');

            const paths = resolve(packagesDir, '{[^@]*/,@*/*/}');
            const packageDirs = await glob(paths);
            const packages = packageDirs
                .filter(dir => !exclude.some(have(dir)))
                .map(dir => relative(resolve(root, 'src/node_modules'), dir))
                .map(name => ({
                    name,
                    dir: relative(
                        root,
                        resolve(root, 'src/node_modules', name),
                    ),
                    distDir: relative(root, resolve(root, 'dist', name)),
                }))
                .map(details => {
                    const packageJson = resolve(
                        root,
                        details.dir,
                        'package.json',
                    );
                    if (exists(packageJson, { root })) return details;

                    try {
                        // eslint-disable-next-line global-require, import/no-dynamic-require
                        const config = require(packageJson);
                        const props = pick(config, ['version', 'bin', 'main']);

                        return { ...details, ...props, config };
                    } catch (e) {
                        return details;
                    }
                });

            return res(packages);
        } catch (error) {
            return rej(error);
        }
    });
