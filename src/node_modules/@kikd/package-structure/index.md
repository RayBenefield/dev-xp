# Get Package Structure

Here we discover the core similiarities between all packages in an
[**Alle**](https://github.com/boennemann/alle) style repo. This includes file
structure, source location, and destination. This allows us to then use this
file structure to decipher how to handle packages... eventually labeling them
with types in order to enable the plugin system in
[**KI/KD**](https://github.com/RayBenefield/dev-xp/tree/master/src/node_modules/kikd).

---

## Dependencies

`path.relative` is used to make sure we have a non-side affected path to use for
details, and `path.resolve` is used to make sure we get the absolute path before
getting the relative. `fs.readdirSync` is used for getting the list of files in
a package directory... currently it is not recursive.

```js
import collapse from '@kikd/collapse'
import { relative, resolve } from 'path'
import { readdirSync as readDir } from 'fs'
```

---

## Logic

### Cache

This could be called multiple times within a single command's life cycle and we
want to make that as efficient as possible so we setup a `cache` to store
details as soon as we have them.

```js
const cache = {}
```

### Fetch structure

We accept the repository `root` as well as the package's name to help us find
what we need since name is directly linked to the project structure. Before we
commit to any work, we check the cache and if we have already done the work
before we return it.

```js
const getStructure = ({ root, name }) => {
    if (name in cache) return { [name]: cache[name] }
```

We start by fetching the relevant directories. Knowing where the package
originates from, and where all build artifacts need to chill at.

```js
const srcDir = relative(root, resolve(root, 'src/node_modules', name))
const destDir = relative(root, resolve(root, 'dist', name))
```

The exact files in a package can give us details into the type of package, for
example an `index.md` means that this may actually be a **Single File Package**,
hinting at the need to read it differently.

```js
const files = readDir(resolve(root, srcDir))
```

Finally we setup the final structure of the return, store in the `cache` and
then move forward.

```js
    const structure = { name, srcDir, destDir, files }
    cache[structure.name] = structure

    return { [name]: structure }
}
```

```js
export default ({ root, packageNames = [] }) =>
    packageNames.map(name => getStructure({ root, name })).reduce(collapse, {})
```

---

## TODO

*   Fix `@kikd/destination-details` to use new structures/manifests
*   Fix `@kikd/template-publishable-packages` to use new structures/manifests
*   Fix `@kikd/prompt-pick-package` to use new structures/manifests
*   Fix `@semcom/update-packages` to use new structures/manifests
*   Fix `@semcom/command-prerelease` to use new structures/manifests

```

```
