import fs from 'fs'
import { extname, resolve } from 'path'

import detective from 'detective-es6'
import promisify from 'es6-promisify'
import collapse from '@kikd/collapse'
import parseSfp from '@entyre/parse-sfp'
import { sync as exists } from 'file-exists'

const lstat = promisify(fs.lstat)
const readFile = promisify(fs.readFile)
const cache = {}

export default ({ root, packages }) =>
    async function detect({ name, main, bin, files = [] } = {}) {
        if (!name) return {}
        const dir = resolve(root, name)
        const sourceFile =
            main ||
            (bin
                ? Object.values(bin)[0]
                : files.includes('index.md') ? 'index.md' : 'index.js')

        if (!exists(resolve(dir, sourceFile))) return {}

        return readFile(resolve(dir, sourceFile), 'utf-8')
            .then(
                content =>
                    extname(sourceFile) === '.md'
                        ? parseSfp({ content }).code
                        : content
            )
            .then(detective)
            .then(result =>
                Promise.all(
                    result.map(async dependency => {
                        try {
                            if (dependency in cache) return cache[dependency]

                            const depDir = resolve(root, dependency)
                            await lstat(depDir)
                            return detect(packages[dependency])
                                .then(
                                    deps =>
                                        Object.keys(deps).length === 0 &&
                                        deps.constructor === Object
                                            ? { [dependency]: false }
                                            : { [dependency]: deps }
                                )
                                .then(tree => {
                                    cache[dependency] = tree
                                    return tree
                                })
                        } catch (e) {
                            return { [dependency]: false }
                        }
                    })
                ).then(results => results.reduce(collapse, {}))
            )
    }
