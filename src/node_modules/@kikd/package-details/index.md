# Get Package Details

For
[**KI/KD**](https://github.com/RayBenefield/dev-xp/tree/master/src/node_modules/kikd)
to function properly we need to be able to fetch all details about a given
package. The package directory is assumed to be `src/node_modules`. This setup
is inspired by an [**Alle**](https://github.com/boennemann/alle) monorepo setup
that utilizes the node.js require algoritihm, to grab packages locally first
before grabbing external packages.

---

## Dependencies

We need `lodash.pick` to just extract some properties from a config file that
matter. `path.relative` is used to make sure we have a non-side affected path to
use for details, and `path.resolve` is used to make sure we get the absolute
path before getting the relative. `fs.readdirSync` is used for getting the list
of files in a package directory... currently it is not recursive. And
`file-exists` is used to confirm a `package.json` exists to avoid random errors.

```js
import pick from 'lodash.pick'
import { relative, resolve } from 'path'
import { readdirSync as readDir } from 'fs'
import { sync as exists } from 'file-exists'
```

---

## Logic

### Cache

This could be called multiple times within a single command's life cycle and we
want to make that as efficient as possible so we setup a cache to store details
as soon as we have them.

```js
const cache = {}
```

### Detail Fetching

In order to properly utilize the cache, we separate out the actual detail
fetching to a function, that then fills the cache at the end. The `root` is
needed to make sure we grab the proper paths.

```js
const getDetails = ({ root, name }) => {
```

We start by fetching the relevant directories. Knowing where the package
originate from, and where all build artifacts need to chill at.

```js
const dir = relative(root, resolve(root, 'src/node_modules', name))
const distDir = relative(root, resolve(root, 'dist', name))
```

Sometimes the exact files in a package can give us details into the type of
package, for example an `index.md` means that this may actually be a **Single
File Package**, hinting at the need to read it differently.

```js
const files = readDir(resolve(root, dir))
```

We need to grab the relevant metadata for the package as it typically contains
important information for building, publishing, etc. We also extract the key
portions and through it in the root of the details.

```js
const packageJson = resolve(root, dir, 'package.json')
// eslint-disable-next-line global-require, import/no-dynamic-require
const config = exists(packageJson) ? require(packageJson) : {}
const props = pick(config, ['version', 'bin', 'main'])
```

With everything gathered we structure the results and then cache it and return
it.

```js
    const details = { name, dir, distDir, files, config, ...props }
    cache[details.name] = details

    return details
}
```

### Map all the packages

The core functionality of this package is to accept a list of `packageNames`
that are relevant and a `root` that we can work off of for the entire
repository, and then fetch all the details. We check the cahce first and if it
isn't there then we do the detail fetching.

```js
export default ({ root = '.', packageNames = [] }) =>
    packageNames.map(
        pkg => (pkg in cache ? cache[pkg] : getDetails({ root, name: pkg }))
    )
```
