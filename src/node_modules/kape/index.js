/* eslint-disable no-console */
import fs from 'fs';
import slugify from 'slugify';
import kapeRun from '@kape/run';
import callsite from 'callsite';
import 'loud-rejection/register';
import child from 'child_process';
import groupBy from 'lodash.groupby';
import promisify from 'es6-promisify';
import { resolve, dirname } from 'path';
import { obj as stream } from 'through2';
import { red, white, green, grey, underline } from 'chalk';
import updateSnapshots from '@kape/update-snapshots';
import sequentialPromises from '@kape/sequential-promises';

const readFile = promisify(fs.readFile);

export const run = kapeRun;

const getSnapshotDir = testFile => resolve(dirname(testFile), '__snapshots__');

const getSuiteFile = (snapshotDir, suite) =>
    resolve(snapshotDir, `${slugify(suite, { lower: true })}.js.snap`);

const printPass = ({ test, index }) =>
    `    ${green('✔')} ${grey(test)} ${white('#')}${white(index)}`;

const printAdd = ({ test, index }) =>
    `    ${green('+')} ${green(test)} ${green.bold('#')}${green.bold(index)}`;

const printFail = ({ test, index }) =>
    `    ${red('✖')} ${red(test)} ${red.bold('#')}${red.bold(index)}`;

const withResultPrinter = results =>
    console.log(
        results
            .map(result => {
                if (result.snapshotMatched) return printPass(result);
                if (!result.previousSnapshot) return printAdd(result);
                return printFail(result);
            })
            .join('\n'),
    );

const getPreviousSnapshots = suiteSnapshotFile =>
    readFile(suiteSnapshotFile, 'utf8')
        .then(contents => {
            // eslint-disable-next-line no-new-func
            const generate = new Function('exports', contents);
            const snapshots = {};
            generate(snapshots);
            return snapshots;
        })
        .catch(() => []);

const testSnapshots = previousSnapshots => result => ({
    ...result,
    previousSnapshot: previousSnapshots[`${result.test} ${result.id}`] || null,
    snapshotMatched: previousSnapshots[`${result.test} ${result.id}`]
        ? result.snapshot.trim() ===
          previousSnapshots[`${result.test} ${result.id}`].trim()
        : false,
});

const testStream = stream();
const suitesCompleted = {};
const suiteInfo = {};

export default (...args) => {
    const isWorker = typeof process.send === 'function';
    const suite = args[0];
    const testFile = callsite()[1].getFileName();
    const snapshotDir = getSnapshotDir(testFile);
    const suiteSnapshotFile = getSuiteFile(snapshotDir, suite);

    if (isWorker) {
        return getPreviousSnapshots(suiteSnapshotFile).then(
            previousSnapshots => {
                const suiteStream = run(...args);
                const testResult = testSnapshots(previousSnapshots);
                suiteStream.on('data', result =>
                    process.send({
                        kape: true,
                        type: 'result',
                        payload: testResult(result),
                    }),
                );
                suiteStream.on('end', () => {
                    process.send({ kape: true, type: 'end' });
                    process.exit();
                });
            },
        );
    }

    const suiteProcess = child.fork(testFile);
    suiteInfo[suite] = { suiteSnapshotFile, snapshotDir };
    suitesCompleted[suite] = false;
    suiteProcess.on('message', msg => {
        if (!msg.kape) return;

        switch (msg.type) {
            case 'result': {
                testStream.push({ suite, ...msg.payload });
                break;
            }
            case 'end': {
                suitesCompleted[suite] = true;
                const weAreDone = Object.values(suitesCompleted).every(
                    status => status === true,
                );
                if (weAreDone) testStream.push(null);
                break;
            }
            default:
        }
    });
    return Promise.resolve();
};

const results = [];
testStream.on('data', result => results.push(result));
testStream.on('end', () => {
    const suites = groupBy(results, 'suite');
    Object.entries(suites).forEach(([suite, suiteResults]) => {
        console.log(`\n  ${underline(suite)}\n`);
        withResultPrinter(suiteResults);
    });
    console.log('\n');
    console.log(`  total:     ${results.length}`);
    console.log(green(`  passing:   ${results.length}`));
    console.log('\n');
    return sequentialPromises(
        Object.entries(suites).map(([suite, testedResults]) => () =>
            updateSnapshots({
                ...suiteInfo[suite],
                testedResults,
            }),
        ),
    ).then(() => process.exit());
});
