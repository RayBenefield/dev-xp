/* eslint-disable no-console */
import callsite from 'callsite';
import print from '@kape/print';
import 'loud-rejection/register';
import child from 'child_process';
import { obj as stream } from 'through2';
import runWorkload from '@kape/run-workload';
import updateSnapshots from '@kape/update-snapshots';
import sequentialPromises from '@kape/sequential-promises';

const testStream = stream();
const suitesCompleted = {};
const suiteFiles = {};

export default (...args) => {
    const isWorker = typeof process.send === 'function';
    const [suite] = args;
    const file = callsite()[1].getFileName();

    if (isWorker) return runWorkload({ file, suite, args });

    const fileProcess = child.fork(file);
    suitesCompleted[suite] = false;
    suiteFiles[suite] = file;
    fileProcess.on('message', msg => {
        if (!msg.kape) return;

        switch (msg.type) {
            case 'result': {
                testStream.push({ suite, ...msg.payload });
                break;
            }
            case 'end': {
                suitesCompleted[suite] = true;
                const weAreDone = Object.values(suitesCompleted).every(
                    status => status === true,
                );
                if (weAreDone) testStream.push(null);
                break;
            }
            default:
        }
    });
    return Promise.resolve();
};

const results = [];
testStream.on('data', result => results.push(result));
testStream.on('end', () =>
    print(results).then(suites =>
        sequentialPromises(
            Object.entries(suites).map(([suite, testedResults]) => () =>
                updateSnapshots({
                    suite,
                    file: suiteFiles[suite],
                    testedResults,
                }),
            ),
        ).then(() => process.exit()),
    ),
);
