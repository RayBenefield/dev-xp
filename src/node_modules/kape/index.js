/* eslint-disable no-console */
import callsite from 'callsite';
import 'loud-rejection/register';
import child from 'child_process';
import groupBy from 'lodash.groupby';
import { obj as stream } from 'through2';
import runWorkload from '@kape/run-workload';
import { red, white, green, grey, underline } from 'chalk';
import updateSnapshots from '@kape/update-snapshots';
import sequentialPromises from '@kape/sequential-promises';

const printPass = ({ test, index }) =>
    `    ${green('✔')} ${grey(test)} ${white('#')}${white(index)}`;

const printAdd = ({ test, index }) =>
    `    ${green('+')} ${green(test)} ${green.bold('#')}${green.bold(index)}`;

const printFail = ({ test, index }) =>
    `    ${red('✖')} ${red(test)} ${red.bold('#')}${red.bold(index)}`;

const withResultPrinter = results =>
    console.log(
        results
            .map(result => {
                if (result.snapshotMatched) return printPass(result);
                if (!result.previousSnapshot) return printAdd(result);
                return printFail(result);
            })
            .join('\n'),
    );

const testStream = stream();
const suitesCompleted = {};
const suiteFiles = {};

export default (...args) => {
    const isWorker = typeof process.send === 'function';
    const [suite] = args;
    const file = callsite()[1].getFileName();

    if (isWorker) return runWorkload({ file, suite, args });

    const fileProcess = child.fork(file);
    suitesCompleted[suite] = false;
    suiteFiles[suite] = file;
    fileProcess.on('message', msg => {
        if (!msg.kape) return;

        switch (msg.type) {
            case 'result': {
                testStream.push({ suite, ...msg.payload });
                break;
            }
            case 'end': {
                suitesCompleted[suite] = true;
                const weAreDone = Object.values(suitesCompleted).every(
                    status => status === true,
                );
                if (weAreDone) testStream.push(null);
                break;
            }
            default:
        }
    });
    return Promise.resolve();
};

const results = [];
testStream.on('data', result => results.push(result));
testStream.on('end', () => {
    const suites = groupBy(results, 'suite');
    Object.entries(suites).forEach(([suite, suiteResults]) => {
        console.log(`\n  ${underline(suite)}\n`);
        withResultPrinter(suiteResults);
    });
    console.log('\n');
    console.log(`  total:     ${results.length}`);
    console.log(green(`  passing:   ${results.length}`));
    console.log('\n');
    return sequentialPromises(
        Object.entries(suites).map(([suite, testedResults]) => () =>
            updateSnapshots({ suite, file: suiteFiles[suite], testedResults }),
        ),
    ).then(() => process.exit());
});
