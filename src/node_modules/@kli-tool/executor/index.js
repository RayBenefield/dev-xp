import parse from 'minimist'
import RenderKid from 'renderkid'
import * as _ from '@dev-xp/utils'
import * as log from '@dev-xp/log'
import * as $ from '@dev-xp/strings'
import { isolate } from 'transmutation'
import convertArgs from '@kli-tool/convert-args'
import { render as prettyJson } from 'prettyjson'
import getKeys from '@kli-tool/get-keys-with-path'

const prettify = _.curryN(1, prettyJson)
const formatValue = _.ifElse(_.is(Array), _.join('\n'), prettify)
const printer = render => _.pipe(formatValue, render)
const byType = _.indexBy(_.prop('type'))

export default ({ config, renderer, style, decide } = {}) =>
    // eslint-disable-next-line complexity
    (unparsed = ['']) => {
        const parsed = parse(unparsed, { boolean: true })
        const {
            _: [request, ...commandArgs],
            commit,
            json,
            dry,
            keys,
        } = parsed

        const command = decide(request)

        const { plugins: unkeyed = [] } = config
        const plugins = byType(unkeyed)
        const { plugs = {} } = command
        const args = { ...parsed, _: commandArgs }
        const newArgs = convertArgs({ args, conversions: command.args })
        const finalConfig = {
            ...config,
            ...newArgs,
            plugins,
            plug: fn => data => {
                // If you are debugging a problem with a third party library using KLI
                // Let the devs know they need to add the respective plug to the command
                if (!(fn in plugs)) throw Error($.noPlug(command.name, fn))

                const { type } = data
                if (!type) return plugs[fn](data)

                const plugin = plugins[type] || {}
                const plug = plugin[fn] || plugs[fn]

                return plug(data)
            },
            plugAll: fn => data => {
                // If you are debugging a problem with a third party library using KLI
                // Let the devs know they need to add the respective plug to the command
                if (!(fn in plugs)) throw Error($.noPlug(command.name, fn))

                const allFns = _.map(_.prop(fn))(plugins)
                const fns = _.filter(_.identity, _.values(allFns))

                if (fns.length <= 0) return {}

                const results = _.map(_.applyTo(data), allFns)
                return results
            },
        }

        const formatter = new RenderKid()
        formatter.style(style)
        const run = () => command.run(finalConfig)
        const template = command.template
            ? data => formatter.render(command.template(finalConfig)(data))
            : _.identity
        const effect = command.effect
            ? data => command.effect(finalConfig)(data)
            : _.identity

        const result = Promise.resolve(run())

        const render = command.renderer || renderer
        const print = printer(render)

        if (keys) return result.then(results => print(getKeys(results, keys)))
        if (json) {
            const path = () => (json.indexOf(',') >= 0 ? json.split(',') : json)
            const paths = json === true ? [] : path()

            const newRun = _.pipe(
                run,
                _.andThen(isolate(paths)),
                _.andThen(print)
            )
            return newRun()
        }
        return result.then(data => {
            render(template(data))

            if (commit || (command.autoCommit && !dry)) effect(data)
        })
    }
