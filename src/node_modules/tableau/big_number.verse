using { /Verse.org/Simulation }

#################################
# We can represent very big numbers as a struct containing both a value and an exponent
#################################
big_number<public> := class<concrete>:
    @editable Value<public>:float = 0.0
    @editable Exponent<public>:int = 0

    IsZero<public>()<decides><transacts>:void = Value = 0.0 and Exponent = 0

#################################
# Below are various functions to operate on big numbers
#################################

# Adds two big_numbers together
BigNumber_Add<public>(NumberA : big_number, NumberB : big_number):big_number=
    CommonExponent : int = Max(NumberA.Exponent, NumberB.Exponent)

    NewValue : float =  (NumberA.Value * Pow(10.0, (NumberA.Exponent - CommonExponent) * 1.0)) +
                        (NumberB.Value * Pow(10.0, (NumberB.Exponent - CommonExponent) * 1.0))

    BigNumber_Normalize(big_number{Value := NewValue, Exponent := CommonExponent})
operator'+'<public>(LHS:big_number, RHS:big_number):big_number = BigNumber_Add(LHS, RHS)

Big_Number_Sum<public>(All:[]big_number):big_number=
    var Total:big_number = big_number{}
    for(Num:All). set Total = Total + Num
    return Total

# Subtracts a big_number from another
BigNumber_Subtract(NumberA : big_number, NumberB : big_number):big_number=
    CommonExponent : int = Max(NumberA.Exponent, NumberB.Exponent)

    NewValue : float =  (NumberA.Value * Pow(10.0, (NumberA.Exponent - CommonExponent) * 1.0)) -
                        (NumberB.Value * Pow(10.0, (NumberB.Exponent - CommonExponent) * 1.0))

    BigNumber_Normalize(big_number{Value := NewValue, Exponent := CommonExponent})

# Multiply two big_numbers together
BigNumber_Multiply(NumberA : big_number, NumberB : big_number):big_number=
    NewValue := NumberA.Value * NumberB.Value
    NewExponent := NumberA.Exponent + NumberB.Exponent

    BigNumber_Normalize(big_number{Value := NewValue, Exponent := NewExponent})
operator'*'<public>(LHS:big_number, RHS:big_number):big_number = BigNumber_Multiply(LHS, RHS)

# Multiply a big_number with a float
BigNumber_Multiply(NumberA : big_number, NumberB : float):big_number=
    NewValue := NumberA.Value * NumberB
    NewExponent := NumberA.Exponent

    BigNumber_Normalize(big_number{Value := NewValue, Exponent := NewExponent})
operator'*'<public>(LHS:big_number, RHS:float):big_number = BigNumber_Multiply(LHS, RHS)
operator'*'<public>(LHS:big_number, RHS:int):big_number = BigNumber_Multiply(LHS, RHS * 1.0)

# Tells you if one big_number is greater than another
BigNumber_GreaterThanOrEquals(NumberA : big_number, NumberB : big_number):logic=
    if:
        NumberA.Exponent > NumberB.Exponent or (NumberA.Exponent = NumberB.Exponent and NumberA.Value >= NumberB.Value)
    then:
        return true

    return false

# Tells you how much it would cost to buy X items
#   Start is how many items you currently own, and count is how many you would like to purchase (used for price scaling)
#   CommonRatio refers to the scaling in price for subsequent purchases.  If set to 1.0, no price scaling occurs.
BigNumber_CalculateCostRange(BaseCost : big_number, Start : int, Count : int, CommonRatio : float):big_number=
    term1 := Pow(CommonRatio, (Start + Count)*1.0);
    term2 := Pow(CommonRatio, Start * 1.0);

    TotalCost_Value := BaseCost.Value * (term1 - term2) / (CommonRatio - 1.0);
    TotalCost_Exponent := BaseCost.Exponent;

    BigNumber_Normalize(big_number{Value:=TotalCost_Value, Exponent:=TotalCost_Exponent});


# Tells you how many items you could afford to purchase
#   CommonRatio refers to the scaling in price for subsequent purchases.  If set to 1.0, no price scaling occurs.
BigNumber_CalculateAffordableItems(CurrentMoney : big_number, BaseCost : big_number, AmountOwned : int, CommonRatio : float):int=
    var AffordableItems : int = 1
    loop:
        Affordable := BigNumber_GreaterThanOrEquals(CurrentMoney, BigNumber_CalculateCostRange(BaseCost, AmountOwned, AffordableItems, CommonRatio))
        if:
            not Affordable?
        then:
            break

        set AffordableItems += 1

    return AffordableItems - 1


# Formats a big_number into a string
ToString<public>(ValueIN : big_number):string=
    if (ValueIN.Value = 0):
        return "0"

    CorrectedNumber := BigNumber_NormalizeToNearestNumberSet(ValueIN)

    if:
        CorrectedNumber.Exponent < 3
        ValueAsInt := Floor[CorrectedNumber.Value]
    then:
        return "{ValueAsInt}"

    var ValueAsString : string = "{CorrectedNumber.Value}"

    var TargetLength : int = 4
    if(CorrectedNumber.Value >= 100.0):
        set TargetLength = 3

    if:
        Value := ValueAsString.Remove[TargetLength, ValueAsString.Length]
        set ValueAsString = Value

    if:
        SuffixIndex : int = Quotient[CorrectedNumber.Exponent, 3]
        set ValueAsString += NumberSuffixes[SuffixIndex](0)

    ValueAsString


NumberSuffixes : []tuple(string, string) = array:
    ("-", ""),
    ("K", "Thousand"),
    ("M", "Million"),
    ("B", "Billion"),
    ("T", "Trillion"),
    ("Qa", "Quadrillion"),
    ("Qt", "Quintillion"),
    ("Sx", "Sextillion"),
    ("Sp", "Septillion"),
    ("Oc", "Octillion"),
    ("Nn", "Nonillion"),
    ("Dc", "Decillion"),
    ("UDc", "Un-Decillion"),
    ("DDc", "Duo-Decillion"),
    ("TDc", "Tre-Decillion"),
    ("QaDc", "Quattuor-Decillion"),
    ("QtDc", "Quin-Decillion"),
    ("SxDc", "Se-Decillion"),
    ("SpDc", "Septen-Decillion"),
    ("ODc", "Octo-Decillion"),
    ("NDc", "Noven-Decillion"),
    ("Vi", "Vigintillion"),
    ("UVi", "Un-Vigintillion"),
    ("DVi", "Duo-Vigintillion"),
    ("TVi", "Tre-Vigintillion"),
    ("QaVi", "Quattuor-Vigintillion"),
    ("QtVi", "Quin-Vigintillion"),
    ("SxVi", "Ses-Vigintillion"),
    ("SpVi", "Septen-Vigintillion"),
    ("OcVi", "Octo-Vigintillion"),
    ("NnVi", "Noven-Vigintillion"),
    ("Tg", "Trigintillion"),
    ("UTg", "Un-Trigintillion"),
    ("DTg", "Duo-Trigintillion"), # 10^99, Googol is 10^100
    ("TTg", "Tre-Trigintillion"),
    ("QaTg", "Quattuor-Trigintillion"),
    ("QtTg", "Quin-Trigintillion"),
    ("SxTg", "Ses-Trigintillion"),
    ("SpTg", "Septen-Trigintillion"),
    ("OcTg", "Octo-Trigintillion"),
    ("NnTg", "Noven-Trigintillion"),
    ("Qd", "Quadragintillion"),
    ("UQd", "Un-Quadragintillion"),
    ("DQd", "Duo-Quadragintillion"),
    ("TQd", "Tre-Quadragintillion"),
    ("QaQd", "Quattuor-Quadragintillion"),
    ("QtQd", "Quin-Quadragintillion"),
    ("SxQd", "Ses-Quadragintillion"),
    ("SpQd", "Septen-Quadragintillion"),
    ("OcQd", "Octo-Quadragintillion"),
    ("NnQd", "Noven-Quadragintillion"),
    ("Qq", "Quinquagintillion"),
    ("UQq", "Un-Quinquagintillion"),
    ("DQq", "Duo-Quinquagintillion"),
    ("TQq", "Tre-Quinquagintillion"),
    ("QaQq", "Quattuor-Quinquagintillion"),
    ("QtQq", "Quin-Quinquagintillion"),
    ("SxQq", "Ses-Quinquagintillion"),
    ("SpQq", "Septen-Quinquagintillion"),
    ("OcQq", "Octo-Quinquagintillion"),
    ("NnQq", "Noven-Quinquagintillion"),
    ("Sg", "Sexagintillion")

# Takes a big_number, and converts it to ensure a single-digit whole-number component for the Value field
#   Ex)  14.2 * 10^2  will become 1.42 * 10^3
BigNumber_Normalize(Number : big_number):big_number=
    var NewExponent : int = Number.Exponent
    var NewValue : float = Number.Value

    if (NewValue <= 0.0):
        return NewResult := big_number{}

    loop:
        if (NewValue < 10.0):
            break
        set NewValue *= 0.1
        set NewExponent += 1

    loop:
        if (NewValue >= 1.0):
            break
        set NewValue *= 10.0
        set NewExponent -= 1

    Result := big_number:
        Value := NewValue
        Exponent := NewExponent


# Takes a big_number, and converts it to ensure a 1,2 or 3 digit whole-number component for the Value field.  This is used for string formatting.
#   Ex)  1.42K or 14.2K or 142K are all valid
#        1420k is not valid, and should instead be 1.42M
BigNumber_NormalizeToNearestNumberSet(Number : big_number):big_number=
    var NewExponent : int = Number.Exponent
    var NewValue : float = Number.Value

    loop:
        if (Mod[NewExponent, 3] = 0):
            break

        set NewValue *= 10.0
        set NewExponent -= 1

    Result := big_number:
        Value := NewValue
        Exponent := NewExponent
