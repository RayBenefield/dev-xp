
using { /Verse.org/Simulation }

controller<public> := interface():
    Triage<public>()<suspends>:void

command<public> := class():
    Subject<public>:string = ""
    Property<public>:string = ""
    Target<public>:string = ""
    Pay<public>:load = load{}
    AfterEffects<public>:[]effect = array{}

CopyCommand<public><constructor>(Old:command) := command:
    Subject := Old.Subject
    Property := Old.Property
    Target := Old.Target
    Pay := Old.Pay
    AfterEffects := Old.AfterEffects

CopyEvent<constructor><public>(Old:domain_event) := domain_event:
    Event := Old.Event
    SubjectType := Old.SubjectType
    Subject := Old.Subject
    TargetType := Old.TargetType
    Target := Old.Target
    Property := Old.Property

domain_event<public> := class:
    Event<public>:ev
    SubjectType<public>:entity
    Subject<public>:string
    TargetType<public>:?entity = false
    Target<public>:string = ""
    Property<public>:string = ""

    Equals<public>(Other:domain_event)<decides><transacts>:void=
        SubjectType.Name() = Other.SubjectType.Name()
        Subject = Other.Subject
        Event.Name() = Other.Event.Name()
        if (TargetType?):
            TargetType?.Name() = Other.TargetType?.Name()
            Target = Other.Target
        Property = Other.Property

(List:[]domain_event).Includes<public>(Target:domain_event)<decides><transacts>:void=
    Equals := for(Ev:List, Ev.Equals[Target]). Ev
    Equals.Length > 0

dispatcher<public> := class():
    DomainEventTriggered:event([]domain_event) := event([]domain_event){}
    DomainEvents<public>():event([]domain_event)=DomainEventTriggered

    Dispatch<public>(Event:domain_event):void = DomainEventTriggered.Signal(array. Event)
    Dispatch<public>(Events:[]domain_event):void = DomainEventTriggered.Signal(Events)

load<public> := class<concrete>():
    @editable Str<public>:string = ""
    @editable Float<public>:float = 1.0
    @editable Num<public>:num = num{}

effect<public> := class<concrete>():
    @editable FN<public>:string = ""
    @editable Pay<public>:load = load{}

effector<public> := interface():
    Play<public>(Source:command, Pay:load)<suspends>:command

entity<public> := interface:
    Name<public>()<computes>:string

ev<public> := interface:
    Name<public>()<computes>:string

event_subscription<public> := struct:
    SubjectType<public>:entity
    Subject<public>:?string = false
    Event<public>:?ev = false

service<public> := interface() {}

updatable<public> := interface():
    Update<public>()<suspends>:void
    ClearState<public>()<suspends>:void
    Subscriptions<public>()<transacts>:[]event_subscription

(Updatable:updatable).FreshUpdate<public>()<suspends>:void=
    Updatable.ClearState()
    Updatable.Update()

mutator<public> := interface():
    ApplyEvents<public>(Events:[]domain_event):void

# (Updatable:updatable).ClearState<override>()<suspends>:void = {}
# (Updatable:updatable).Subscriptions<override>()<transacts>:[]event_subscription = array{}

computer<public> := class<concrete>():
    @editable FN<public>:string = ""
    @editable Pay<public>:load = load{}

num_computer_provider<public> := class():
    var NumComputers:[string]num_computer = map{}

    Register<public>(FN:string, NumComputer:num_computer):void=
        if (set NumComputers[FN] = NumComputer) {}

    Get<public>(FN:string)<decides><transacts>:num_computer = NumComputers[FN]

multiply_num_computer<public> := class(num_computer):
    FN<override>(First:num, Second:num):num = First * First

num_computer<public> := interface:
    FN<public>(First:num, Second:num):num

comp_prop<public>(t:type) := class:
    ID<public>:string
    BaseProp<public>:string
    Computer<public>:computer

comp_float<public> := class<concrete>(comp_prop(float)):
    @editable ID<override>:string = ""
    @editable BaseProp<override>:string = ""
    @editable Computer<override>:computer = computer{}

comp_num<public> := class<concrete>(comp_prop(num)):
    @editable ID<override>:string = ""
    @editable BaseProp<override>:string = ""
    @editable Computer<override>:computer = computer{}

comp_str<public> := class<concrete>(comp_prop(string)):
    @editable ID<override>:string = ""
    @editable BaseProp<override>:string = ""
    @editable Computer<override>:computer = computer{}

prop_type<public> := enum:
    Num
    Str
    Float
    StatNum
    StatStr
    StatFloat
    CompNum
    CompStr
    CompFloat
    Unknown

ToString<public>(Type:prop_type):string = case(Type):
    prop_type.Num => "Num"
    prop_type.Str => "Str"
    prop_type.Float => "Float"
    prop_type.StatNum => "StatNum"
    prop_type.StatStr => "StatStr"
    prop_type.StatFloat => "StatFloat"
    prop_type.CompNum => "CompNum"
    prop_type.CompStr => "CompStr"
    prop_type.CompFloat => "CompFloat"
    prop_type.Unknown => "Unknown"
