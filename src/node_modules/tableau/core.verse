
using. /Verse.org/Random
using. /Verse.org/Simulation
using. /UnrealEngine.com/Temporary/SpatialMath

using. Goo
using. Numb
using. TableauEffect
using. TableauResource
using. Vertex

Path<public><constructor>(PropertyID:string)<transacts> := half_path. PropertyID := option. PropertyID
Path<public><constructor>(PropPath:half_path)<transacts> := half_path. PropertyPath := option. PropPath
Path<public><constructor>(ResourcePath:half_path, PropertyID:string)<transacts> := half_path:
    ResourcePath := option. ResourcePath
    PropertyID := option. PropertyID
Path<public><constructor>(ResID:string, PropertyPath:half_path)<transacts> := half_path:
    ResourceID := option. ResID
    PropertyPath := option. PropertyPath
Path<public><constructor>(ResourcePath:half_path, PropPath:half_path)<transacts> := half_path:
    ResourcePath := option. ResourcePath
    PropertyPath := option. PropPath
Path<public><constructor>(ResourceID:string, PropertyID:string)<transacts> := half_path:
    ResourceID := option. ResourceID
    PropertyID := option. PropertyID

half_path<public> := class<concrete>():
    @editable ResourceID<public>:?string = false
    @editable PropertyID<public>:?string = false
    @editable ResourcePath<public>:?half_path = false
    @editable PropertyPath<public>:?half_path = false
(HP:half_path).Empty<public>()<decides><computes>:void=
    not HP.ResourceID? and not HP.PropertyID? and not HP.ResourcePath? and not HP.PropertyPath?
(HP:half_path).TryComplete<public>(ResourceID:string)<transacts>:?prop_path=
    if (R := HP.ResourceID?, P := HP.PropertyID?). return option. prop_path{ ResourceID := R, PropertyID := P }
    if (not HP.ResourcePath?, P := HP.PropertyID?). return option. prop_path{ ResourceID := ResourceID, PropertyID := P }
    return false
(HP:half_path).GetKey<public>()<transacts>:string=
    (if (RP := HP.ResourcePath?). "({RP.GetKey()})"
    else. (if (R := HP.ResourceID?). "{R}" else. "?")) +
    "." +
    (if (PP := HP.PropertyPath?). "({PP.GetKey()})"
    else. (if (P := HP.PropertyID?). "{P}" else. "?"))
ToString<public>(P:half_path)<transacts>:string= Tab("[HALF PATH]") +
    (if (S := P.ResourceID?). WithIndent("ResourceID: {S}") else. "") +
    (if (S := P.PropertyID?). WithIndent("PropertyID: {S}") else. "") +
    (if (S := P.ResourcePath?). WithIndent("ResourcePath: {S}") else. "") +
    (if (S := P.PropertyPath?). WithIndent("PropertyPath: {S}") else. "") +
    EndTab()

ToString<public>(P:prop_path):string= "[{P.ResourceID}.{P.PropertyID}]"
prop_path<public> := class<concrete>():
    @editable ResourceID<public>:string = ""
    @editable PropertyID<public>:string = ""

CopyEffect<public><constructor>(Old:effect)<transacts> := effect:
    FN := Old.FN
    Focus := Old.Focus
    Tweak := Old.Tweak
effect<public> := class<concrete>():
    @editable FN<public>:string = ""
    Focus<public>:half_path = half_path{}
    Tweak<public>:half_path = half_path{}

    Into<public>(PropID:string):effect= Into(Path(PropID))
    Into<public>(ResID:string, PropID:string):effect= Into(Path(ResID, PropID))
    Into<public>(T:half_path):effect= effect:
        CopyEffect<constructor>(Self)
        Tweak := T

    To<public>(PropID:string):effect= To(Path(PropID))
    To<public>(ResID:string, PropID:string):effect= To(Path(ResID, PropID))
    To<public>(T:half_path):effect= effect:
        CopyEffect<constructor>(Self)
        Tweak := T

    By<public>(PropID:string):effect= By(Path(PropID))
    By<public>(ResID:string, PropID:string):effect= By(Path(ResID, PropID))
    By<public>(T:half_path):effect= effect:
        CopyEffect<constructor>(Self)
        Tweak := T

    As<public>(PropID:string):effect= As(Path(PropID))
    As<public>(ResID:string, PropID:string):effect= As(Path(ResID, PropID))
    As<public>(T:half_path):effect= effect:
        CopyEffect<constructor>(Self)
        Tweak := T

    From<public>(PropID:string):effect= From(Path(PropID))
    From<public>(ResID:string, PropID:string):effect= From(Path(ResID, PropID))
    From<public>(T:half_path):effect= effect:
        CopyEffect<constructor>(Self)
        Tweak := T

prop_type<public> := enum{ Integer, Num, Str, Strs, Bool, Float, Agent, Vec2, Vec3, Unknown }
ToString<public>(Type:prop_type)<computes>:string = case(Type):
    prop_type.Integer => "Int"
    prop_type.Num => "Num"
    prop_type.Str => "Str"
    prop_type.Strs => "Strs"
    prop_type.Bool => "Bool"
    prop_type.Float => "Float"
    prop_type.Agent => "Agent"
    prop_type.Vec2 => "Vec2"
    prop_type.Vec3 => "Vec3"
    prop_type.Unknown => "Unknown"

CopyProp<public><constructor>(Old:prop)<transacts> := prop:
    ID := Old.ID
    Focus := Old.Focus
    FN := Old.FN
    Tweak := Old.Tweak
    Type := Old.Type
prop<public> := class:
    @editable ID<public>:string = ""
    @editable Focus<public>:half_path = half_path{}
    @editable FN<public>:string = ""
    @editable Tweak<public>:half_path = half_path{}
    @editable Type<public>:prop_type = prop_type.Unknown
    @editable DefaultFrom<public>:?half_path = false
ToString<public>(Prop:prop)<transacts>:string= Tab("[PROP]") +
    WithIndent("Focus: {Prop.Focus}") +
    WithIndent("FN: {Prop.FN}") +
    WithIndent("Tweak: {Prop.Tweak}") +
    WithIndent("Type: {Prop.Type}") +
    EndTab()

PropBool<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_bool{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_bool<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.Bool
    @editable Default<public>:logic = false
    ValueFor<public>(State:scoped_state):bool_goo= case(FN):
        "Int >" => BoolGoo(CompIntGT(Focus, State.ToInt, Tweak, State.ToInt))
        "Int <" => BoolGoo(CompIntLT(Focus, State.ToInt, Tweak, State.ToInt))
        "Int >=" => BoolGoo(CompIntGTE(Focus, State.ToInt, Tweak, State.ToInt))
        "Int <=" => BoolGoo(CompIntLTE(Focus, State.ToInt, Tweak, State.ToInt))
        ">=" => BoolGoo(CompGTE(Focus, State.ToNum, Tweak, State.ToNum))
        "=" => BoolGoo(CompNumEquals(Focus, State.ToNum, Tweak, State.ToNum))
        "AND" => BoolGoo(CompAnd(Focus, State.ToBool, Tweak, State.ToBool))
        "OR" => BoolGoo(CompOr(Focus, State.ToBool, Tweak, State.ToBool))
        "NOT" => BoolGoo(MapNot(Focus, State.ToBool))
        "Not Empty" => BoolGoo(MapNotEmpty(Focus, State.ToStr))
        "String Equals" => BoolGoo(CompStrEquals(Focus, State.ToStr, Tweak, State.ToStr))
        _ =>  case(Type):
            _ => if (not Focus.Empty[]). State.ToBool(Focus)
            else if(HP := DefaultFrom?). BoolGoo(Once(State.ToBool(HP)))
            else. BoolGoo(Default)

Negate(Integer:int)<computes>:int= Integer * -1
IntMinus(First:int, Second:int)<computes>:int= First - Second
IntMultiply(First:int, Second:int)<computes>:int= First * Second
FindElement(Strs:[]string, ToFind:string):int= if (I := Strs.Find[ToFind]). I+1 else. 0
PropInt<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_int{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_int<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.Integer
    @editable Default<public>:int = 0
    ValueFor<public>(State:scoped_state):int_goo= case(FN):
        "+" => IntGoo(CompIntAdd(Focus, State.ToInt, Tweak, State.ToInt))
        "-" => IntGoo(Computed(State.ToInt(Focus), State.ToInt(Tweak), IntMinus))
        "*" => IntGoo(Computed(State.ToInt(Focus), State.ToInt(Tweak), IntMultiply))
        "Find" => IntGoo(Computed(State.ToStrs(Focus), State.ToStr(Tweak), FindElement))
        "Negate" => IntGoo(Map(State.ToInt(Focus), Negate))
        "Length" => IntGoo(MapStrsLength(Focus, State.ToStrs))
        _ => case(Type):
            prop_type.Float => IntGoo(MapFloatToInt(Focus, State.ToFloat))
            _ => if (not Focus.Empty[]). State.ToInt(Focus)
            else if(HP := DefaultFrom?). IntGoo(Once(State.ToInt(HP)))
            else. IntGoo(Default)

RandFloat(MaxRange:float):float = GetRandomFloat(0.0, MaxRange)
AddFloat(First:float, Second:float)<computes>:float = First + Second
PropFloat<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_float{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_float<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.Float
    @editable Default<public>:float = 0.0
    ValueFor<public>(State:scoped_state):float_goo= case(FN):
        "+" => FloatGoo(Computed(State.ToFloat(Focus), State.ToFloat(Tweak), AddFloat))
        "*" => FloatGoo(CompFloatMultiply(Focus, State.ToFloat, Tweak, State.ToFloat))
        "Random" => FloatGoo(Map(State.ToFloat(Focus), RandFloat))
        _ => case(Type):
            prop_type.Num => FloatGoo(MapNumToFloat(Focus, State.ToNum))
            prop_type.Integer => FloatGoo(MapIntToFloat(Focus, State.ToInt))
            _ => if (not Focus.Empty[]). State.ToFloat(Focus)
            else if(HP := DefaultFrom?). FloatGoo(Once(State.ToFloat(HP)))
            else. FloatGoo(Default)

PropNum<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_num{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_num<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.Num
    @editable Default<public>:num = num{}
    ValueFor<public>(State:scoped_state):num_goo= case(FN):
        "Multiply" => NumGoo(CompNumMultiply(Focus, State.ToNum, Tweak, State.ToNum))
        "Power" => NumGoo(CompNumPower(Focus, State.ToNum, Tweak, State.ToFloat))
        "Reverse Power" => NumGoo(CompNumPower(Tweak, State.ToNum, Focus, State.ToFloat))
        _ => case(Type):
            prop_type.Float => NumGoo(MapFloatToNum(Focus, State.ToFloat))
            prop_type.Integer => NumGoo(MapIntToNum(Focus, State.ToInt))
            _ => if (not Focus.Empty[]). State.ToNum(Focus)
            else if(HP := DefaultFrom?). NumGoo(Once(State.ToNum(HP)))
            else. NumGoo(Default)

IfTrueStr(Bool:logic, IfTrue:string)<computes>:string= if (Bool?). IfTrue else. ""
StrsToStr(Strs:[]string)<computes>:string = Strs.Join(", ")
PropStr<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_str{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_str<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.Str
    @editable Default<public>:string = ""
    ValueFor<public>(State:scoped_state):string_goo= case(FN):
        "Append" => StrGoo(CompAppendStrs(Focus, State.ToStr, Tweak, State.ToStr))
        "Get" => StrGoo(CompGetStr(Focus, State.ToStrs, Tweak, State.ToInt))
        "Random" => StrGoo(MapRandStr(Focus, State.ToStrs))
        # OLD "If True" => StrGoo(CompIfTrueStr(Focus, State.ToBool, Tweak, State.ToStr))
        "If True" => StrGoo(Computed(State.ToBool(Focus), State.ToStr(Tweak), IfTrueStr))
        _ => case(Type):
            prop_type.Bool => StrGoo(MapBoolToStr(Focus, State.ToBool))
            prop_type.Agent => StrGoo(MapAgentToStr(Focus, State.ToAgent))
            prop_type.Integer => StrGoo(MapIntToStr(Focus, State.ToInt))
            prop_type.Float => StrGoo(MapFloatToStr(Focus, State.ToFloat))
            prop_type.Num => StrGoo(MapNumToStr(Focus, State.ToNum))
            prop_type.Vec2 => StrGoo(MapVec2ToStr(Focus, State.ToVec2))
            prop_type.Vec3 => StrGoo(MapVec3ToStr(Focus, State.ToVec3))
            prop_type.Strs => StrGoo(Map(State.ToStrs(Focus), StrsToStr))
            _ => if (not Focus.Empty[]). State.ToStr(Focus)
            else if(HP := DefaultFrom?). StrGoo(Once(State.ToStr(HP)))
            else. StrGoo(Default)

PropStrs<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_strs{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_strs<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.Strs
    @editable Default<public>:[]string = array{}
    ValueFor<public>(State:scoped_state):strs_goo= case(FN):
        _ => case(Type):
            _ => if (not Focus.Empty[]). State.ToStrs(Focus)
            else if(HP := DefaultFrom?). StrsGoo(Once(State.ToStrs(HP)))
            else. StrsGoo(Default)

PropAgent<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_agent{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_agent<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.Agent
    Default<public>:?agent = false
    ValueFor<public>(State:scoped_state):agent_goo= case(FN):
        _ => case(Type):
            _ => if (not Focus.Empty[]). State.ToAgent(Focus)
            else if(HP := DefaultFrom?). AgentGooVM(Once(State.ToAgent(HP)))
            else. AgentGoo(Default)

PropVec2<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_vec2{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_vec2<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.Vec2
    @editable Default<public>:vector2 = vector2{}
    ValueFor<public>(State:scoped_state):vec2_goo= case(FN):
        "Append" => Vec2Goo(CompAppendFloats(Focus, State.ToFloat, Tweak, State.ToFloat))
        _ => case(Type):
            _ => if (not Focus.Empty[]). State.ToVec2(Focus)
            else if(HP := DefaultFrom?). Vec2Goo(Once(State.ToVec2(HP)))
            else. Vec2Goo(Default)

PropVec3<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_vec3{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_vec3<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.Vec3
    @editable Default<public>:vector3 = vector3{}
    ValueFor<public>(State:scoped_state):vec3_goo= case(FN):
        "+" => Vec3Goo(CompVec3Add(Focus, State.ToVec3, Tweak, State.ToVec3))
        "Append" => Vec3Goo(CompAppendVec2AndFloat(Focus, State.ToVec2, Tweak, State.ToFloat))
        _ => case(Type):
            _ => if (not Focus.Empty[]). State.ToVec3(Focus)
            else if(HP := DefaultFrom?). Vec3Goo(Once(State.ToVec3(HP)))
            else. Vec3Goo(Default)

ability<public> := class():
    Effects<public>:[]effect = array{}

    ActionFor<public>(State:scoped_state):event_goo=
        ActionGoo := EventGoo()
        var Stream:event_goo = ActionGoo
        for(Effect:Effects):
            case(Effect.FN):
                "Set" =>
                    Effector := set_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Execute Ability" =>
                    Effector := execute_effect{ Focus := Effect.Focus, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Is True" =>
                    Effector := is_true_effect{ Focus := Effect.Focus, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Is False" =>
                    Effector := is_false_effect{ Focus := Effect.Focus, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Create Resource" =>
                    Effector := create_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Delay" =>
                    Effector := delay_effect{ Focus := Effect.Focus, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Increase" =>
                    Effector := increase_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Decrease" =>
                    Effector := decrease_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Log" =>
                    Effector := log_effect{ Focus := Effect.Focus, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Remove" =>
                    Effector := remove_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Remove Item" =>
                    Effector := remove_item_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Insert" =>
                    Effector := insert_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Insert Random" =>
                    Effector := insert_random_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                _ => Print("{Effect.FN} is unsupported")
        ActionGoo
