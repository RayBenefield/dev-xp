
using. /Verse.org/Random
using. /Verse.org/Simulation
using. /UnrealEngine.com/Temporary/SpatialMath

using. Banding
using. Goo
using. Numb
using. Vertex

Path<public><constructor>(PropertyID:string)<transacts> := half_path. PropertyID := option. PropertyID
Path<public><constructor>(PropPath:half_path)<transacts> := half_path. PropertyPath := option. PropPath
Path<public><constructor>(ResourcePath:half_path, PropertyID:string)<transacts> := half_path:
    ResourcePath := option. ResourcePath
    PropertyID := option. PropertyID
Path<public><constructor>(ResID:string, PropertyPath:half_path)<transacts> := half_path:
    ResourceID := option. ResID
    PropertyPath := option. PropertyPath
Path<public><constructor>(ResourcePath:half_path, PropPath:half_path)<transacts> := half_path:
    ResourcePath := option. ResourcePath
    PropertyPath := option. PropPath
Path<public><constructor>(ResourceID:string, PropertyID:string)<transacts> := half_path:
    ResourceID := option. ResourceID
    PropertyID := option. PropertyID

half_path<public> := class<concrete>():
    @editable ResourceID<public>:?string = false
    @editable PropertyID<public>:?string = false
    @editable ResourcePath<public>:?half_path = false
    @editable PropertyPath<public>:?half_path = false
(HP:half_path).Empty<public>()<decides><computes>:void=
    not HP.ResourceID? and not HP.PropertyID? and not HP.ResourcePath? and not HP.PropertyPath?
(HP:half_path).TryComplete<public>(ResourceID:string)<transacts>:?prop_path=
    if (R := HP.ResourceID?, P := HP.PropertyID?). return option. prop_path{ ResourceID := R, PropertyID := P }
    if (not HP.ResourcePath?, P := HP.PropertyID?). return option. prop_path{ ResourceID := ResourceID, PropertyID := P }
    return false
(HP:half_path).GetKey<public>()<transacts>:string=
    (if (RP := HP.ResourcePath?). "({RP.GetKey()})"
    else. (if (R := HP.ResourceID?). "{R}" else. "?")) +
    "." +
    (if (PP := HP.PropertyPath?). "({PP.GetKey()})"
    else. (if (P := HP.PropertyID?). "{P}" else. "?"))
ToString<public>(P:half_path)<transacts>:string= Tab("[HALF PATH]") +
    (if (S := P.ResourceID?). WithIndent("ResourceID: {S}") else. "") +
    (if (S := P.PropertyID?). WithIndent("PropertyID: {S}") else. "") +
    (if (S := P.ResourcePath?). WithIndent("ResourcePath: {S}") else. "") +
    (if (S := P.PropertyPath?). WithIndent("PropertyPath: {S}") else. "") +
    EndTab()

ToString<public>(P:prop_path):string= "[{P.ResourceID}.{P.PropertyID}]"
prop_path<public> := class<concrete>():
    @editable ResourceID<public>:string = ""
    @editable PropertyID<public>:string = ""

CopyEffect<public><constructor>(Old:effect)<transacts> := effect:
    FN := Old.FN
    Focus := Old.Focus
    Tweak := Old.Tweak
effect<public> := class<concrete>():
    @editable FN<public>:string = ""
    Focus<public>:half_path = half_path{}
    Tweak<public>:half_path = half_path{}

    To<public>(PropID:string):effect= To(Path(PropID))
    To<public>(ResID:string, PropID:string):effect= To(Path(ResID, PropID))
    To<public>(RPath:half_path, PropID:string):effect= To(Path(RPath, PropID))
    To<public>(HP:half_path):effect= effect:
        CopyEffect<constructor>(Self)
        Tweak := HP

    Into<public>(PropID:string):effect= To(Path(PropID))
    Into<public>(ResID:string, PropID:string):effect= To(Path(ResID, PropID))
    Into<public>(RPath:half_path, PropID:string):effect= To(Path(RPath, PropID))
    Into<public>(HP:half_path):effect= To(HP)

    By<public>(PropID:string):effect= To(Path(PropID))
    By<public>(ResID:string, PropID:string):effect= To(Path(ResID, PropID))
    By<public>(RPath:half_path, PropID:string):effect= To(Path(RPath, PropID))
    By<public>(HP:half_path):effect= To(HP)

    As<public>(PropID:string):effect= To(Path(PropID))
    As<public>(ResID:string, PropID:string):effect= To(Path(ResID, PropID))
    As<public>(RPath:half_path, PropID:string):effect= To(Path(RPath, PropID))
    As<public>(HP:half_path):effect= To(HP)

    From<public>(PropID:string):effect= To(Path(PropID))
    From<public>(ResID:string, PropID:string):effect= To(Path(ResID, PropID))
    From<public>(RPath:half_path, PropID:string):effect= To(Path(RPath, PropID))
    From<public>(HP:half_path):effect= To(HP)

    Else<public>(PropID:string):effect= To(Path(PropID))
    Else<public>(ResID:string, PropID:string):effect= To(Path(ResID, PropID))
    Else<public>(RPath:half_path, PropID:string):effect= To(Path(RPath, PropID))
    Else<public>(HP:half_path):effect= To(HP)

prop_type<public> := enum{ IntegerType, NumType, StrType, StrsType, BoolType, FloatType, AgentType, Vec2Type, Vec3Type, UnknownType }
ToString<public>(Type:prop_type)<computes>:string = case(Type):
    prop_type.IntegerType => "Int"
    prop_type.NumType => "Num"
    prop_type.StrType => "Str"
    prop_type.StrsType => "Strs"
    prop_type.BoolType => "Bool"
    prop_type.FloatType => "Float"
    prop_type.AgentType => "Agent"
    prop_type.Vec2Type => "Vec2"
    prop_type.Vec3Type => "Vec3"
    prop_type.UnknownType => "Unknown"

CopyProp<public><constructor>(Old:prop)<transacts> := prop:
    ID := Old.ID
    Focus := Old.Focus
    FN := Old.FN
    Tweak := Old.Tweak
    Type := Old.Type
prop<public> := class:
    @editable ID<public>:string = ""
    @editable Focus<public>:half_path = half_path{}
    @editable FN<public>:string = ""
    @editable Tweak<public>:half_path = half_path{}
    @editable Type<public>:prop_type = prop_type.UnknownType
    @editable DefaultFrom<public>:?half_path = false
ToString<public>(Prop:prop)<transacts>:string= Tab("[PROP]") +
    WithIndent("Focus: {Prop.Focus}") +
    WithIndent("FN: {Prop.FN}") +
    WithIndent("Tweak: {Prop.Tweak}") +
    WithIndent("Type: {Prop.Type}") +
    EndTab()

NotEmpty(Str:string)<transacts>:logic= if (Str <> ""). true else. false
NotBools(Bool:logic)<transacts>:logic= if (Bool?). false else. true
OrBools(First:logic, Second:logic)<transacts>:logic= if (First = true or Second = true). true else. false
AndBools(First:logic, Second:logic)<transacts>:logic= if (First = true and Second = true). true else. false
StrEquals(First:string, Second:string)<transacts>:logic= if (First = Second). true else. false
NumEquals(First:num, Second:num)<transacts>:logic= if (First.Equals[Second]). true else. false
GTE(First:num, Second:num)<transacts>:logic= if (First.GreaterThanOrEqual[Second]). true else. false
IntLT(First:int, Second:int)<transacts>:logic= if (First < Second). true else. false
IntGT(First:int, Second:int)<transacts>:logic= if (First > Second). true else. false
IntLTE(First:int, Second:int)<transacts>:logic= if (First <= Second). true else. false
IntGTE(First:int, Second:int)<transacts>:logic= if (First >= Second). true else. false
PropBool<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_bool{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_bool<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.BoolType
    @editable Default<public>:logic = false
    ValueFor<public>(State:scoped_state):bool_goo= case(FN):
        "Int >" => BoolGoo(Computed(State.ToInt(Focus), State.ToInt(Tweak), IntGT))
        "Int <" => BoolGoo(Computed(State.ToInt(Focus), State.ToInt(Tweak), IntLT))
        "Int >=" => BoolGoo(Computed(State.ToInt(Focus), State.ToInt(Tweak), IntGTE))
        "Int <=" => BoolGoo(Computed(State.ToInt(Focus), State.ToInt(Tweak), IntLTE))
        ">=" => BoolGoo(Computed(State.ToNum(Focus), State.ToNum(Tweak), GTE))
        "=" => BoolGoo(Computed(State.ToNum(Focus), State.ToNum(Tweak), NumEquals))
        "AND" => BoolGoo(Computed(State.ToBool(Focus), State.ToBool(Tweak), AndBools))
        "OR" => BoolGoo(Computed(State.ToBool(Focus), State.ToBool(Tweak), OrBools))
        "NOT" => BoolGoo(Map(State.ToBool(Focus), NotBools))
        "Not Empty" => BoolGoo(Map(State.ToStr(Focus), NotEmpty))
        "String Equals" => BoolGoo(Computed(State.ToStr(Focus), State.ToStr(Tweak), StrEquals))
        _ =>  case(Type):
            _ => if (not Focus.Empty[]). State.ToBool(Focus)
            else. BoolGoo(Default)

IntAdd(First:int, Second:int)<transacts>:int= First + Second
FloatToInt(Float:float)<transacts>:int= Float.ToInt()
StrsLength(Strs:[]string)<transacts>:int= Strs.Length
Negate(Integer:int)<computes>:int= Integer * -1
IntMinus(First:int, Second:int)<computes>:int= First - Second
IntMultiply(First:int, Second:int)<computes>:int= First * Second
FindElement(Strs:[]string, ToFind:string):int= if (I := Strs.Find[ToFind]). I+1 else. 0
PropInt<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_int{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_int<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.IntegerType
    @editable Default<public>:int = 0
    ValueFor<public>(State:scoped_state):int_goo= case(FN):
        "+" => IntGoo(Computed(State.ToInt(Focus), State.ToInt(Tweak), IntAdd))
        "-" => IntGoo(Computed(State.ToInt(Focus), State.ToInt(Tweak), IntMinus))
        "*" => IntGoo(Computed(State.ToInt(Focus), State.ToInt(Tweak), IntMultiply))
        "Find" => IntGoo(Computed(State.ToStrs(Focus), State.ToStr(Tweak), FindElement))
        "Negate" => IntGoo(Map(State.ToInt(Focus), Negate))
        "Length" => IntGoo(Map(State.ToStrs(Focus), StrsLength))
        _ => case(Type):
            prop_type.FloatType => IntGoo(Map(State.ToFloat(Focus), FloatToInt))
            _ => if (not Focus.Empty[]). State.ToInt(Focus)
            else. IntGoo(Default)

IntToFloat(Integer:int)<transacts>:float= Integer*1.0
FloatMultiply(First:float, Second:float)<transacts>:float= First * Second
NumToFloat<public>(Num:num)<transacts>:float= Num.Value * Pow(10.0, Num.Exponent * 1.0)
RandFloat(MaxRange:float):float = GetRandomFloat(0.0, MaxRange)
AddFloat(First:float, Second:float)<computes>:float = First + Second
PropFloat<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_float{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_float<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.FloatType
    @editable Default<public>:float = 0.0
    ValueFor<public>(State:scoped_state):float_goo= case(FN):
        "+" => FloatGoo(Computed(State.ToFloat(Focus), State.ToFloat(Tweak), AddFloat))
        "*" => FloatGoo(Computed(State.ToFloat(Focus), State.ToFloat(Tweak), FloatMultiply))
        "Random" => FloatGoo(Map(State.ToFloat(Focus), RandFloat))
        _ => case(Type):
            prop_type.NumType => FloatGoo(Map(State.ToNum(Focus), NumToFloat))
            prop_type.IntegerType => FloatGoo(Map(State.ToInt(Focus), IntToFloat))
            _ => if (not Focus.Empty[]). State.ToFloat(Focus)
            else. FloatGoo(Default)

IntToNum(Integer:int)<transacts>:num= num. Value := Integer*1.0
FloatToNum(Float:float)<transacts>:num= num. Value := Float
NumPower(First:num, Second:float)<transacts>:num= First.Pow(Second)
NumMultiply(First:num, Second:num)<transacts>:num= First * Second
PropNum<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_num{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_num<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.NumType
    @editable Default<public>:num = num{}
    ValueFor<public>(State:scoped_state):num_goo= case(FN):
        "Multiply" => NumGoo(Computed(State.ToNum(Focus), State.ToNum(Tweak), NumMultiply))
        "Power" => NumGoo(Computed(State.ToNum(Focus), State.ToFloat(Tweak), NumPower))
        "Reverse Power" => NumGoo(Computed(State.ToNum(Tweak), State.ToFloat(Focus), NumPower))
        _ => case(Type):
            prop_type.FloatType => NumGoo(Map(State.ToFloat(Focus), FloatToNum))
            prop_type.IntegerType => NumGoo(Map(State.ToInt(Focus), IntToNum))
            _ => if (not Focus.Empty[]). State.ToNum(Focus)
            else. NumGoo(Default)

RandStr(Strs:[]string)<transacts>:string= Strs[GetRandomInt(0, Strs.Length-1)] or ""
GetStr(Strs:[]string, Index:int)<transacts>:string= Strs[Index-1] or ""
AgentToStr(Value:?agent)<transacts>:string= if (Value?). "[HAS AGENT]" else. "[NO AGENT]"
Vec3ToStr(Vec3:vector3)<transacts>:string= "{Vec3}"
Vec2ToStr(Vec2:vector2)<transacts>:string= "{Vec2}"
IntToStr(Integer:int)<transacts>:string= "{Integer}"
FloatToStr(Float:float)<transacts>:string= "{Float}"
NumToStr(Num:num)<transacts>:string= "{Num}"
BoolToStr(Value:logic)<transacts>:string= if (Value?). "true" else. "false"
AppendStrs(First:string, Second:string)<transacts>:string = "{First}{Second}"
IfTrueStr(Bool:logic, IfTrue:string)<computes>:string= if (Bool?). IfTrue else. ""
StrsToStr(Strs:[]string)<computes>:string = Strs.Join(", ")
PropStr<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_str{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_str<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.StrType
    @editable Default<public>:string = ""
    ValueFor<public>(State:scoped_state):string_goo= case(FN):
        "Append" => StrGoo(Computed(State.ToStr(Focus), State.ToStr(Tweak), AppendStrs))
        "Get" => StrGoo(Computed(State.ToStrs(Focus), State.ToInt(Tweak), GetStr))
        "Random" => StrGoo(Map(State.ToStrs(Focus), RandStr))
        "If True" => StrGoo(Computed(State.ToBool(Focus), State.ToStr(Tweak), IfTrueStr))
        _ => case(Type):
            prop_type.BoolType => StrGoo(Map(State.ToBool(Focus), BoolToStr))
            prop_type.AgentType => StrGoo(Map(State.ToAgent(Focus), AgentToStr))
            prop_type.IntegerType => StrGoo(Map(State.ToInt(Focus), IntToStr))
            prop_type.FloatType => StrGoo(Map(State.ToFloat(Focus), FloatToStr))
            prop_type.NumType => StrGoo(Map(State.ToNum(Focus), NumToStr))
            prop_type.Vec2Type => StrGoo(Map(State.ToVec2(Focus), Vec2ToStr))
            prop_type.Vec3Type => StrGoo(Map(State.ToVec3(Focus), Vec3ToStr))
            prop_type.StrsType => StrGoo(Map(State.ToStrs(Focus), StrsToStr))
            _ => if (not Focus.Empty[]). State.ToStr(Focus)
            else. StrGoo(Default)

PropStrs<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_strs{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_strs<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.StrsType
    @editable Default<public>:[]string = array{}
    ValueFor<public>(State:scoped_state):strs_goo= case(FN):
        _ => case(Type):
            _ => if (not Focus.Empty[]). State.ToStrs(Focus)
            else. StrsGoo(Default)

PropAgent<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_agent{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_agent<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.AgentType
    Default<public>:?agent = false
    ValueFor<public>(State:scoped_state):agent_goo= case(FN):
        _ => case(Type):
            _ => if (not Focus.Empty[]). State.ToAgent(Focus)
            else. AgentGoo(Default)

AppendFloats(X:float, Y:float)<transacts>:vector2= vector2{ X := X, Y := Y }
PropVec2<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_vec2{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_vec2<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.Vec2Type
    @editable Default<public>:vector2 = vector2{}
    ValueFor<public>(State:scoped_state):vec2_goo= case(FN):
        "Append" => Vec2Goo(Computed(State.ToFloat(Focus), State.ToFloat(Tweak), AppendFloats))
        _ => case(Type):
            _ => if (not Focus.Empty[]). State.ToVec2(Focus)
            else. Vec2Goo(Default)

Vec3Add(First:vector3, Second:vector3)<transacts>:vector3= First + Second
AppendVec2AndFloat(Vec2:vector2, Z:float)<transacts>:vector3= vector3{ X := Vec2.X, Y := Vec2.Y, Z := Z }
PropVec3<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_vec3{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_vec3<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.Vec3Type
    @editable Default<public>:vector3 = vector3{}
    ValueFor<public>(State:scoped_state):vec3_goo= case(FN):
        "+" => Vec3Goo(Computed(State.ToVec3(Focus), State.ToVec3(Tweak), Vec3Add))
        "Append" => Vec3Goo(Computed(State.ToVec2(Focus), State.ToFloat(Tweak), AppendVec2AndFloat))
        _ => case(Type):
            _ => if (not Focus.Empty[]). State.ToVec3(Focus)
            else. Vec3Goo(Default)

Action<public><constructor>(Effect:effect)<transacts> := action. Effects := array. Effect
Action<public><constructor>(Effects:[]effect)<transacts> := action. Effects := Effects
action<public> := class():
    Effects<public>:[]effect = array{}

    ActionFor<public>(State:scoped_state):event_goo=
        ActionGoo := EventGoo()
        var Stream:event_goo = ActionGoo
        for(Effect:Effects):
            case(Effect.FN):
                "Set" =>
                    Effector := set_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Execute Action" =>
                    Effector := execute_effect{ Focus := Effect.Focus, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Is True" =>
                    Effector := is_true_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Is False" =>
                    Effector := is_false_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Create Resource" =>
                    Effector := create_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Delay" =>
                    Effector := delay_effect{ Focus := Effect.Focus, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Increase" =>
                    Effector := increase_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Decrease" =>
                    Effector := decrease_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Log" =>
                    Effector := log_effect{ Focus := Effect.Focus, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Remove" =>
                    Effector := remove_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Remove Item" =>
                    Effector := remove_item_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Insert" =>
                    Effector := insert_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                "Insert Random" =>
                    Effector := insert_random_effect{ Focus := Effect.Focus, Tweak := Effect.Tweak, State := State }
                    set Stream = EventGoo(Affect(Stream, Effector.Affect))
                _ => Print("{Effect.FN} is unsupported")
        ActionGoo
