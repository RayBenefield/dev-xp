
using. /Verse.org/Random
using. /Verse.org/Simulation
using. /UnrealEngine.com/Temporary/SpatialMath

using. Banding
using. Goo
using. Numb
using. Vertex

EmptyPath<public><constructor>()<transacts> := half_path{}
Path<public><constructor>(PropPath:prop_path)<transacts> := half_path:
    ResourceID := option. PropPath.ResourceID
    PropertyID := option. PropPath.PropertyID
    FromSub := PropPath.FromSub
Path<public><constructor>(PropertyID:string)<transacts> := half_path. PropertyID := option. PropertyID
Path<public><constructor>(PropPath:half_path)<transacts> := half_path. PropertyPath := option. PropPath
Path<public><constructor>(ResourcePath:half_path, PropertyID:string)<transacts> := half_path:
    ResourcePath := option. ResourcePath
    PropertyID := option. PropertyID
Path<public><constructor>(ResID:string, PropertyPath:half_path)<transacts> := half_path:
    ResourceID := option. ResID
    PropertyPath := option. PropertyPath
Path<public><constructor>(ResourcePath:half_path, PropPath:half_path)<transacts> := half_path:
    ResourcePath := option. ResourcePath
    PropertyPath := option. PropPath
Path<public><constructor>(ResourceID:string, PropertyID:string)<transacts> := half_path:
    ResourceID := option. ResourceID
    PropertyID := option. PropertyID

half_path<public> := class<concrete>():
    @editable ResourceID<public>:?string = false
    @editable PropertyID<public>:?string = false
    @editable ResourcePath<public>:?half_path = false
    @editable PropertyPath<public>:?half_path = false
    @editable FromSub<public>:logic = false
(HP:half_path).IsExternalLink(ResourceID:string)<decides><reads>:void= HP.FromSub? or not array{"", ResourceID, "GLOBAL"}.Find[HP.ResourceID? or ""]
(HP:half_path).Empty<public>()<decides><computes>:void=
    not HP.ResourceID? and not HP.PropertyID? and not HP.ResourcePath? and not HP.PropertyPath?
(HP:half_path).TryComplete<public>(ResourceID:string, SubTypeID:string)<transacts>:?prop_path=
    if (HP.FromSub?). HP.TryComplete(SubTypeID) else. HP.TryComplete(ResourceID)
(HP:half_path).TryComplete<public>(ResourceID:string)<transacts>:?prop_path=
    if (R := HP.ResourceID?, P := HP.PropertyID?, R <> "", P <> ""). return option. prop_path{ ResourceID := R, PropertyID := P }
    if (not HP.ResourcePath?, P := HP.PropertyID?, ResourceID <> "", P <> ""). return option. prop_path{ ResourceID := ResourceID, PropertyID := P }
    return false
(HP:half_path).GetUML<public>(ResourceID:string, ParentType:string)<transacts>:string= "\"{HP.GetResourceKey(ResourceID, ParentType).RemoveSpaces()}::{HP.GetPropertyKey()}\""
(HP:half_path).GetResourceKey<public>(ResourceID:string, ParentType:string)<reads>:string=
    if(HP.FromSub?). "PARENT{ParentType}" else:
        if (RP := HP.ResourcePath?). "({RP.GetFullKey(ResourceID, ParentType)})"
        else. (if (R := HP.ResourceID?). R else. ResourceID)
(HP:half_path).GetPropertyKey<public>()<reads>:string=
    if (PP := HP.PropertyPath?). "({PP.GetKey()})"
    else. (if (P := HP.PropertyID?). "{P}" else. "?")
(HP:half_path).GetResourceDescriptor<public>(ResourceID:string, ParentType:string)<reads>:string=
    if(HP.FromSub?). "(*{ParentType})" else:
        if (RP := HP.ResourcePath?). "({RP.GetDescriptor(ResourceID, ParentType)})"
        else. (if (R := HP.ResourceID?). R else. ResourceID)
(HP:half_path).GetDescriptor<public>(ResourceID:string, ParentType:string)<reads>:string= HP.GetResourceDescriptor(ResourceID, ParentType) + "." + HP.GetPropertyKey()
(HP:half_path).GetFullKey<public>(ResourceID:string, ParentType:string)<reads>:string= HP.GetResourceKey(ResourceID, ParentType) + "." + HP.GetPropertyKey()
(HP:half_path).GetKey<public>()<reads>:string= HP.GetResourceKey("?", "(*SUB)") + "." + HP.GetPropertyKey()
ToString<public>(P:half_path)<reads>:string= P.GetKey()
(P:half_path).ToDebugString<public>()<transacts>:string= Tab("[HALF PATH]") +
    (if (S := P.ResourceID?). WithIndent("ResourceID: {S}") else. "") +
    (if (S := P.PropertyID?). WithIndent("PropertyID: {S}") else. "") +
    (if (S := P.ResourcePath?). WithIndent("ResourcePath: {S}") else. "") +
    (if (S := P.PropertyPath?). WithIndent("PropertyPath: {S}") else. "") +
    EndTab()

ToString<public>(P:prop_path)<transacts>:string= "[{P.ResourceID}.{P.PropertyID}]"
(PP:prop_path).ToPath<public>()<transacts>:half_path= Path(PP)
(PP:prop_path).Empty<public>()<decides><computes>:void= PP.ResourceID = "" and PP.PropertyID = ""
SubPath<public>(PropertyID:string)<transacts>:prop_path = prop_path{ PropertyID := PropertyID, FromSub := true }
HardPath<public>(ResourceID:string, PropertyID:string)<transacts>:prop_path = prop_path{ ResourceID := ResourceID, PropertyID := PropertyID }
prop_path<public> := class<concrete>():
    @editable ResourceID<public>:string = ""
    @editable PropertyID<public>:string = ""
    @editable FromSub<public>:logic = false

MakeEffect<public><constructor>(Focus:prop_path, FN:string, Tweak:prop_path)<transacts> := effect{ Focus := Focus.ToPath(), FN := FN, Tweak := Tweak.ToPath() }
CopyEffect<public><constructor>(Old:effect)<transacts> := effect:
    FN := Old.FN
    Focus := Old.Focus
    Tweak := Old.Tweak
effect<public> := class<concrete>():
    @editable FN<public>:string = ""
    Focus<public>:half_path = half_path{}
    Tweak<public>:half_path = half_path{}

    To<public>(PropPath:prop_path):effect= To(PropPath.ToPath())
    To<public>(PropID:string):effect= To(Path(PropID))
    To<public>(ResID:string, PropID:string):effect= To(Path(ResID, PropID))
    To<public>(RPath:half_path, PropID:string):effect= To(Path(RPath, PropID))
    To<public>(HP:half_path):effect= effect:
        CopyEffect<constructor>(Self)
        Tweak := HP

    Into<public>(PropPath:prop_path):effect= To(PropPath.ToPath())
    Into<public>(PropID:string):effect= To(Path(PropID))
    Into<public>(ResID:string, PropID:string):effect= To(Path(ResID, PropID))
    Into<public>(RPath:half_path, PropID:string):effect= To(Path(RPath, PropID))
    Into<public>(HP:half_path):effect= To(HP)

    By<public>(PropPath:prop_path):effect= To(PropPath.ToPath())
    By<public>(PropID:string):effect= To(Path(PropID))
    By<public>(ResID:string, PropID:string):effect= To(Path(ResID, PropID))
    By<public>(RPath:half_path, PropID:string):effect= To(Path(RPath, PropID))
    By<public>(HP:half_path):effect= To(HP)

    As<public>(PropPath:prop_path):effect= To(PropPath.ToPath())
    As<public>(PropID:string):effect= To(Path(PropID))
    As<public>(ResID:string, PropID:string):effect= To(Path(ResID, PropID))
    As<public>(RPath:half_path, PropID:string):effect= To(Path(RPath, PropID))
    As<public>(HP:half_path):effect= To(HP)

    From<public>(PropPath:prop_path):effect= To(PropPath.ToPath())
    From<public>(PropID:string):effect= To(Path(PropID))
    From<public>(ResID:string, PropID:string):effect= To(Path(ResID, PropID))
    From<public>(RPath:half_path, PropID:string):effect= To(Path(RPath, PropID))
    From<public>(HP:half_path):effect= To(HP)

    Else<public>(PropPath:prop_path):effect= To(PropPath.ToPath())
    Else<public>(PropID:string):effect= To(Path(PropID))
    Else<public>(ResID:string, PropID:string):effect= To(Path(ResID, PropID))
    Else<public>(RPath:half_path, PropID:string):effect= To(Path(RPath, PropID))
    Else<public>(HP:half_path):effect= To(HP)

prop_type<public> := enum{ IntegerType, NumType, StrType, StrsType, BoolType, FloatType, AgentType, Vec2Type, Vec3Type, ActionType, UnknownType }
ToString<public>(Type:prop_type)<computes>:string = case(Type):
    prop_type.IntegerType => "Int"
    prop_type.NumType => "Num"
    prop_type.StrType => "Str"
    prop_type.StrsType => "Strs"
    prop_type.BoolType => "Bool"
    prop_type.FloatType => "Float"
    prop_type.AgentType => "Agent"
    prop_type.Vec2Type => "Vec2"
    prop_type.Vec3Type => "Vec3"
    prop_type.ActionType => "Action"
    prop_type.UnknownType => "Unknown"

CopyProp<public><constructor>(Old:prop)<transacts> := prop:
    ID := Old.ID
    Focus := Old.Focus
    FN := Old.FN
    Tweak := Old.Tweak
    Braid := Old.Braid
    Type := Old.Type
prop_strat<public> := enum{ Value, Remap, Transform, InternalComputer, Computer }
prop<public> := class:
    @editable ID<public>:string = ""
    @editable Focus<public>:half_path = half_path{}
    @editable FN<public>:string = ""
    @editable Tweak<public>:half_path = half_path{}
    @editable Braid<public>:half_path = half_path{}
    @editable Type<public>:prop_type = prop_type.UnknownType
    GetStrat<public>()<reads>:prop_strat=
        if(FN = "" and Focus.Empty[]). prop_strat.Value
        else if(FN <> "" and InternallyCalculated[]). prop_strat.InternalComputer
        else if(FN = "" and not Focus.Empty[]). prop_strat.Remap
        else if(FN <> "" and (not Tweak.Empty[] or not Braid.Empty[])). prop_strat.Computer
        else prop_strat.Transform
    InternallyCalculated()<decides><reads>:void=
        not (("" <> Focus.ResourceID?) or (Focus.ResourcePath?) or
        ("" <> Tweak.ResourceID?) or (Tweak.ResourcePath?) or
        ("" <> Braid.ResourceID?) or (Braid.ResourcePath?) or
        Focus.FromSub? or Tweak.FromSub? or Braid.FromSub?)
    IsExternalLink<public>(ResourceID:string)<decides><reads>:void=
        Focus.IsExternalLink[ResourceID] or
        Tweak.IsExternalLink[ResourceID] or
        Braid.IsExternalLink[ResourceID]
    GetDescriptor<public>(PropID:string, ResourceID:string, ParentType:string)<computes><reads>:string= case(GetStrat()):
        prop_strat.Value => "{PropID} => {Type}"
        prop_strat.Remap => "{PropID} => {Type} of {Focus.GetDescriptor(ResourceID, ParentType)}"
        prop_strat.Transform => "{PropID} => {Type} = {FN}({Focus.GetDescriptor(ResourceID, ParentType)})"
        prop_strat.InternalComputer => "{PropID} => {Type}"
        _ =>
            FuncName := (FN <> "") or "{Type}"
            Args := FilterOptions of array:
                option. not Focus.Empty[] and Focus.GetDescriptor(ResourceID, ParentType)
                option. not Tweak.Empty[] and Tweak.GetDescriptor(ResourceID, ParentType)
                option. not Braid.Empty[] and Braid.GetDescriptor(ResourceID, ParentType)
            FinalArgs := Args.Join(", ")
            "{PropID} => {Type} = {FuncName}({FinalArgs})"

ToString<public>(Prop:prop)<transacts>:string= Tab("[PROP]") +
    WithIndent("Focus: {Prop.Focus}") +
    WithIndent("FN: {Prop.FN}") +
    WithIndent("Tweak: {Prop.Tweak}") +
    WithIndent("Braid: {Prop.Braid}") +
    WithIndent("Type: {Prop.Type}") +
    EndTab()
