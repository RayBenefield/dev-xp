
using. Vertex

Affector<constructor>(GameState:game_state, ResourceID:string, SideEffects:[]side_effect_group)<transacts> := affector{ GameState := GameState, ResourceID := ResourceID, SideEffects := SideEffects }
affector := class():
    GameState:game_state
    ResourceID:string
    SideEffects:[]side_effect_group

    Init()<suspends>:void=
        for(Group:SideEffects, Parent:Group.Parents):
            if(GameState.IsType[Parent]):
                spawn. HandleNewParents(Parent, Group)
                for(P:GameState.ResourceTypePools[Parent]). spawn. ProcessSideEffects(P, Group)
            else:
                spawn. ProcessSideEffects(Parent, Group)

    HandleNewParents(ParentID:string, Group:side_effect_group)<suspends>:void=
        loop:
            NewResource := GameState.ResourceAddedEvent(ParentID).Await()
            spawn. ProcessSideEffects(NewResource, Group)

    ProcessSideEffects(ParentID:string, Group:side_effect_group)<suspends>:void=
        FinalParentID := if(ParentID <> ""). ParentID else. ResourceID
        NonDebugSideEffects := Group.SideEffectCreator()
        Debugs := for(Property:Group.Debugs, Property <> ""). Debug(Property, ResourceID, FinalParentID)
        AllSideEffects := Concatenate(NonDebugSideEffects, Debugs)

        for (P:AllSideEffects.Partition(IsSetup), Effect:P). ProcessSideEffect(Effect, FinalParentID)

    ProcessSideEffect(Effect:side_effect, ParentID:string)<suspends>:void=
        sync:
            GameState.AwaitResource(ResourceID)
            GameState.AwaitResource(ParentID)

        # if(Effect.PropertyID <> ""). GameState.PrimeCache(ResourceID, Effect.PropertyID, ParentID)

        PP := HardPath(ResourceID, Effect.PropertyID)
        if(E := debug_pipe[Effect]). spawn. GameState.SyncStr(PP, ParentID, E.FN)
        if(E := generate_pipe[Effect]). spawn. GameState.AttachGenerator(E.Event)
        if(E := first_pipe[Effect]). spawn. E.FN(AffectorContext(ResourceID, ParentID))
        if(E := tap_pipe[Effect]). spawn. GameState.OnUpdated(PP, ParentID, E.FN)
        if(E := bool_pipe[Effect]). spawn. GameState.SyncBool(PP, ParentID, E.FN)
        if(E := int_pipe[Effect]). spawn. GameState.SyncInt(PP, ParentID, E.FN)
        if(E := float_pipe[Effect]). spawn. GameState.SyncFloat(PP, ParentID, E.FN)
        if(E := str_pipe[Effect]). spawn. GameState.SyncStr(PP, ParentID, E.FN)
        if(E := agent_pipe[Effect]). spawn. GameState.SyncAgent(PP, ParentID, E.FN)
        if(E := msg_pipe[Effect]). spawn. GameState.SyncStr(PP, ParentID, E.FN)
        if(E := vec3_pipe[Effect]). spawn. GameState.SyncVec3(PP, ParentID, E.FN)
        if(E := action_pipe[Effect]). spawn. GameState.AttachAction(PP, ParentID, E.Event)
        if(E := arg_action_pipe[Effect]). spawn. GameState.AttachArgAction(PP, ParentID, E.Event)
        if(E := sync_float_side_effect[Effect]). spawn. GameState.UpdateFloat(PP, ParentID, E.From)
        if(E := widget_binding[Effect]). spawn. GameState.AddUI(E.Widget, ParentID, E.Position)

AffectorContext<public><constructor>(ResourceID:string, ParentID:string)<transacts> := context{ ResourceID := ResourceID, ParentID := ParentID }
context<public> := class():
    ResourceID<public>:string
    ParentID<public>:string
