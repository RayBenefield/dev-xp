
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }

using { TableauTesting }
using { Tableau }

num_parts_test := class(creative_device, test_suite):
    GetName<override>():string = "Num Parts"
    GetTests<override>():[]test_case = array:
        test_case:
            Name := "Should support a single digit (3)"
            Test := OneDigit
        test_case:
            Name := "Should support two digits (34)"
            Test := TwoDigits
        test_case:
            Name := "Should support two digits normalized (34)"
            Test := TwoDigitsNormalized
        test_case:
            Name := "Should support three digits (345)"
            Test := ThreeDigits
        test_case:
            Name := "Should support three digits normalized (345)"
            Test := ThreeDigitsNormalized
        test_case:
            Name := "Should convert a single digit in the thousands to three digits (3k -> 3.00k)"
            Test := OneDigitThousands
        test_case:
            Name := "Should convert a single digit in the thousands to three digits normalized (3k -> 3.00k)"
            Test := OneDigitThousandsNormalized
        test_case:
            Name := "Should convert two digits in the thousands to three digits (34k -> 34.0k)"
            Test := TwoDigitThousands
        test_case:
            Name := "Should convert two digits in the thousands to three digits normalized (34k -> 34.0k)"
            Test := TwoDigitThousandsNormalized
        test_case:
            Name := "Should convert two digits with a decimal to three digits (3.4k -> 3.40k)"
            Test := TwoDigitDecimalThousands
        test_case:
            Name := "Should convert two digits with a decimal to three digits normalized (3.4k -> 3.40k)"
            Test := TwoDigitDecimalThousandsNormalized
        test_case:
            Name := "Should support three digits in the thousands (345k)"
            Test := ThreeDigitThousands
        test_case:
            Name := "Should support three digits in the thousands normalized (345k)"
            Test := ThreeDigitThousandsNormalized
        test_case:
            Name := "Should support three digits with a tens decimal (34.5k)"
            Test := ThreeDigitTensDecimalThousands
        test_case:
            Name := "Should support three digits with a tens decimal normalized (34.5k)"
            Test := ThreeDigitTensDecimalThousandsNormalized
        test_case:
            Name := "Should support three digits with a hundreds decimal (3.45k)"
            Test := ThreeDigitHundredsDecimalThousands
        test_case:
            Name := "Should support three digits with a hundreds decimal normalized (3.45k)"
            Test := ThreeDigitHundredsDecimalThousandsNormalized

    OneDigit():?failure =
        # Arrange
        Number := num{ Value := 3.0, Exponent := 0 }

        # Act
        Result := Number.Parts()

        # Assert: 3
        if (not Result.Digits = 3). return fail("Number should be a single digit")
        if (not Result.ExpIndex = 0). return fail("Number should have no exponent")
        if (not Result.Decimal = decimal_position.None). return fail("Number should not have a decimal")

        # Pass
        return false

    TwoDigits():?failure =
        # Arrange
        Number := num{ Value := 34.0, Exponent := 0 }

        # Act
        Result := Number.Parts()

        # Assert: 34
        if (not Result.Digits = 34). return fail("Number should have two digits")
        if (not Result.ExpIndex = 0). return fail("Number should have no exponent")
        if (not Result.Decimal = decimal_position.None). return fail("Number should not have a decimal")

        # Pass
        return false

    TwoDigitsNormalized():?failure =
        # Arrange
        Number := num{ Value := 3.4, Exponent := 1 }

        # Act
        Result := Number.Parts()

        # Assert: 34
        if (not Result.Digits = 34). return fail("Number should have two digits")
        if (not Result.ExpIndex = 0). return fail("Number should have no exponent")
        if (not Result.Decimal = decimal_position.None). return fail("Number should not have a decimal")

        # Pass
        return false

    ThreeDigits():?failure =
        # Arrange
        Number := num{ Value := 345.0, Exponent := 0 }

        # Act
        Result := Number.Parts()

        # Assert: 345
        if (not Result.Digits = 345). return fail("Number should have three digits")
        if (not Result.ExpIndex = 0). return fail("Number should have no exponent")
        if (not Result.Decimal = decimal_position.None). return fail("Number should not have a decimal")

        # Pass
        return false

    ThreeDigitsNormalized():?failure =
        # Arrange
        Number := num{ Value := 3.45, Exponent := 2 }

        # Act
        Result := Number.Parts()

        # Assert: 345
        if (not Result.Digits = 345). return fail("Number should have three digits")
        if (not Result.ExpIndex = 0). return fail("Number should have no exponent")
        if (not Result.Decimal = decimal_position.None). return fail("Number should not have a decimal")

        # Pass
        return false

    OneDigitThousands():?failure =
        # Arrange
        Number := num{ Value := 3000.0, Exponent := 0 }

        # Act
        Result := Number.Parts()

        # Assert: 3.00k
        if (not Result.Digits = 300). return fail("Number should have three digits")
        if (not Result.ExpIndex = 1). return fail("Number should have an exponent of 1")
        if (not Result.Decimal = decimal_position.Hundredths). return fail("Number should have a decimal for Hundredths")

        # Pass
        return false

    # 3.00k
    OneDigitThousandsNormalized():?failure =
        # Arrange
        Number := num{ Value := 3.0, Exponent := 3 }

        # Act
        Result := Number.Parts()

        # Assert: 3.00k
        if (not Result.Digits = 300). return fail("Number should have three digits")
        if (not Result.ExpIndex = 1). return fail("Number should have an exponent of 1")
        if (not Result.Decimal = decimal_position.Hundredths). return fail("Number should have a decimal for Hundredths")

        # Pass
        return false

    TwoDigitThousands():?failure =
        # Arrange
        Number := num{ Value := 34000.0, Exponent := 0 }

        # Act
        Result := Number.Parts()

        # Assert: 34.0k
        if (not Result.Digits = 340). return fail("Number should have three digits")
        if (not Result.ExpIndex = 1). return fail("Number should have an exponent of 1")
        if (not Result.Decimal = decimal_position.Tenths). return fail("Number should have a decimal for Tenths")

        # Pass
        return false

    TwoDigitThousandsNormalized():?failure =
        # Arrange
        Number := num{ Value := 3.4, Exponent := 4 }

        # Act
        Result := Number.Parts()

        # Assert: 34.0k
        if (not Result.Digits = 340). return fail("Number should have three digits")
        if (not Result.ExpIndex = 1). return fail("Number should have an exponent of 1")
        if (not Result.Decimal = decimal_position.Tenths). return fail("Number should have a decimal for Tenths")

        # Pass
        return false

    TwoDigitDecimalThousands():?failure =
        # Arrange
        Number := num{ Value := 3400.0, Exponent := 0 }

        # Act
        Result := Number.Parts()

        # Assert: 3.40k
        ProjectLog("Result: {Result}")
        ProjectLog("SetNormalized: {Number.SetNormalize().Value}, {Number.SetNormalize().Exponent}")
        if (not Result.Digits = 340). return fail("Number should have three digits")
        if (not Result.ExpIndex = 1). return fail("Number should have an exponent of 1")
        if (not Result.Decimal = decimal_position.Hundredths). return fail("Number should have a decimal for Hundredths")

        # Pass
        return false

    TwoDigitDecimalThousandsNormalized():?failure =
        # Arrange
        Number := num{ Value := 3.4, Exponent := 3 }

        # Act
        Result := Number.Parts()

        # Assert: 3.40k
        if (not Result.Digits = 340). return fail("Number should have three digits")
        if (not Result.ExpIndex = 1). return fail("Number should have an exponent of 1")
        if (not Result.Decimal = decimal_position.Hundredths). return fail("Number should have a decimal for Hundredths")

        # Pass
        return false

    ThreeDigitThousands():?failure =
        # Arrange
        Number := num{ Value := 345000.0, Exponent := 0 }

        # Act
        Result := Number.Parts()

        # Assert: 345k
        if (not Result.Digits = 345). return fail("Number should have three digits")
        if (not Result.ExpIndex = 1). return fail("Number should have an exponent of 1")
        if (not Result.Decimal = decimal_position.None). return fail("Number should not have a decimal")

        # Pass
        return false

    # 345k
    ThreeDigitThousandsNormalized():?failure =
        # Arrange
        Number := num{ Value := 3.45, Exponent := 5 }

        # Act
        Result := Number.Parts()

        # Assert: 345k
        if (not Result.Digits = 345). return fail("Number should have three digits")
        if (not Result.ExpIndex = 1). return fail("Number should have an exponent of 1")
        if (not Result.Decimal = decimal_position.None). return fail("Number should not have a decimal")

        # Pass
        return false

    ThreeDigitTensDecimalThousands():?failure =
        # Arrange
        Number := num{ Value := 34500.0, Exponent := 0 }

        # Act
        Result := Number.Parts()

        # Assert: 34.5k
        if (not Result.Digits = 345). return fail("Number should have three digits")
        if (not Result.ExpIndex = 1). return fail("Number should have an exponent of 1")
        if (not Result.Decimal = decimal_position.Tenths). return fail("Number should have a decimal for Tenths")

        # Pass
        return false

    ThreeDigitTensDecimalThousandsNormalized():?failure =
        # Arrange
        Number := num{ Value := 3.45, Exponent := 4 }

        # Act
        Result := Number.Parts()

        # Assert: 34.5k
        if (not Result.Digits = 345). return fail("Number should have three digits")
        if (not Result.ExpIndex = 1). return fail("Number should have an exponent of 1")
        if (not Result.Decimal = decimal_position.Tenths). return fail("Number should have a decimal for Tenths")

        # Pass
        return false

    ThreeDigitHundredsDecimalThousands():?failure =
        # Arrange
        Number := num{ Value := 3450.0, Exponent := 0 }

        # Act
        Result := Number.Parts()

        # Assert: 3.45k
        if (not Result.Digits = 345). return fail("Number should have three digits")
        if (not Result.ExpIndex = 1). return fail("Number should have an exponent of 1")
        if (not Result.Decimal = decimal_position.Hundredths). return fail("Number should have a decimal for Hundredths")

        # Pass
        return false

    # 3.45k
    ThreeDigitHundredsDecimalThousandsNormalized():?failure =
        # Arrange
        Number := num{ Value := 3.45, Exponent := 3 }

        # Act
        Result := Number.Parts()

        # Assert: 3.45k
        if (not Result.Digits = 345). return fail("Number should have three digits")
        if (not Result.ExpIndex = 1). return fail("Number should have an exponent of 1")
        if (not Result.Decimal = decimal_position.Hundredths). return fail("Number should have a decimal for Hundredths")

        # Pass
        return false
