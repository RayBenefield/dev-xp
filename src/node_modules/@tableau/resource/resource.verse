using. /Verse.org/Simulation

using. Banding
using. Numb
using. Vertex

MergeResources<public><constructor>(Old:resource, New:resource)<transacts> := resource:
    ID := (Old.ID <> "") or New.ID
    Type := (Old.Type <> "") or New.Type
    ParentType := (Old.Type <> "") or New.ParentType
    Props := ConcatenateMaps(Old.Props, New.Props)
    Actions:= ConcatenateMaps(Old.Actions, New.Actions)
MergeToResourceMap<public>(Entry:tuple(t,resource), OldMap:[t]resource where t:subtype(comparable))<transacts>:[t]resource=
    NewValue := if(Old := OldMap[Entry(0)]). MergeResources(Old, Entry(1)) else. Entry(1)
    ConcatenateMaps(OldMap, map{ Entry(0) => NewValue })
CreateResourceMap<public>(Mappable:[]tuple(t, resource) where t:subtype(comparable)):[t]resource=
    Mappable.Reduce(MergeToResourceMap, map{})
ConcatenateResourceMaps<public>(Old:[string]resource, New:[string]resource):[string]resource=
    var AllKeys:[]string = Old.Keys()
    for(K:New.Keys()). if(not AllKeys.Find[K]). set AllKeys += array. K
    var Final:[string]resource = map{}
    for(K:AllKeys):
        if(O := Old[K], N := New[K]). option. set Final[K] = MergeResources(O, N)
        else if(O := Old[K]). option. set Final[K] = O
        else if(N := New[K]). option. set Final[K] = N
        else. Print("HOW!?!?!")
    Final
AddTemplatesToResources<public>(Templates:[string]resource, Resources:[string]resource):[string]resource=
    var Final:[string]resource = map{}
    for(R:Resources):
        if(Template := Templates[R.Type]). option. set Final[R.ID] = MergeResources(Template, R)
        else. option. set Final[R.ID] = R
    Final

Copy<constructor>(Old:resource)<transacts> := resource:
    ID := Old.ID
    Type := Old.Type
    ParentType := Old.ParentType
    Static := Old.Static
    Props := Old.Props
    Actions:= Old.Actions

CreateFromTemplate<public><constructor>(ID:string, Template:resource)<transacts> := resource:
    Copy<constructor>(Template)
    ID := ID

MakeStatic<public><constructor>(Resource:resource)<transacts> := resource:
    Copy<constructor>(Resource)
    Static := true

AddProps<public><constructor>(Old:resource, NewProps:[string]prop)<transacts> := resource:
    Copy<constructor>(Old)
    Props := ConcatenateMaps(Old.Props, NewProps)

resource<public> := class<unique><concrete>():
    @editable ID<public>:string = ""
    @editable Type<public>:string = ""
    @editable ParentType<public>:string = ""
    @editable Static<public>:logic = false
    Props<public>:[string]prop = map{}
    Actions<public>:[string]action = map{}

    GetPropType<public>(PropID:string)<transacts>:prop_type=
        Props[PropID].Type or (Actions[PropID] and prop_type.ActionType) or prop_type.UnknownType

    GetAction<public>(PropID:string):action = Actions[PropID] or action{}
    GetBool<public>(PropID:string):prop_bool =
        if (not Props[PropID]). return Bool of false
        prop_bool[Props[PropID]] or PropBool(ID, PropID, GetPropType(PropID))
    GetInt<public>(PropID:string):prop_int =
        if (not Props[PropID]). return Integer of 0
        prop_int[Props[PropID]] or PropInt(ID, PropID, GetPropType(PropID))
    GetFloat<public>(PropID:string):prop_float =
        if (not Props[PropID]). return Float of 0.0
        prop_float[Props[PropID]] or PropFloat(ID, PropID, GetPropType(PropID))
    GetNum<public>(PropID:string):prop_num =
        if (not Props[PropID]). return Num of 0.0
        prop_num[Props[PropID]] or PropNum(ID, PropID, GetPropType(PropID))
    GetStr<public>(PropID:string):prop_str =
        if (not Props[PropID]). return Str of ""
        prop_str[Props[PropID]] or PropStr(ID, PropID, GetPropType(PropID))
    GetStrs<public>(PropID:string):prop_strs =
        if (not Props[PropID]). return Strs of array{}
        prop_strs[Props[PropID]] or PropStrs(ID, PropID, GetPropType(PropID))
    GetAgent<public>(PropID:string):prop_agent =
        if (not Props[PropID]). return UEAgent of option. agent[BLANK{}]
        prop_agent[Props[PropID]] or PropAgent(ID, PropID, GetPropType(PropID))
    GetVec2<public>(PropID:string):prop_vec2 =
        if (not Props[PropID]). return Vec2 of V2()
        prop_vec2[Props[PropID]] or PropVec2(ID, PropID, GetPropType(PropID))
    GetVec3<public>(PropID:string):prop_vec3 =
        if (not Props[PropID]). return Vec3 of V3()
        prop_vec3[Props[PropID]] or PropVec3(ID, PropID, GetPropType(PropID))

HasProperty<public><constructor>(PropToFilter:string)<transacts> := has_property_fn. PropToFilter := PropToFilter
has_property_fn<public> := class():
    PropToFilter<public>:string
    FN<public>(Resource:resource)<decides><transacts>:void=Resource.Props[PropToFilter]

(Resource:resource).GetRelevantProps<public>():[string][]string=
    UnmergedProps := CombineAllArrays of for(PropID->Value:Resource.Props, Value.IsExternalLink at Resource.ID). FilterOptions of array:
        option. (Resource.ID, array. PropID)
        option. (if(Value.Focus.FromSub?). Resource.ParentType else. Value.Focus.ResourceID? <> "", array. Value.Focus.PropertyID?)
        option. (if(Value.Tweak.FromSub?). Resource.ParentType else. Value.Tweak.ResourceID? <> "", array. Value.Tweak.PropertyID?)
        option. (if(Value.Braid.FromSub?). Resource.ParentType else. Value.Braid.ResourceID? <> "", array. Value.Braid.PropertyID?)
    CreateResourcePropMap of UnmergedProps

MergeResourcePropMap<public>(Entry:tuple(string, []string), OldMap:[string][]string)<transacts>:[string][]string=
    NewValue := if(Old := OldMap[Entry(0)]). Concatenate(Old, Entry(1)) else. Entry(1)
    ConcatenateMaps(OldMap, map{ Entry(0) => NewValue })
CreateResourcePropMap<public>(ResourcePropMaps:[]tuple(string, []string)):[string][]string=
    ResourcePropMaps.Reduce(MergeResourcePropMap, map{})
CombineResourcePropMaps<public>(ResourcePropMaps:[][string][]string):[string][]string=
    CreateResourcePropMap of for(PropMap:ResourcePropMaps, Key->Values:PropMap). (Key, Values)

ToString<public>(Resource:resource):string=
    Tab("RESOURCE [{Resource.ID}]({Resource.Type})") +
        WithIndent("Static: {if(Resource.Static?). "True" else. "False"}") +
        Tab("Props:") +
            IndentedKeys(Resource.Props) +
            EndTab() +
        Tab("Actions:") +
            IndentedKeys(Resource.Actions) +
            EndTab() +
    EndTab()

(Resource:resource).ToPlantUMLParents<public>(Links:[]string):string=
    CamelCase := Resource.Type.RemoveSpaces()
    "package {CamelCase} \{\}" +
    Tab("protocol \"{Resource.Type}\" as {CamelCase}.PARENT{CamelCase} \{") +
        (for(ID->Val:Resource.Props, Links.Find[ID]). "{ID} : {Val.Type}").IndentedJoin() +
        (for(ID->Val:Resource.Actions, Links.Find[ID]). "{ID} : Action").IndentedJoin() +
    EndTabWith("\}")
(Resource:resource).ToPlantUMLMaps<public>(Links:[]string):string=
    CamelCase := Resource.ID.RemoveSpaces()
    FinalName := if(Resource.ParentType <> ""). "{Resource.ParentType}.{CamelCase}" else. CamelCase
    Tab("map \"{Resource.ID}\" as {FinalName} \{") +
        (for(ID->Val:Resource.Props, Links.Find[ID]). Val.GetDescriptor(ID, Resource.ID, Resource.ParentType)).IndentedJoin() +
        (for(ID->Val:Resource.Actions, Links.Find[ID]). "{ID} => Action").IndentedJoin() +
    EndTabWith("\}")
(Resource:resource).ToPlantUMLLinks<public>():string=
    CamelCase := Resource.ID.RemoveSpaces()
    (for(ID->Value:Resource.Props, F := Value.Focus, not F.Empty[], F.IsExternalLink[Resource.ID]). "{F.GetUML(Resource.ID, Resource.ParentType)} *--> \"{CamelCase}::{ID}\"").IndentedJoin() +
    (for(ID->Value:Resource.Props, F := Value.Tweak, not F.Empty[], F.IsExternalLink[Resource.ID]). "{F.GetUML(Resource.ID, Resource.ParentType)} o..> \"{CamelCase}::{ID}\"").IndentedJoin() +
    (for(ID->Value:Resource.Props, F := Value.Braid, not F.Empty[], F.IsExternalLink[Resource.ID]). "{F.GetUML(Resource.ID, Resource.ParentType)} *..> \"{CamelCase}::{ID}\"").IndentedJoin()
