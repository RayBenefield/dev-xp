
using. /Verse.org/Simulation
using. /UnrealEngine.com/Temporary/SpatialMath

using. Goo
using. Vertex

AppendFloats(X:float, Y:float)<transacts>:vector2= vector2{ X := X, Y := Y }
InverseUlam(Index:int)<transacts>:vector2=
    if(Index = 1). return V2()

    Layer := Ceil[(Sqrt(Index*1.0) - 1.0) / 2.0]*1.0 or 1.0
    LayerPos := Index*1.0 - Pow(2.0 * Layer - 1.0, 2.0)

    if(LayerPos <= 2.0 * Layer). return V2(Layer, Layer-LayerPos)
    else if(LayerPos <= 4.0 * Layer). return V2(Layer - (LayerPos - 2.0 * Layer), -Layer)
    else if(LayerPos <= 6.0 * Layer). return V2(-Layer, -Layer + (LayerPos - 4.0 * Layer))
    else return V2(-Layer + (LayerPos - 6.0 * Layer), Layer)
CornerGrid(RawIndex:int)<transacts>:vector2=
    if(RawIndex < 0). return V2()

    Index := RawIndex - 1
    RingFinder := find_ring_fn. Index := Index
    FoundRing := if(Index = 0). ring_points{} else. RingFinder.FN(0, 0)
    Ring := FoundRing.Ring
    TotalPoints := FoundRing.TotalPoints
    Offset := Index - TotalPoints
    SideLength := Ring + 1

    Result := if(Ring = 0). V2()
        else if(Offset < SideLength). V2(Offset, Ring)
        else V2(Ring, Offset - SideLength)

    return Result

ring_points := class<concrete>():
    Ring:int = 0
    TotalPoints:int = 0

find_ring_fn := class():
    Index:int
    FN(N:int, PrevTotal:int)<transacts>:ring_points=
        Total := (N+1)*(N+1)
        if(Total > Index). return ring_points{ Ring := N, TotalPoints := PrevTotal }
        return FN(N+1, Total)

Vec2<public><constructor>(Default:vector2)<transacts> := prop_vec2. Default := Default
Vec2<public><constructor>(Focus:half_path)<transacts> := prop_vec2. Focus := Focus
Vec2<public><constructor>(Focus:prop_path)<transacts> := prop_vec2. Focus := Focus.ToPath()
Vec2<public><constructor>(Focus:half_path, FN:string)<transacts> := prop_vec2{ Focus := Focus, FN := FN }
Vec2<public><constructor>(FN:string, Focus:half_path)<transacts> := prop_vec2{ Focus := Focus, FN := FN }
Vec2<public><constructor>(Focus:half_path, FN:string, Tweak:half_path)<transacts> := prop_vec2{ Focus := Focus, FN := FN, Tweak := Tweak }
Vec2<public><constructor>(Focus:prop_path, FN:string, Tweak:prop_path)<transacts> := prop_vec2{ Focus := Focus.ToPath(), FN := FN, Tweak := Tweak.ToPath() }
MaybeVec2<public><constructor>(Focus:?prop_path)<transacts> := prop_vec2. Focus := Focus?.ToPath() or EmptyPath()

vec2_plug<public> := class<concrete>():
    @editable Default:vector2 = vector2{}
    @editable Source:?prop_path = false
Vec2<public>(Plug:vec2_plug)<transacts>:prop_vec2 := (Vec2 of Plug.Source?) or (Vec2 of Plug.Default)
Vec2<public>(Plug:?vec2_plug, Default:vector2)<transacts>:prop_vec2 := (Vec2 of Plug?) or (Vec2 of Default)

PropVec2<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_vec2{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_vec2<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.Vec2Type
    @editable Default<public>:vector2 = vector2{}
    ValueFor<public>(State:scoped_state):vec2_goo= case(FN):
        "Append" => Vec2Goo(Computed(State.ToFloat(Focus), State.ToFloat(Tweak), AppendFloats))
        "Ulam" => Vec2Goo(Map(State.ToInt(Focus), InverseUlam))
        "Corner Grid" => Vec2Goo(Map(State.ToInt(Focus), CornerGrid))
        _ => case(Type):
            _ => if (not Focus.Empty[]). State.ToVec2(Focus)
            else. Vec2Goo(Default)
