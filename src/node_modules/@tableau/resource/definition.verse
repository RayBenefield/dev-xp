
using. /UnrealEngine.com/Temporary/SpatialMath

using. Banding
using. Vertex

SideEffectGroup<public><constructor>(Def:definition)<transacts> := side_effect_group{ Parents := Def.Parents, SideEffectCreator := Def.SideEffectCreator, Debugs := Def.Debugs }
side_effect_group<public> := class():
    Parents<public>:[]string
    SideEffectCreator<public>:type{_()<suspends>:[]side_effect}
    Debugs<public>:[]string

definition<public> := class():
    ID<public>:string
    Type<public>:string
    SubID<public>:string
    DeviceType<public>:string
    DeviceLocation<public>:vector3
    StaticResource<public>:logic
    StaticType<public>:logic
    Props<public>:[string]prop
    Actions<public>:[string]action
    Parents<public>:[]string
    SideEffectCreator<public>:type{_()<suspends>:[]side_effect}
    Debugs<public>:[]string

ToDefinition<public><constructor>(Device:tableau_device)<transacts> := to_definition. Device := Device
to_definition<public> := class():
    Device<public>:tableau_device
    FN<public>(Resource:resource)<transacts>:definition=
        ID := (Resource.ID <> "") or ((not Device.SideEffectSettings.PerResource?) and Device.ResourceID <> "") or ""
        Type := (Resource.Type <> "") or (Device.SideEffectSettings.PerResource? and Device.Type <> "") or Device.Type
        SubID := Device.GetSubResID()
        StaticResource := if(SubID = "" and ID <> ""). true else. false
        StaticType := if(SubID = "" and ID = "" and Type <> ""). true else. false

        definition:
            ID := ID
            Type := Type
            SubID := SubID
            DeviceType := Device.DeviceType
            DeviceLocation := Device.GetTransform().Translation
            StaticResource := StaticResource
            StaticType := StaticType
            Props := Resource.Props
            Actions := Resource.Actions
            Parents := array. SubID
            SideEffectCreator := Device.GetSideEffects
            Debugs := Device.GetDebugs()

ToString<public>(D:definition):string=
    Tab("Definition [{D.ID}]({D.Type}) - {D.DeviceType}@{D.DeviceLocation}") +
        WithIndent("Sub ID: {D.SubID}") +
        WithIndent("Static Resource: {if(D.StaticResource?). "True" else. "False"}") +
        WithIndent("Static Type: {if(D.StaticType?). "True" else. "False"}") +
        Tab("Props:") +
            IndentedKeys(D.Props) +
            EndTab() +
        Tab("Actions:") +
            IndentedKeys(D.Actions) +
            EndTab() +
    EndTab()

(Def:definition).ToResource<public>()<transacts>:resource= resource:
    ID := Def.ID
    Type := Def.Type
    ParentType := Def.SubID
    Props := Def.Props
    Actions := Def.Actions

ToTypeMap<public>(New:definition, All:[string]resource)<transacts>:[string]resource=
    NewResource := if(Old := All[New.Type]). MergeResources(Old, New.ToResource()) else. New.ToResource()
    ConcatenateMaps(All, map{ New.Type => NewResource })
TypeOnly<public>(D:definition)<decides><transacts>:void= D.Type <> "" and D.ID = ""
(Defs:[]definition).GetTemplateMap<public>():[string]resource=
    OnlyTypes := Defs.Filter(TypeOnly)
    OnlyTypes.Reduce(ToTypeMap, map{})

ToResourceMap<public>(New:definition, All:[string]resource)<transacts>:[string]resource=
    NewResource := if(Old := All[New.ID]). MergeResources(Old, New.ToResource()) else. New.ToResource()
    ConcatenateMaps(All, map{ New.ID => NewResource })
OnlyID<public>(D:definition)<decides><transacts>:void= D.ID <> "" and D.Type = ""
(Defs:[]definition).GetUntypedResourceMap<public>():[string]resource=
    UntypedResources := Defs.Filter(OnlyID)
    UntypedResources.Reduce(ToResourceMap, map{})
TypedAndID<public>(D:definition)<decides><transacts>:void= D.ID <> "" and D.Type <> ""
(Defs:[]definition).GetTypedResourceMap<public>():[string]resource=
    TypedResources := Defs.Filter(TypedAndID)
    TypedResources.Reduce(ToResourceMap, map{})

ToAffectorMap<public>(New:definition, All:[string][]side_effect_group)<transacts>:[string][]side_effect_group=
    NewAffectors := if(Old := All[New.ID]). Concatenate(Old, array. SideEffectGroup(New)) else. array. SideEffectGroup(New)
    ConcatenateMaps(All, map{ New.ID => NewAffectors })
HasID<public>(D:definition)<decides><transacts>:void= D.ID <> ""
GetAffectorMap<public>(Defs:[]definition):[string][]side_effect_group=
    Resources := Defs.Filter(HasID)
    Resources.Reduce(ToAffectorMap, map{})
ToTypeAffectorMap<public>(New:definition, All:[string][]side_effect_group)<transacts>:[string][]side_effect_group=
    NewAffectors := if(Old := All[New.Type]). Concatenate(Old, array. SideEffectGroup(New)) else. array. SideEffectGroup(New)
    ConcatenateMaps(All, map{ New.Type => NewAffectors })
GetTypeAffectorMap<public>(Defs:[]definition):[string][]side_effect_group=
    Resources := Defs.Filter(TypeOnly)
    Resources.Reduce(ToTypeAffectorMap, map{})

ToResourceLogicMap<public>(New:definition, All:[string]logic)<transacts>:[string]logic=
    ConcatenateMaps(All, map{ New.ID => true })
IsStaticResource<public>(D:definition)<decides><transacts>:void= D.StaticResource = true
(Defs:[]definition).GetStaticResourceMap<public>():[string]logic=
    StaticResources := Defs.Filter(IsStaticResource)
    StaticResources.Reduce(ToResourceLogicMap, map{})

ToTypeLogicMap<public>(New:definition, All:[string]logic)<transacts>:[string]logic=
    ConcatenateMaps(All, map{ New.Type => true })
IsStaticType<public>(D:definition)<decides><transacts>:void= D.StaticType = true
(Defs:[]definition).GetStaticTypeMap<public>():[string]logic=
    StaticTypes := Defs.Filter(IsStaticType)
    StaticTypes.Reduce(ToTypeLogicMap, map{})

HasRelationship<public>(D:definition)<decides><transacts>:void= D.ID <> "" and D.SubID <> ""
ToRelationshipMap<public>(New:definition, All:[string][]string)<transacts>:[string][]string=
    ConcatenateMaps(All, map{ New.ID => array. New.SubID })
(Defs:[]definition).GetRelationshipMap<public>():[string][]string=
    Relationships := Defs.Filter(HasRelationship)
    Relationships.Reduce(ToRelationshipMap, map{})

ToTypePool<public>(New:definition, All:[string][]string)<transacts>:[string][]string=
    NewPool := if(Old := All[New.Type]). Old + array. New.ID else. array. New.ID
    ConcatenateMaps(All, map{ New.Type => NewPool })
(Defs:[]definition).GetTypePoolMap<public>():[string][]string=
    TypedIDs := Defs.Filter(TypedAndID)
    TypedIDs.Reduce(ToTypePool, map{})

(Defs:[]definition).PrintAll<public>():void= for(D:Defs). Print("{D}")
