
using. /Verse.org/Simulation
using. /UnrealEngine.com/Temporary/Diagnostics
using. /UnrealEngine.com/Temporary/SpatialMath

using. Goo
using. Numb
using. Tableau
using. Vertex

props_vm<public> := class():
    var Ints<public>:[string]resource_int_property_vm = map{}
    var Nums<public>:[string]resource_num_property_vm = map{}
    var Floats<public>:[string]resource_float_property_vm = map{}
    var Bools<public>:[string]resource_bool_property_vm = map{}
    var Strs<public>:[string]resource_str_property_vm = map{}
    var Vec2s<public>:[string]resource_vec2_property_vm = map{}
    var Vec3s<public>:[string]resource_vec3_property_vm = map{}
    var Agents<public>:[string]resource_agent_property_vm = map{}

resource_vm<public> := class():
    GameState<public>:game_state
    ID<public>:string
    var Props<public>:props_vm = props_vm{}
    var Abilities<public>:[string]action_maker = map{}

    Init<public>(Resource:resource)<suspends>:void =
        for (PropID->Prop:Resource.Props):
            case(Prop.GetType()):
                prop_type.Integer =>
                    if (Property := prop_int[Prop]):
                        VM := resource_int_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            PropertyID := PropID
                            Focus := Property.Focus
                            FN := Property.FN
                            Tweak := Property.Tweak
                            Default := Property.Default
                        if. set Props.Ints[PropID] = VM
                prop_type.Num =>
                    if (Property := prop_num[Prop]):
                        VM := resource_num_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            PropertyID := PropID
                            Focus := Property.Focus
                            FN := Property.FN
                            Tweak := Property.Tweak
                            Default := Property.Default
                        if. set Props.Nums[PropID] = VM
                prop_type.Float =>
                    if (Property := prop_float[Prop]):
                        VM := resource_float_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            PropertyID := PropID
                            Focus := Property.Focus
                            FN := Property.FN
                            Tweak := Property.Tweak
                            Default := Property.Default
                        if. set Props.Floats[PropID] = VM
                prop_type.Bool =>
                    if (Property := prop_bool[Prop]):
                        VM := resource_bool_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            PropertyID := PropID
                            Focus := Property.Focus
                            FN := Property.FN
                            Tweak := Property.Tweak
                            Default := Property.Default
                        if. set Props.Bools[PropID] = VM
                prop_type.Str =>
                    if (Property := prop_str[Prop]):
                        VM := resource_str_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            PropertyID := PropID
                            Focus := Property.Focus
                            FN := Property.FN
                            Tweak := Property.Tweak
                            Default := Property.Default
                        if. set Props.Strs[PropID] = VM
                prop_type.Vec2 =>
                    if (Property := prop_vec2[Prop]):
                        VM := resource_vec2_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            PropertyID := PropID
                            Focus := Property.Focus
                            FN := Property.FN
                            Tweak := Property.Tweak
                            Default := Property.Default
                        if. set Props.Vec2s[PropID] = VM
                prop_type.Vec3 =>
                    if (Property := prop_vec3[Prop]):
                        VM := resource_vec3_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            PropertyID := PropID
                            Focus := Property.Focus
                            FN := Property.FN
                            Tweak := Property.Tweak
                            Default := Property.Default
                        if. set Props.Vec3s[PropID] = VM
                prop_type.Agent =>
                    if (Property := prop_agent[Prop]):
                        VM := resource_agent_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            PropertyID := PropID
                            Focus := Property.Focus
                            FN := Property.FN
                            Tweak := Property.Tweak
                            Default := Property.Default
                        if. set Props.Agents[PropID] = VM
                _ => {}
        for (AbilityID->Effects:Resource.Abilities):
            if. set Abilities[AbilityID] = action_maker:
                GameState := GameState
                Subject := Resource.ID
                Effects := Effects

resource_int_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PropertyID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Tweak<public>:half_path
    Default<public>:int
    var Values<public>:[string]int_goo := map{}

    ValueFor<public>(PlayerID:string):int_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            "+" =>
                NewVM := int_goo{}
                Base := GameState.GetIntProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetIntProp(ResourceID, Tweak, PlayerID)
                spawn. Combine(Base, Pipe, IntAdd, NewVM)
                NewVM
            _ =>
                if (FN <> ""). ProjectLog("Int[{FN}] does not exist for {ResourceID}.{PropertyID}@{PlayerID}", log_level.Warning)
                IntGoo(Default)

        if. set Values[PlayerID] = Result
        return Result

    var Nums<public>:[string]num_goo := map{}
    AsNum<public>(PlayerID:string):num_goo=
        Value := ValueFor(PlayerID)
        Converted := NumGoo(Map(Value, IntToNum))
        if. set Nums[PlayerID] = Converted
        return Converted

IntToNum(Integer:int)<transacts>:num = num. Value := Integer*1.0
IntAdd(First:int, Second:int)<transacts>:int = First + Second

resource_num_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PropertyID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Tweak<public>:half_path
    Default<public>:num
    var Values<public>:[string]num_goo := map{}

    ValueFor<public>(PlayerID:string):num_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            "Multiply" =>
                NewVM := num_goo{}
                Base:num_goo = GameState.GetNumProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetNumProp(ResourceID, Tweak, PlayerID)
                spawn. Combine(Base, Pipe, NumMultiply, NewVM)
                NewVM
            "Power" =>
                NewVM := num_goo{}
                Base := GameState.GetNumProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetFloatProp(ResourceID, Tweak, PlayerID)
                spawn. Combine(Base, Pipe, NumPower, NewVM)
                NewVM
            "Reverse Power" =>
                NewVM := num_goo{}
                Base := GameState.GetFloatProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetNumProp(ResourceID, Tweak, PlayerID)
                spawn. Combine(Pipe, Base, NumPower, NewVM)
                NewVM
            _ =>
                if (FN <> ""). ProjectLog("Num[{FN}] does not exist for {ResourceID}.{PropertyID}@{PlayerID}", log_level.Warning)
                NumGoo(Default)

        if. set Values[PlayerID] = Result
        return Result

    var Floats<public>:[string]float_goo := map{}
    AsFloat<public>(PlayerID:string):float_goo=
        Value := ValueFor(PlayerID)
        Converted := FloatGoo(Map(Value, ToFloat))
        if. set Floats[PlayerID] = Converted
        return Converted

resource_bool_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PropertyID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Tweak<public>:half_path
    Default<public>:logic
    var Values<public>:[string]bool_goo := map{}

    ValueFor<public>(PlayerID:string):bool_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            ">=" =>
                NewVM := bool_goo{}
                Base := GameState.GetNumProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetNumProp(ResourceID, Tweak, PlayerID)

                # Workaround for parametric issues...
                spawn. Combine(Base, Pipe, GTE, NewVM)
                NewVM
                # ComputedBool(Base, Pipe, GTE)
            "=" =>
                NewVM := bool_goo{}
                Base := GameState.GetNumProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetNumProp(ResourceID, Tweak, PlayerID)

                spawn. Combine(Base, Pipe, NumEquals, NewVM)
                NewVM
            "AND" =>
                NewVM := bool_goo{}
                Base := GameState.GetBoolProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetBoolProp(ResourceID, Tweak, PlayerID)

                spawn. Combine(Base, Pipe, AndBools, NewVM)
                NewVM
            "OR" =>
                NewVM := bool_goo{}
                Base := GameState.GetBoolProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetBoolProp(ResourceID, Tweak, PlayerID)

                spawn. Combine(Base, Pipe, OrBools, NewVM)
                NewVM
            "NOT" =>
                NewVM := bool_goo{}
                Base := GameState.GetBoolProp(ResourceID, Focus, PlayerID)

                spawn. MapTransformer(Base, NotBools, NewVM)
                NewVM
            "Not Empty" =>
                NewVM := bool_goo{}
                Base := GameState.GetStrProp(ResourceID, Focus, PlayerID)

                spawn. MapTransformer(Base, NotEmpty, NewVM)
                NewVM
            "Adopt" =>
                NewVM := bool_goo{}
                Base := GameState.GetStrProp(ResourceID, Focus, PlayerID)
                Finder := finder{ GameState := GameState, Focus := Tweak, PlayerID := PlayerID }
                spawn. Switcher(Base, Finder.FN, NewVM)
                NewVM
            _ =>
                if (FN <> ""). ProjectLog("Bool[{FN}] does not exist for {ResourceID}.{PropertyID}@{PlayerID}", log_level.Warning)
                BoolGoo(Default)

        if. set Values[PlayerID] = Result
        return Result

finder := class():
    GameState:game_state
    Focus:half_path
    PlayerID:string
    var ID:string = ""
    var Cache:[string]bool_goo = map{}

    FN<public>(ResourceID:string):bool_goo=
        if (Cached := Cache[ResourceID+PlayerID]). return Cached
        set ID = ResourceID
        ExistsVM := GameState.AwaitResourceGoo(ResourceID)
        Result := bool_goo{}
        spawn. Switcher(ExistsVM, SwitchDefault, Result)
        if. set Cache[ResourceID+PlayerID] = Result
        Result

    SwitchDefault<public>(ResourceExists:logic):bool_goo=
        if (ResourceExists?):
            GameState.GetBoolProp(ID, Focus, PlayerID)
        else. BoolGoo(false)

GTE(First:num, Second:num)<transacts>:logic = if (First.GreaterThanOrEqual[Second]). true else. false
NumEquals(First:num, Second:num)<transacts>:logic = if (First.Equals[Second]). true else. false
AndBools(First:logic, Second:logic)<transacts>:logic = if (First = true and Second = true). true else. false
OrBools(First:logic, Second:logic)<transacts>:logic = if (First = true or Second = true). true else. false
NotBools(Bool:logic)<transacts>:logic = if (Bool?). false else. true
NotEmpty(Str:string)<transacts>:logic = if (Str <> ""). true else. false

NumMultiply(First:num, Second:num):num = First * Second
NumPower(First:num, Second:float):num = First.Pow(Second)

resource_str_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PropertyID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Tweak<public>:half_path
    Default<public>:string
    var Values<public>:[string]string_goo := map{}

    ValueFor<public>(PlayerID:string):string_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            "To String" =>
                NewVM := string_goo{}
                PropType := GameState.GetPropType(ResourceID, Focus, PlayerID)
                case(PropType):
                    prop_type.Num =>
                        Base := GameState.GetNumProp(ResourceID, Focus, PlayerID)
                        spawn. MapTransformer(Base, NumToString, NewVM)
                    prop_type.Vec2 =>
                        Base := GameState.GetVec2Prop(ResourceID, Focus, PlayerID)
                        spawn. MapTransformer(Base, Vec2ToString, NewVM)
                    prop_type.Vec3 =>
                        Base := GameState.GetVec3Prop(ResourceID, Focus, PlayerID)
                        spawn. MapTransformer(Base, Vec3ToString, NewVM)
                    _ => StrGoo(Default)
                NewVM
            _ =>
                if (FN <> ""). ProjectLog("Str[{FN}] does not exist for {ResourceID}.{PropertyID}@{PlayerID}", log_level.Warning)
                StrGoo(Default)

        if. set Values[PlayerID] = Result
        return Result

NumToString(Num:num):string = "{Num}"
Vec2ToString(Vec2:vector2):string = "{Vec2}"
Vec3ToString(Vec3:vector3):string = "{Vec3}"

resource_vec2_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PropertyID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Tweak<public>:half_path
    Default<public>:vector2
    var Values<public>:[string]vec2_goo := map{}

    ValueFor<public>(PlayerID:string):vec2_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            "Append" =>
                NewVM := vec2_goo{}
                Base:float_goo = GameState.GetFloatProp(ResourceID, Focus, PlayerID)
                Pipe:float_goo = GameState.GetFloatProp(ResourceID, Tweak, PlayerID)
                spawn. Combine(Base, Pipe, AppendFloats, NewVM)
                NewVM
            _ =>
                if (FN <> ""). ProjectLog("Vec2[{FN}] does not exist for {ResourceID}.{PropertyID}@{PlayerID}", log_level.Warning)
                Vec2Goo(Default)

        if. set Values[PlayerID] = Result
        return Result

AppendFloats(X:float, Y:float):vector2 = vector2{ X := X, Y := Y }

resource_vec3_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PropertyID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Tweak<public>:half_path
    Default<public>:vector3
    var Values<public>:[string]vec3_goo := map{}

    ValueFor<public>(PlayerID:string):vec3_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            "Append" =>
                NewVM := vec3_goo{}
                Base:vec2_goo = GameState.GetVec2Prop(ResourceID, Focus, PlayerID)
                Pipe:float_goo = GameState.GetFloatProp(ResourceID, Tweak, PlayerID)
                spawn. Combine(Base, Pipe, AppendVec2AndFloat, NewVM)
                NewVM
            _ =>
                if (FN <> ""). ProjectLog("Vec3[{FN}] does not exist for {ResourceID}.{PropertyID}@{PlayerID}", log_level.Warning)
                Vec3Goo(Default)

        if. set Values[PlayerID] = Result
        return Result

AppendVec2AndFloat(Vec2:vector2, Z:float):vector3 = vector3{ X := Vec2.X, Y := Vec2.Y, Z := Z }

resource_agent_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PropertyID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Tweak<public>:half_path
    Default<public>:?agent
    var Values<public>:[string]agent_goo := map{}

    ValueFor<public>(PlayerID:string):agent_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            _ =>
                if (FN <> ""). ProjectLog("Agent[{FN}] does not exist for {ResourceID}.{PropertyID}@{PlayerID}", log_level.Warning)
                AgentGoo(Default)

        if. set Values[PlayerID] = Result
        return Result

resource_float_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PropertyID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Tweak<public>:half_path
    Default<public>:float
    var Values<public>:[string]float_goo := map{}

    ValueFor<public>(PlayerID:string):float_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            _ =>
                if (FN <> ""). ProjectLog("Float[{FN}] does not exist for {ResourceID}.{PropertyID}@{PlayerID}", log_level.Warning)
                FloatGoo(Default)

        if. set Values[PlayerID] = Result
        return Result

    var Nums<public>:[string]num_goo := map{}
    AsNum<public>(PlayerID:string):num_goo=
        Value := ValueFor(PlayerID)
        Converted := NumGoo(Map(Value, ToNum))
        if. set Nums[PlayerID] = Converted
        return Converted

    var Ints<public>:[string]int_goo := map{}
    AsInt<public>(PlayerID:string):int_goo=
        Value := ValueFor(PlayerID)
        Converted := IntGoo(Map(Value, FloatToInt))
        if. set Ints[PlayerID] = Converted
        return Converted

FloatToInt(Float:float):int = Float.ToInt()

action_maker<public> := class():
    GameState<public>:game_state
    Subject<public>:string
    Effects<public>:[]effect

    ActionFor<public>(NewTarget:string):action=
        action:
            GameState := GameState
            Subject := Subject
            Target := NewTarget
            Effects := Effects

action<public> := class():
    GameState<public>:game_state
    Subject<public>:string
    Target<public>:string
    Effects<public>:[]effect

    Execute<public>():void= spawn. Run(load{})
    ExecuteAgentFloat<public>(Agent:agent, Float:float):void= spawn. Run(load{})

    Run(Pay:load)<suspends>:void=
        var Iterator:int = 0
        loop:
            if (Effect := Effects[Iterator]):
                if (Effector := GameState.EffectorProvider.Get[Effect.FN]):
                    Focus := GameState.ResolvePath(Subject, Effect.Focus, Target)
                    Tweak := GameState.ResolvePath(Subject, Effect.Tweak, Target)

                    Commands := Effector.Play(Subject, Target, Focus, Tweak)

                    if (not Commands?). break

                    for (Command:Commands?). GameState.Commander.Fire(Command)
                    set Iterator += 1
                else:
                    Print("[{Effect.FN}] not found")
                    break
            else. break
