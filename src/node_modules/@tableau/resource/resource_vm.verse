
using. /Verse.org/Simulation
using. /UnrealEngine.com/Temporary/Diagnostics
using. /UnrealEngine.com/Temporary/SpatialMath

using. Goo
using. Numb
using. Tableau
using. Vertex

resource_state<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    ToPlayer<public>(PlayerID:string):player_state = player_state:
        GameState := GameState
        ResourceID := ResourceID
        PlayerID := PlayerID

player_state<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PlayerID<public>:string
    GetType<public>(P:half_path)<suspends>:prop_type=GameState.GetPropType(ResourceID, P, PlayerID)
    ToNum<public>(P:half_path)<suspends>:num_goo=GameState.GetNumProp(ResourceID, P, PlayerID)
    ToInt<public>(P:half_path)<suspends>:int_goo=GameState.GetIntProp(ResourceID, P, PlayerID)
    ToFloat<public>(P:half_path)<suspends>:float_goo=GameState.GetFloatProp(ResourceID, P, PlayerID)
    ToStr<public>(P:half_path)<suspends>:string_goo=GameState.GetStrProp(ResourceID, P, PlayerID)
    ToAgent<public>(P:half_path)<suspends>:agent_goo=GameState.GetAgentProp(ResourceID, P, PlayerID)
    ToVec2<public>(P:half_path)<suspends>:vec2_goo=GameState.GetVec2Prop(ResourceID, P, PlayerID)
    ToVec3<public>(P:half_path)<suspends>:vec3_goo=GameState.GetVec3Prop(ResourceID, P, PlayerID)
    ToBool<public>(P:half_path)<suspends>:bool_goo=GameState.GetBoolProp(ResourceID, P, PlayerID)

props_vm<public> := class():
    var Ints<public>:[string]int_vm = map{}
    var Nums<public>:[string]num_vm = map{}
    var Floats<public>:[string]float_vm = map{}
    var Bools<public>:[string]bool_vm = map{}
    var Strs<public>:[string]str_vm = map{}
    var Vec2s<public>:[string]vec2_vm = map{}
    var Vec3s<public>:[string]vec3_vm = map{}
    var Agents<public>:[string]agent_vm = map{}

resource_vm<public> := class():
    GameState<public>:game_state
    ID<public>:string
    var Props<public>:props_vm = props_vm{}
    var Abilities<public>:[string]action_maker = map{}

    Init<public>(Resource:resource)<suspends>:void =
        ScopedState := resource_state{ GameState := GameState, ResourceID := Resource.ID }
        for (PropID->Prop:Resource.Props):
            if (Prop.GetFN() <> ""). ProjectLog("Float[{Prop.GetFN()}] does not exist for {Resource.ID}.{PropID}", log_level.Warning)
            case(Prop.GetType()):
                prop_type.Integer =>
                    if (P := prop_int[Prop]):
                        VM := int_vm{ ScopedState := ScopedState, Prop := P }
                        if. set Props.Ints[PropID] = VM
                prop_type.Num =>
                    if (P := prop_num[Prop]):
                        VM := num_vm{ ScopedState := ScopedState, Prop := P }
                        if. set Props.Nums[PropID] = VM
                prop_type.Float =>
                    if (P := prop_float[Prop]):
                        VM := float_vm{ ScopedState := ScopedState, Prop := P }
                        if. set Props.Floats[PropID] = VM
                prop_type.Bool =>
                    if (P := prop_bool[Prop]):
                        VM := bool_vm:
                            GameState := GameState
                            ScopedState := ScopedState
                            ResourceID := Resource.ID
                            Prop := P
                        if. set Props.Bools[PropID] = VM
                prop_type.Str =>
                    if (P := prop_str[Prop]):
                        VM := str_vm{ ScopedState := ScopedState, Prop := P }
                        if. set Props.Strs[PropID] = VM
                prop_type.Vec2 =>
                    if (P := prop_vec2[Prop]):
                        VM := vec2_vm{ ScopedState := ScopedState, Prop := P }
                        if. set Props.Vec2s[PropID] = VM
                prop_type.Vec3 =>
                    if (P := prop_vec3[Prop]):
                        VM := vec3_vm{ ScopedState := ScopedState, Prop := P }
                        if. set Props.Vec3s[PropID] = VM
                prop_type.Agent =>
                    if (P := prop_agent[Prop]):
                        VM := agent_vm{ ScopedState := ScopedState, Prop := P }
                        if. set Props.Agents[PropID] = VM
                _ => {}
        for (AbilityID->Effects:Resource.Abilities):
            if. set Abilities[AbilityID] = action_maker:
                GameState := GameState
                Subject := Resource.ID
                Effects := Effects

int_vm<public> := class():
    ScopedState<public>:resource_state
    Prop<public>:prop_int
    var Values<public>:[string]int_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:int_goo =
        if (Value := Values[PlayerID]). return Value

        Scoped := ScopedState.ToPlayer(PlayerID)
        Result := case(Prop.FN):
            "+" => IntGoo(CompIntAdd(Prop.Focus, Scoped.ToInt, Prop.Tweak, Scoped.ToInt))
            _ => IntGoo(Prop.Default)

        if. set Values[PlayerID] = Result
        return Result

    var Nums<public>:[string]num_goo := map{}
    AsNum<public>(PlayerID:string)<suspends>:num_goo=
        if (Cached := Nums[PlayerID]). return Cached
        Converted := NumGoo(MapIntToNum(ValueFor(PlayerID)))
        if. set Nums[PlayerID] = Converted
        return Converted

    var Floats<public>:[string]float_goo := map{}
    AsFloat<public>(PlayerID:string)<suspends>:float_goo=
        if (Cached := Floats[PlayerID]). return Cached
        Converted := FloatGoo(MapIntToFloat(ValueFor(PlayerID)))
        if. set Floats[PlayerID] = Converted
        return Converted

    var Strs<public>:[string]string_goo := map{}
    AsStr<public>(PlayerID:string)<suspends>:string_goo=
        if (Cached := Strs[PlayerID]). return Cached
        Converted := StrGoo(MapIntToStr(ValueFor(PlayerID)))
        if. set Strs[PlayerID] = Converted
        return Converted

num_vm<public> := class():
    ScopedState<public>:resource_state
    Prop<public>:prop_num
    var Values<public>:[string]num_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:num_goo =
        if (Value := Values[PlayerID]). return Value

        Scoped := ScopedState.ToPlayer(PlayerID)
        Result := case(Prop.FN):
            "Multiply" => NumGoo(CompNumMultiply(Prop.Focus, Scoped.ToNum, Prop.Tweak, Scoped.ToNum))
            "Power" => NumGoo(CompNumPower(Prop.Focus, Scoped.ToNum, Prop.Tweak, Scoped.ToFloat))
            "Reverse Power" => NumGoo(CompNumPower(Prop.Tweak, Scoped.ToNum, Prop.Focus, Scoped.ToFloat))
            _ => NumGoo(Prop.Default)

        if. set Values[PlayerID] = Result
        return Result

    var Floats<public>:[string]float_goo := map{}
    AsFloat<public>(PlayerID:string)<suspends>:float_goo=
        if (Cached := Floats[PlayerID]). return Cached
        Converted := FloatGoo(MapNumToFloat(ValueFor(PlayerID)))
        if. set Floats[PlayerID] = Converted
        return Converted

    var Strs<public>:[string]string_goo := map{}
    AsStr<public>(PlayerID:string)<suspends>:string_goo=
        if (Cached := Strs[PlayerID]). return Cached
        Converted := StrGoo(MapNumToStr(ValueFor(PlayerID)))
        if. set Strs[PlayerID] = Converted
        return Converted

bool_vm<public> := class():
    GameState<public>:game_state
    ScopedState<public>:resource_state
    ResourceID<public>:string
    Prop<public>:prop_bool
    var Values<public>:[string]bool_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:bool_goo =
        if (Value := Values[PlayerID]). return Value

        Scoped := ScopedState.ToPlayer(PlayerID)
        Result := case(Prop.FN):
            ">=" => BoolGoo(CompGTE(Prop.Focus, Scoped.ToNum, Prop.Tweak, Scoped.ToNum))
            "=" => BoolGoo(CompNumEquals(Prop.Focus, Scoped.ToNum, Prop.Tweak, Scoped.ToNum))
            "AND" => BoolGoo(CompAnd(Prop.Focus, Scoped.ToBool, Prop.Tweak, Scoped.ToBool))
            "OR" => BoolGoo(CompOr(Prop.Focus, Scoped.ToBool, Prop.Tweak, Scoped.ToBool))
            "NOT" => BoolGoo(MapNot(Prop.Focus, Scoped.ToBool))
            "Not Empty" => BoolGoo(MapNotEmpty(Prop.Focus, Scoped.ToStr))
            "Adopt" =>
                Base := GameState.GetStrProp(ResourceID, Prop.Focus, PlayerID)
                Finder := finder{ GameState := GameState, Focus := Prop.Tweak, PlayerID := PlayerID }
                BoolGoo(SwitchMap(Base, Finder.FN))
            _ => BoolGoo(Prop.Default)

        if. set Values[PlayerID] = Result
        return Result

    var Strs<public>:[string]string_goo := map{}
    AsStr<public>(PlayerID:string)<suspends>:string_goo=
        Value := ValueFor(PlayerID)
        Converted := StrGoo(Map(Value, BoolToStr))
        if. set Strs[PlayerID] = Converted
        return Converted

BoolToStr(Value:logic):string = if (Value?). "true" else. "false"

finder := class():
    GameState:game_state
    Focus:half_path
    PlayerID:string
    var Cache:[string]bool_goo = map{}

    FN<public>(ResourceID:string):bool_goo=
        if (Cached := Cache[ResourceID+PlayerID]). return Cached
        ExistsVM := GameState.AwaitResourceGoo(ResourceID)
        Result := BoolGoo(SwitchMap(ExistsVM, SwitchDefault))
        if. set Cache[ResourceID+PlayerID] = Result
        Result

    SwitchDefault<public>(ResourceID:string)<suspends>:bool_goo=
        if (ResourceID <> ""). GameState.GetBoolProp(ResourceID, Focus, PlayerID)
        else. BoolGoo(false)

str_vm<public> := class():
    ScopedState<public>:resource_state
    Prop<public>:prop_str
    var Values<public>:[string]string_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:string_goo =
        if (Value := Values[PlayerID]). return Value

        Scoped := ScopedState.ToPlayer(PlayerID)
        Result := case(Prop.FN):
            "To String" =>
                PropType := Scoped.GetType(Prop.Focus)
                case(PropType):
                    prop_type.Num => StrGoo(MapNumToStr(Prop.Focus, Scoped.ToNum))
                    prop_type.Vec2 => StrGoo(MapVec2ToStr(Prop.Focus, Scoped.ToVec2))
                    prop_type.Vec3 => StrGoo(MapVec3ToStr(Prop.Focus, Scoped.ToVec3))
                    _ => StrGoo(Prop.Default)
            "Append" => StrGoo(CompAppendStrs(Prop.Focus, Scoped.ToStr, Prop.Tweak, Scoped.ToStr))
            _ => StrGoo(Prop.Default)

        if. set Values[PlayerID] = Result
        return Result

vec2_vm<public> := class():
    ScopedState<public>:resource_state
    Prop<public>:prop_vec2
    var Values<public>:[string]vec2_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:vec2_goo =
        if (Value := Values[PlayerID]). return Value

        Scoped := ScopedState.ToPlayer(PlayerID)
        Result := case(Prop.FN):
            "Append" => Vec2Goo(CompAppendFloats(Prop.Focus, Scoped.ToFloat, Prop.Tweak, Scoped.ToFloat))
            _ => Vec2Goo(Prop.Default)

        if. set Values[PlayerID] = Result
        return Result

    var Strs<public>:[string]string_goo := map{}
    AsStr<public>(PlayerID:string)<suspends>:string_goo=
        if (Cached := Strs[PlayerID]). return Cached
        Converted := StrGoo(MapVec2ToStr(ValueFor(PlayerID)))
        if. set Strs[PlayerID] = Converted
        return Converted

vec3_vm<public> := class():
    ScopedState<public>:resource_state
    Prop<public>:prop_vec3
    var Values<public>:[string]vec3_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:vec3_goo =
        if (Value := Values[PlayerID]). return Value

        Scoped := ScopedState.ToPlayer(PlayerID)
        Result := case(Prop.FN):
            "Append" => Vec3Goo(CompAppendVec2AndFloat(Prop.Focus, Scoped.ToVec2, Prop.Tweak, Scoped.ToFloat))
            _ => Vec3Goo(Prop.Default)

        if. set Values[PlayerID] = Result
        return Result

    var Strs<public>:[string]string_goo := map{}
    AsStr<public>(PlayerID:string)<suspends>:string_goo=
        if (Cached := Strs[PlayerID]). return Cached
        Converted := StrGoo(MapVec3ToStr(ValueFor(PlayerID)))
        if. set Strs[PlayerID] = Converted
        return Converted

Vec3ToStr(Value:vector3):string = "{Value}"

agent_vm<public> := class():
    ScopedState<public>:resource_state
    Prop<public>:prop_agent
    var Values<public>:[string]agent_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:agent_goo =
        if (Value := Values[PlayerID]). return Value

        Scoped := ScopedState.ToPlayer(PlayerID)
        Result := case(Prop.FN):
            _ => AgentGoo(Prop.Default)

        if. set Values[PlayerID] = Result
        return Result

    var Strs<public>:[string]string_goo := map{}
    AsStr<public>(PlayerID:string)<suspends>:string_goo=
        if (Cached := Strs[PlayerID]). return Cached
        Converted := StrGoo(MapAgentToStr(ValueFor(PlayerID)))
        if. set Strs[PlayerID] = Converted
        return Converted

float_vm<public> := class():
    ScopedState<public>:resource_state
    Prop<public>:prop_float
    var Values<public>:[string]float_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:float_goo =
        if (Value := Values[PlayerID]). return Value

        Scoped := ScopedState.ToPlayer(PlayerID)
        Result := case(Prop.FN):
            "*" => FloatGoo(CompFloatMultiply(Prop.Focus, Scoped.ToFloat, Prop.Tweak, Scoped.ToFloat))
            _ => FloatGoo(Prop.Default)

        if. set Values[PlayerID] = Result
        return Result

    var Nums<public>:[string]num_goo := map{}
    AsNum<public>(PlayerID:string)<suspends>:num_goo=
        if (Cached := Nums[PlayerID]). return Cached
        Converted := NumGoo(MapFloatToNum(ValueFor(PlayerID)))
        if. set Nums[PlayerID] = Converted
        return Converted

    var Ints<public>:[string]int_goo := map{}
    AsInt<public>(PlayerID:string)<suspends>:int_goo=
        if (Cached := Ints[PlayerID]). return Cached
        Converted := IntGoo(MapFloatToInt(ValueFor(PlayerID)))
        if. set Ints[PlayerID] = Converted
        return Converted

    var Strs<public>:[string]string_goo := map{}
    AsStr<public>(PlayerID:string)<suspends>:string_goo=
        if (Cached := Strs[PlayerID]). return Cached
        Converted := StrGoo(MapFloatToStr(ValueFor(PlayerID)))
        if. set Strs[PlayerID] = Converted
        return Converted

action_maker<public> := class():
    GameState<public>:game_state
    Subject<public>:string
    Effects<public>:[]effect

    ActionFor<public>(NewTarget:string):action=
        action:
            GameState := GameState
            Subject := Subject
            Target := NewTarget
            Effects := Effects

action<public> := class():
    GameState<public>:game_state
    Subject<public>:string
    Target<public>:string
    Effects<public>:[]effect

    ExecuteEmpty<public>():void= spawn. Run()
    ExecuteAgentFloat<public>(Agent:agent, Float:float):void= spawn. Run()

    Run()<suspends>:void=
        var Iterator:int = 0
        loop:
            if (Effect := Effects[Iterator]):
                if (Effector := GameState.EffectorProvider.Get[Effect.FN]):
                    Focus := GameState.ResolvePath(Subject, Effect.Focus, Target)
                    Tweak := GameState.ResolvePath(Subject, Effect.Tweak, Target)

                    Commands := Effector.Play(Subject, Target, Focus, Tweak)

                    if (not Commands?). break
                    set Iterator += 1
                else:
                    ProjectLog("[{Effect.FN}] not found", log_level.Warning)
                    break
            else. break
