
using. /Verse.org/Simulation
using. /UnrealEngine.com/Temporary/Diagnostics
using. /UnrealEngine.com/Temporary/SpatialMath

using. Goo
using. Numb
using. Tableau
using. Vertex

props_vm<public> := class():
    var Ints<public>:[string]resource_int_property_vm = map{}
    var Nums<public>:[string]resource_num_property_vm = map{}
    var Floats<public>:[string]resource_float_property_vm = map{}
    var Bools<public>:[string]resource_bool_property_vm = map{}
    var Strs<public>:[string]resource_str_property_vm = map{}
    var Vec2s<public>:[string]resource_vec2_property_vm = map{}
    var Vec3s<public>:[string]resource_vec3_property_vm = map{}
    var Agents<public>:[string]resource_agent_property_vm = map{}

resource_vm<public> := class():
    GameState<public>:game_state
    ID<public>:string
    var Props<public>:props_vm = props_vm{}
    var Abilities<public>:[string]action_maker = map{}

    Init<public>(Resource:resource)<suspends>:void =
        for (PropID->Prop:Resource.Props):
            case(Prop.GetType()):
                prop_type.Integer =>
                    if (Property := prop_int[Prop]):
                        VM := resource_int_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            PropertyID := PropID
                            Focus := Property.Focus
                            FN := Property.FN
                            Tweak := Property.Tweak
                            Default := Property.Default
                        if. set Props.Ints[PropID] = VM
                prop_type.Num =>
                    if (Property := prop_num[Prop]):
                        VM := resource_num_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            PropertyID := PropID
                            Focus := Property.Focus
                            FN := Property.FN
                            Tweak := Property.Tweak
                            Default := Property.Default
                        if. set Props.Nums[PropID] = VM
                prop_type.Float =>
                    if (Property := prop_float[Prop]):
                        VM := resource_float_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            PropertyID := PropID
                            Focus := Property.Focus
                            FN := Property.FN
                            Tweak := Property.Tweak
                            Default := Property.Default
                        if. set Props.Floats[PropID] = VM
                prop_type.Bool =>
                    if (Property := prop_bool[Prop]):
                        VM := resource_bool_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            PropertyID := PropID
                            Focus := Property.Focus
                            FN := Property.FN
                            Tweak := Property.Tweak
                            Default := Property.Default
                        if. set Props.Bools[PropID] = VM
                prop_type.Str =>
                    if (Property := prop_str[Prop]):
                        VM := resource_str_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            PropertyID := PropID
                            Focus := Property.Focus
                            FN := Property.FN
                            Tweak := Property.Tweak
                            Default := Property.Default
                        if. set Props.Strs[PropID] = VM
                prop_type.Vec2 =>
                    if (Property := prop_vec2[Prop]):
                        VM := resource_vec2_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            PropertyID := PropID
                            Focus := Property.Focus
                            FN := Property.FN
                            Tweak := Property.Tweak
                            Default := Property.Default
                        if. set Props.Vec2s[PropID] = VM
                prop_type.Vec3 =>
                    if (Property := prop_vec3[Prop]):
                        VM := resource_vec3_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            PropertyID := PropID
                            Focus := Property.Focus
                            FN := Property.FN
                            Tweak := Property.Tweak
                            Default := Property.Default
                        if. set Props.Vec3s[PropID] = VM
                prop_type.Agent =>
                    if (Property := prop_agent[Prop]):
                        VM := resource_agent_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            PropertyID := PropID
                            Focus := Property.Focus
                            FN := Property.FN
                            Tweak := Property.Tweak
                            Default := Property.Default
                        if. set Props.Agents[PropID] = VM
                _ => {}
        for (AbilityID->Effects:Resource.Abilities):
            if. set Abilities[AbilityID] = action_maker:
                GameState := GameState
                Subject := Resource.ID
                Effects := Effects

resource_int_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PropertyID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Tweak<public>:half_path
    Default<public>:int
    var Values<public>:[string]int_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:int_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            "+" =>
                Base := GameState.GetIntProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetIntProp(ResourceID, Tweak, PlayerID)
                IntGoo(Computed(Base, Pipe, IntAdd))
            _ =>
                if (FN <> ""). ProjectLog("Int[{FN}] does not exist for {ResourceID}.{PropertyID}@{PlayerID}", log_level.Warning)
                IntGoo(Default)

        if. set Values[PlayerID] = Result
        return Result

    var Nums<public>:[string]num_goo := map{}
    AsNum<public>(PlayerID:string)<suspends>:num_goo=
        Value := ValueFor(PlayerID)
        Converted := NumGoo(Map(Value, IntToNum))
        if. set Nums[PlayerID] = Converted
        return Converted

    var Floats<public>:[string]float_goo := map{}
    AsFloat<public>(PlayerID:string)<suspends>:float_goo=
        Value := ValueFor(PlayerID)
        Converted := FloatGoo(Map(Value, IntToFloat))
        if. set Floats[PlayerID] = Converted
        return Converted

    var Strs<public>:[string]string_goo := map{}
    AsStr<public>(PlayerID:string)<suspends>:string_goo=
        Value := ValueFor(PlayerID)
        Converted := StrGoo(Map(Value, IntToStr))
        if. set Strs[PlayerID] = Converted
        return Converted

IntToStr(Value:int):string = "{Value}"
IntToNum(Integer:int)<transacts>:num = num. Value := Integer*1.0
IntToFloat(Integer:int)<transacts>:float = Integer*1.0
IntAdd(First:int, Second:int)<transacts>:int = First + Second

resource_num_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PropertyID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Tweak<public>:half_path
    Default<public>:num
    var Values<public>:[string]num_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:num_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            "Multiply" =>
                Base := GameState.GetNumProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetNumProp(ResourceID, Tweak, PlayerID)
                NumGoo(Computed(Base, Pipe, NumMultiply))
            "Power" =>
                Base := GameState.GetNumProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetFloatProp(ResourceID, Tweak, PlayerID)
                NumGoo(Computed(Base, Pipe, NumPower))
            "Reverse Power" =>
                Base := GameState.GetFloatProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetNumProp(ResourceID, Tweak, PlayerID)
                NumGoo(Computed(Pipe, Base, NumPower))
            _ =>
                if (FN <> ""). ProjectLog("Num[{FN}] does not exist for {ResourceID}.{PropertyID}@{PlayerID}", log_level.Warning)
                NumGoo(Default)

        if. set Values[PlayerID] = Result
        return Result

    var Floats<public>:[string]float_goo := map{}
    AsFloat<public>(PlayerID:string)<suspends>:float_goo=
        Value := ValueFor(PlayerID)
        Converted := FloatGoo(Map(Value, ToFloat))
        if. set Floats[PlayerID] = Converted
        return Converted

    var Strs<public>:[string]string_goo := map{}
    AsStr<public>(PlayerID:string)<suspends>:string_goo=
        Value := ValueFor(PlayerID)
        Converted := StrGoo(Map(Value, NumToStr))
        if. set Strs[PlayerID] = Converted
        return Converted

NumToStr(Value:num):string = "{Value}"

resource_bool_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PropertyID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Tweak<public>:half_path
    Default<public>:logic
    var Values<public>:[string]bool_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:bool_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            ">=" =>
                Base := GameState.GetNumProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetNumProp(ResourceID, Tweak, PlayerID)
                BoolGoo(Computed(Base, Pipe, GTE))
            "=" =>
                Base := GameState.GetNumProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetNumProp(ResourceID, Tweak, PlayerID)
                BoolGoo(Computed(Base, Pipe, NumEquals))
            "AND" =>
                Base := GameState.GetBoolProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetBoolProp(ResourceID, Tweak, PlayerID)
                BoolGoo(Computed(Base, Pipe, AndBools))
            "OR" =>
                Base := GameState.GetBoolProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetBoolProp(ResourceID, Tweak, PlayerID)
                BoolGoo(Computed(Base, Pipe, OrBools))
            "NOT" =>
                Base := GameState.GetBoolProp(ResourceID, Focus, PlayerID)
                BoolGoo(Map(Base, NotBools))
            "Not Empty" =>
                Base := GameState.GetStrProp(ResourceID, Focus, PlayerID)
                BoolGoo(Map(Base, NotEmpty))
            "Adopt" =>
                Base := GameState.GetStrProp(ResourceID, Focus, PlayerID)
                Finder := finder{ GameState := GameState, Focus := Tweak, PlayerID := PlayerID }
                BoolGoo(SwitchMap(Base, Finder.FN))
            _ =>
                if (FN <> ""). ProjectLog("Bool[{FN}] does not exist for {ResourceID}.{PropertyID}@{PlayerID}", log_level.Warning)
                BoolGoo(Default)

        if. set Values[PlayerID] = Result
        return Result

    var Strs<public>:[string]string_goo := map{}
    AsStr<public>(PlayerID:string)<suspends>:string_goo=
        Value := ValueFor(PlayerID)
        Converted := StrGoo(Map(Value, BoolToStr))
        if. set Strs[PlayerID] = Converted
        return Converted

BoolToStr(Value:logic):string = if (Value?). "true" else. "false"

finder := class():
    GameState:game_state
    Focus:half_path
    PlayerID:string
    var Cache:[string]bool_goo = map{}

    FN<public>(ResourceID:string):bool_goo=
        if (Cached := Cache[ResourceID+PlayerID]). return Cached
        ExistsVM := GameState.AwaitResourceGoo(ResourceID)
        Result := BoolGoo(SwitchMap(ExistsVM, SwitchDefault))
        if. set Cache[ResourceID+PlayerID] = Result
        Result

    SwitchDefault<public>(ResourceID:string)<suspends>:bool_goo=
        if (ResourceID <> ""). GameState.GetBoolProp(ResourceID, Focus, PlayerID)
        else. BoolGoo(false)

GTE(First:num, Second:num)<transacts>:logic = if (First.GreaterThanOrEqual[Second]). true else. false
NumEquals(First:num, Second:num)<transacts>:logic = if (First.Equals[Second]). true else. false
AndBools(First:logic, Second:logic)<transacts>:logic = if (First = true and Second = true). true else. false
OrBools(First:logic, Second:logic)<transacts>:logic = if (First = true or Second = true). true else. false
NotBools(Bool:logic)<transacts>:logic = if (Bool?). false else. true
NotEmpty(Str:string)<transacts>:logic = if (Str <> ""). true else. false

NumMultiply(First:num, Second:num):num = First * Second
NumPower(First:num, Second:float):num = First.Pow(Second)

resource_str_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PropertyID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Tweak<public>:half_path
    Default<public>:string
    var Values<public>:[string]string_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:string_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            "To String" =>
                PropType := GameState.GetPropType(ResourceID, Focus, PlayerID)
                case(PropType):
                    prop_type.Num =>
                        Base := GameState.GetNumProp(ResourceID, Focus, PlayerID)
                        StrGoo(Map(Base, NumToString))
                    prop_type.Vec2 =>
                        Base := GameState.GetVec2Prop(ResourceID, Focus, PlayerID)
                        StrGoo(Map(Base, Vec2ToString))
                    prop_type.Vec3 =>
                        Base := GameState.GetVec3Prop(ResourceID, Focus, PlayerID)
                        StrGoo(Map(Base, Vec3ToString))
                    _ => StrGoo(Default)
            "Append" =>
                Base := GameState.GetStrProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetStrProp(ResourceID, Tweak, PlayerID)
                StrGoo(Computed(Base, Pipe, AppendStrs))
            _ =>
                if (FN <> ""). ProjectLog("Str[{FN}] does not exist for {ResourceID}.{PropertyID}@{PlayerID}", log_level.Warning)
                StrGoo(Default)

        if. set Values[PlayerID] = Result
        return Result

AppendStrs(First:string, Second:string):string = "{First}{Second}"
NumToString(Num:num):string = "{Num}"
Vec2ToString(Vec2:vector2):string = "{Vec2}"
Vec3ToString(Vec3:vector3):string = "{Vec3}"

resource_vec2_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PropertyID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Tweak<public>:half_path
    Default<public>:vector2
    var Values<public>:[string]vec2_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:vec2_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            "Append" =>
                Base := GameState.GetFloatProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetFloatProp(ResourceID, Tweak, PlayerID)
                Vec2Goo(Computed(Base, Pipe, AppendFloats))
            _ =>
                if (FN <> ""). ProjectLog("Vec2[{FN}] does not exist for {ResourceID}.{PropertyID}@{PlayerID}", log_level.Warning)
                Vec2Goo(Default)

        if. set Values[PlayerID] = Result
        return Result

    var Strs<public>:[string]string_goo := map{}
    AsStr<public>(PlayerID:string)<suspends>:string_goo=
        Value := ValueFor(PlayerID)
        Converted := StrGoo(Map(Value, Vec2ToStr))
        if. set Strs[PlayerID] = Converted
        return Converted

Vec2ToStr(Value:vector2):string = "{Value}"
AppendFloats(X:float, Y:float):vector2 = vector2{ X := X, Y := Y }

resource_vec3_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PropertyID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Tweak<public>:half_path
    Default<public>:vector3
    var Values<public>:[string]vec3_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:vec3_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            "Append" =>
                Base := GameState.GetVec2Prop(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetFloatProp(ResourceID, Tweak, PlayerID)
                Vec3Goo(Computed(Base, Pipe, AppendVec2AndFloat))
            _ =>
                if (FN <> ""). ProjectLog("Vec3[{FN}] does not exist for {ResourceID}.{PropertyID}@{PlayerID}", log_level.Warning)
                Vec3Goo(Default)

        if. set Values[PlayerID] = Result
        return Result

    var Strs<public>:[string]string_goo := map{}
    AsStr<public>(PlayerID:string)<suspends>:string_goo=
        Value := ValueFor(PlayerID)
        Converted := StrGoo(Map(Value, Vec3ToStr))
        if. set Strs[PlayerID] = Converted
        return Converted

Vec3ToStr(Value:vector3):string = "{Value}"
AppendVec2AndFloat(Vec2:vector2, Z:float):vector3 = vector3{ X := Vec2.X, Y := Vec2.Y, Z := Z }

resource_agent_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PropertyID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Tweak<public>:half_path
    Default<public>:?agent
    var Values<public>:[string]agent_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:agent_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            _ =>
                if (FN <> ""). ProjectLog("Agent[{FN}] does not exist for {ResourceID}.{PropertyID}@{PlayerID}", log_level.Warning)
                AgentGoo(Default)

        if. set Values[PlayerID] = Result
        return Result

    var Strs<public>:[string]string_goo := map{}
    AsStr<public>(PlayerID:string)<suspends>:string_goo=
        Value := ValueFor(PlayerID)
        Converted := StrGoo(Map(Value, AgentToStr))
        if. set Strs[PlayerID] = Converted
        return Converted

AgentToStr(Value:?agent):string = if (Value?). "[HAS AGENT]" else. "[NO AGENT]"

resource_float_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PropertyID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Tweak<public>:half_path
    Default<public>:float
    var Values<public>:[string]float_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:float_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            "*" =>
                Base := GameState.GetFloatProp(ResourceID, Focus, PlayerID)
                Pipe := GameState.GetFloatProp(ResourceID, Tweak, PlayerID)
                FloatGoo(Computed(Base, Pipe, FloatMultiply))
            _ =>
                if (FN <> ""). ProjectLog("Float[{FN}] does not exist for {ResourceID}.{PropertyID}@{PlayerID}", log_level.Warning)
                FloatGoo(Default)

        if. set Values[PlayerID] = Result
        return Result

    var Nums<public>:[string]num_goo := map{}
    AsNum<public>(PlayerID:string)<suspends>:num_goo=
        Value := ValueFor(PlayerID)
        Converted := NumGoo(Map(Value, ToNum))
        if. set Nums[PlayerID] = Converted
        return Converted

    var Ints<public>:[string]int_goo := map{}
    AsInt<public>(PlayerID:string)<suspends>:int_goo=
        Value := ValueFor(PlayerID)
        Converted := IntGoo(Map(Value, FloatToInt))
        if. set Ints[PlayerID] = Converted
        return Converted

    var Strs<public>:[string]string_goo := map{}
    AsStr<public>(PlayerID:string)<suspends>:string_goo=
        Value := ValueFor(PlayerID)
        Converted := StrGoo(Map(Value, FloatToStr))
        if. set Strs[PlayerID] = Converted
        return Converted

FloatToStr(Value:float):string = "{Value}"
FloatToInt(Float:float):int = Float.ToInt()
FloatMultiply(First:float, Second:float):float = First * Second

action_maker<public> := class():
    GameState<public>:game_state
    Subject<public>:string
    Effects<public>:[]effect

    ActionFor<public>(NewTarget:string):action=
        action:
            GameState := GameState
            Subject := Subject
            Target := NewTarget
            Effects := Effects

action<public> := class():
    GameState<public>:game_state
    Subject<public>:string
    Target<public>:string
    Effects<public>:[]effect

    ExecuteEmpty<public>():void= spawn. Run()
    ExecuteAgentFloat<public>(Agent:agent, Float:float):void= spawn. Run()

    Run()<suspends>:void=
        var Iterator:int = 0
        loop:
            if (Effect := Effects[Iterator]):
                if (Effector := GameState.EffectorProvider.Get[Effect.FN]):
                    Focus := GameState.ResolvePath(Subject, Effect.Focus, Target)
                    Tweak := GameState.ResolvePath(Subject, Effect.Tweak, Target)

                    Commands := Effector.Play(Subject, Target, Focus, Tweak)

                    if (not Commands?). break
                    set Iterator += 1
                else:
                    ProjectLog("[{Effect.FN}] not found", log_level.Warning)
                    break
            else. break
