
using. /Verse.org/Simulation
using. /UnrealEngine.com/Temporary/Diagnostics
using. /UnrealEngine.com/Temporary/SpatialMath

using. Goo
using. Numb
using. Tableau
using. Vertex

resource_state<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    ToPlayer<public>(PlayerID:string):player_state = player_state:
        GameState := GameState
        ResourceID := ResourceID
        PlayerID := PlayerID

player_state<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    PlayerID<public>:string
    ToNum<public>(P:half_path)<suspends>:num_goo=GameState.GetNumProp(ResourceID, P, PlayerID)
    ToInt<public>(P:half_path)<suspends>:int_goo=GameState.GetIntProp(ResourceID, P, PlayerID)
    ToFloat<public>(P:half_path)<suspends>:float_goo=GameState.GetFloatProp(ResourceID, P, PlayerID)
    ToStr<public>(P:half_path)<suspends>:string_goo=GameState.GetStrProp(ResourceID, P, PlayerID)
    ToAgent<public>(P:half_path)<suspends>:agent_goo=GameState.GetAgentProp(ResourceID, P, PlayerID)
    ToVec2<public>(P:half_path)<suspends>:vec2_goo=GameState.GetVec2Prop(ResourceID, P, PlayerID)
    ToVec3<public>(P:half_path)<suspends>:vec3_goo=GameState.GetVec3Prop(ResourceID, P, PlayerID)
    ToBool<public>(P:half_path)<suspends>:bool_goo=GameState.GetBoolProp(ResourceID, P, PlayerID)

props_vm<public> := class():
    var Ints<public>:[string]int_vm = map{}
    var Nums<public>:[string]num_vm = map{}
    var Floats<public>:[string]float_vm = map{}
    var Bools<public>:[string]bool_vm = map{}
    var Strs<public>:[string]str_vm = map{}
    var Vec2s<public>:[string]vec2_vm = map{}
    var Vec3s<public>:[string]vec3_vm = map{}
    var Agents<public>:[string]agent_vm = map{}

resource_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    var Props<public>:props_vm = props_vm{}
    var Abilities<public>:[string]action_maker = map{}

    var PropTypes<public>:[string]prop_type = map{}
    GetPropType<public>(PropID:string)<transacts>:prop_type= PropTypes[PropID] or prop_type.Unknown

    Init<public>(Resource:resource)<suspends>:void =
        for (PropID->Prop:Resource.Props):
            # ValidateProp(PropID, Prop)
            StoreProp(PropID, Prop)

        for (AbilityID->Effects:Resource.Abilities):
            if. set Abilities[AbilityID] = action_maker:
                GameState := GameState
                Subject := ResourceID
                Effects := Effects

    # ValidateProp(PropID:string, Prop:prop):void=
    #     if (Prop.FN <> ""). ProjectLog("{Prop.Type}[{Prop.FN}] does not exist for {ResourceID}.{PropID}", log_level.Warning)

    StoreProp(PropID:string, Prop:prop):void=
        State := resource_state{ GameState := GameState, ResourceID := ResourceID }
        if. set PropTypes[PropID] = Prop.Type
        case(Prop.Type):
            prop_type.Integer => if (P := prop_int[Prop]):
                if. set Props.Ints[PropID] = int_vm{ State := State, Prop := P }
            prop_type.Num => if (P := prop_num[Prop]):
                if. set Props.Nums[PropID] = num_vm{ State := State, Prop := P }
            prop_type.Float => if (P := prop_float[Prop]):
                if. set Props.Floats[PropID] = float_vm{ State := State, Prop := P }
            prop_type.Bool => if (P := prop_bool[Prop]):
                if. set Props.Bools[PropID] = bool_vm:
                    GameState := GameState
                    State := State
                    Prop := P
            prop_type.Str => if (P := prop_str[Prop]):
                if. set Props.Strs[PropID] = StrProp(State, P)
            prop_type.Vec2 => if (P := prop_vec2[Prop]):
                if. set Props.Vec2s[PropID] = vec2_vm{ State := State, Prop := P }
            prop_type.Vec3 => if (P := prop_vec3[Prop]):
                if. set Props.Vec3s[PropID] = vec3_vm{ State := State, Prop := P }
            prop_type.Agent => if (P := prop_agent[Prop]):
                if. set Props.Agents[PropID] = agent_vm{ State := State, Prop := P }
            _ => {}

    GetStrProp<public>(PropID:string, PlayerID:string)<suspends>:string_goo=
        Type := GetPropType(PropID)
        if (Type = prop_type.Unknown). ProjectLog("Not found for {ResourceID}.{PropID}@{PlayerID}: {Type} -> Str", log_level.Warning)
        State := resource_state{ GameState := GameState, ResourceID := ResourceID }
        PropVM := case(Type):
            prop_type.Str => if (P := Props.Strs[PropID]). P else. StrProp(State)
            prop_type.Integer => if (P := Props.Ints[PropID]). ToStrProp(State, P.Prop, Path(ResourceID, PropID)) else. StrProp(State)
            prop_type.Num => if (P := Props.Nums[PropID]). ToStrProp(State, P.Prop, Path(ResourceID, PropID)) else. StrProp(State)
            prop_type.Float => if (P := Props.Floats[PropID]). ToStrProp(State, P.Prop, Path(ResourceID, PropID)) else. StrProp(State)
            prop_type.Bool => if (P := Props.Bools[PropID]). ToStrProp(State, P.Prop, Path(ResourceID, PropID)) else. StrProp(State)
            prop_type.Vec2 => if (P := Props.Vec2s[PropID]). ToStrProp(State, P.Prop, Path(ResourceID, PropID)) else. StrProp(State)
            prop_type.Vec3 => if (P := Props.Vec3s[PropID]). ToStrProp(State, P.Prop, Path(ResourceID, PropID)) else. StrProp(State)
            prop_type.Agent => if (P := Props.Agents[PropID]). ToStrProp(State, P.Prop, Path(ResourceID, PropID)) else. StrProp(State)
            _ => StrProp(State)
        if. set Props.Strs[PropID] = PropVM
        PropVM.ValueFor(PlayerID)

    GetIntProp<public>(PropID:string, PlayerID:string)<suspends>:int_goo=
        Type := GetPropType(PropID)
        if (Type = prop_type.Unknown). ProjectLog("Not found for {ResourceID}.{PropID}@{PlayerID}: {Type} -> Int", log_level.Warning)
        State := resource_state{ GameState := GameState, ResourceID := ResourceID }
        PropVM := case(Type):
            prop_type.Integer => if (P := Props.Ints[PropID]). P else. IntProp(State)
            prop_type.Float => if (P := Props.Floats[PropID]). ToIntProp(State, P.Prop, Path(ResourceID, PropID)) else. IntProp(State)
            _ => IntProp(State)
        if. set Props.Ints[PropID] = PropVM
        PropVM.ValueFor(PlayerID)

    GetNumProp<public>(PropID:string, PlayerID:string)<suspends>:num_goo=
        Type := GetPropType(PropID)
        if (Type = prop_type.Unknown). ProjectLog("Not found for {ResourceID}.{PropID}@{PlayerID}: {Type} -> Num", log_level.Warning)
        State := resource_state{ GameState := GameState, ResourceID := ResourceID }
        PropVM := case(Type):
            prop_type.Num => if (P := Props.Nums[PropID]). P else. NumProp(State)
            prop_type.Integer => if (P := Props.Ints[PropID]). ToNumProp(State, P.Prop, Path(ResourceID, PropID)) else. NumProp(State)
            prop_type.Float => if (P := Props.Floats[PropID]). ToNumProp(State, P.Prop, Path(ResourceID, PropID)) else. NumProp(State)
            _ => NumProp(State)
        if. set Props.Nums[PropID] = PropVM
        PropVM.ValueFor(PlayerID)

    GetFloatProp<public>(PropID:string, PlayerID:string)<suspends>:float_goo=
        Type := GetPropType(PropID)
        if (Type = prop_type.Unknown). ProjectLog("Not found for {ResourceID}.{PropID}@{PlayerID}: {Type} -> Float", log_level.Warning)
        State := resource_state{ GameState := GameState, ResourceID := ResourceID }
        PropVM := case(Type):
            prop_type.Float => if (P := Props.Floats[PropID]). P else. FloatProp(State)
            prop_type.Integer => if (P := Props.Ints[PropID]). ToFloatProp(State, P.Prop, Path(ResourceID, PropID)) else. FloatProp(State)
            prop_type.Num => if (P := Props.Nums[PropID]). ToFloatProp(State, P.Prop, Path(ResourceID, PropID)) else. FloatProp(State)
            _ => FloatProp(State)
        if. set Props.Floats[PropID] = PropVM
        PropVM.ValueFor(PlayerID)

    GetBoolProp<public>(PropID:string, PlayerID:string)<suspends>:bool_goo=
        Type := GetPropType(PropID)
        if (Type = prop_type.Unknown). ProjectLog("Not found for {ResourceID}.{PropID}@{PlayerID}: {Type} -> Bool", log_level.Warning)
        State := resource_state{ GameState := GameState, ResourceID := ResourceID }
        PropVM := case(Type):
            prop_type.Bool => if (P := Props.Bools[PropID]). P else. BoolProp(GameState, State)
            _ => BoolProp(GameState, State)
        if. set Props.Bools[PropID] = PropVM
        PropVM.ValueFor(PlayerID)

    GetVec2Prop<public>(PropID:string, PlayerID:string)<suspends>:vec2_goo=
        Type := GetPropType(PropID)
        if (Type = prop_type.Unknown). ProjectLog("Not found for {ResourceID}.{PropID}@{PlayerID}: {Type} -> Vec2", log_level.Warning)
        State := resource_state{ GameState := GameState, ResourceID := ResourceID }
        PropVM := case(Type):
            prop_type.Vec2 => if (P := Props.Vec2s[PropID]). P else. Vec2Prop(State)
            _ => Vec2Prop(State)
        if. set Props.Vec2s[PropID] = PropVM
        PropVM.ValueFor(PlayerID)

    GetVec3Prop<public>(PropID:string, PlayerID:string)<suspends>:vec3_goo=
        Type := GetPropType(PropID)
        if (Type = prop_type.Unknown). ProjectLog("Not found for {ResourceID}.{PropID}@{PlayerID}: {Type} -> Vec3", log_level.Warning)
        State := resource_state{ GameState := GameState, ResourceID := ResourceID }
        PropVM := case(Type):
            prop_type.Vec3 => if (P := Props.Vec3s[PropID]). P else. Vec3Prop(State)
            _ => Vec3Prop(State)
        if. set Props.Vec3s[PropID] = PropVM
        PropVM.ValueFor(PlayerID)

    GetAgentProp<public>(PropID:string, PlayerID:string)<suspends>:agent_goo=
        Type := GetPropType(PropID)
        if (Type = prop_type.Unknown). ProjectLog("Not found for {ResourceID}.{PropID}@{PlayerID}: {Type} -> Agent", log_level.Warning)
        State := resource_state{ GameState := GameState, ResourceID := ResourceID }
        PropVM := case(Type):
            prop_type.Agent => if (P := Props.Agents[PropID]). P else. AgentProp(State)
            _ => AgentProp(State)
        if. set Props.Agents[PropID] = PropVM
        PropVM.ValueFor(PlayerID)

IntProp<constructor>(State:resource_state, Prop:prop_int)<transacts> := int_vm{ State := State, Prop := Prop }
ToIntProp<constructor>(State:resource_state, Prop:prop, Focus:half_path)<transacts> := int_vm:
    State := State
    Prop := prop_int:
        CopyProp<constructor>(Prop)
        FN := "To Int"
        Focus := Focus
IntProp<constructor>(State:resource_state)<transacts> := int_vm. State := State
int_vm<public> := class():
    State<public>:resource_state
    Prop<public>:prop_int = prop_int{}
    var Values<public>:[string]int_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:int_goo =
        if (Value := Values[PlayerID]). return Value

        Scoped := State.ToPlayer(PlayerID)
        Result := case(Prop.FN):
            "+" => IntGoo(CompIntAdd(Prop.Focus, Scoped.ToInt, Prop.Tweak, Scoped.ToInt))
            "To Int" => case(Prop.Type):
                prop_type.Float => IntGoo(MapFloatToInt(Prop.Focus, Scoped.ToFloat))
                _ => IntGoo(Prop.Default)
            _ => IntGoo(Prop.Default)

        if. set Values[PlayerID] = Result
        return Result

NumProp<constructor>(State:resource_state, Prop:prop_num)<transacts> := num_vm{ State := State, Prop := Prop }
ToNumProp<constructor>(State:resource_state, Prop:prop, Focus:half_path)<transacts> := num_vm:
    State := State
    Prop := prop_num:
        CopyProp<constructor>(Prop)
        FN := "To Num"
        Focus := Focus
NumProp<constructor>(State:resource_state)<transacts> := num_vm. State := State
num_vm<public> := class():
    State<public>:resource_state
    Prop<public>:prop_num = prop_num{}
    var Values<public>:[string]num_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:num_goo =
        if (Value := Values[PlayerID]). return Value

        Scoped := State.ToPlayer(PlayerID)
        Result := case(Prop.FN):
            "Multiply" => NumGoo(CompNumMultiply(Prop.Focus, Scoped.ToNum, Prop.Tweak, Scoped.ToNum))
            "Power" => NumGoo(CompNumPower(Prop.Focus, Scoped.ToNum, Prop.Tweak, Scoped.ToFloat))
            "Reverse Power" => NumGoo(CompNumPower(Prop.Tweak, Scoped.ToNum, Prop.Focus, Scoped.ToFloat))
            "To Num" => case(Prop.Type):
                prop_type.Float => NumGoo(MapFloatToNum(Prop.Focus, Scoped.ToFloat))
                prop_type.Integer => NumGoo(MapIntToNum(Prop.Focus, Scoped.ToInt))
                _ => NumGoo(Prop.Default)
            _ => NumGoo(Prop.Default)

        if. set Values[PlayerID] = Result
        return Result

    var Floats<public>:[string]float_goo := map{}
    AsFloat<public>(PlayerID:string)<suspends>:float_goo=
        if (Cached := Floats[PlayerID]). return Cached
        Converted := FloatGoo(MapNumToFloat(ValueFor(PlayerID)))
        if. set Floats[PlayerID] = Converted
        return Converted

BoolProp<constructor>(GameState:game_state, State:resource_state, Prop:prop_bool)<transacts> := bool_vm{ GameState := GameState, State := State, Prop := Prop }
BoolProp<constructor>(GameState:game_state, State:resource_state)<transacts> := bool_vm{ GameState := GameState, State := State }
bool_vm<public> := class():
    GameState<public>:game_state
    State<public>:resource_state
    Prop<public>:prop_bool = prop_bool{}
    var Values<public>:[string]bool_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:bool_goo =
        if (Value := Values[PlayerID]). return Value

        Scoped := State.ToPlayer(PlayerID)
        Result := case(Prop.FN):
            ">=" => BoolGoo(CompGTE(Prop.Focus, Scoped.ToNum, Prop.Tweak, Scoped.ToNum))
            "=" => BoolGoo(CompNumEquals(Prop.Focus, Scoped.ToNum, Prop.Tweak, Scoped.ToNum))
            "AND" => BoolGoo(CompAnd(Prop.Focus, Scoped.ToBool, Prop.Tweak, Scoped.ToBool))
            "OR" => BoolGoo(CompOr(Prop.Focus, Scoped.ToBool, Prop.Tweak, Scoped.ToBool))
            "NOT" => BoolGoo(MapNot(Prop.Focus, Scoped.ToBool))
            "Not Empty" => BoolGoo(MapNotEmpty(Prop.Focus, Scoped.ToStr))
            "Adopt" =>
                Base := Scoped.ToStr(Prop.Focus)
                Finder := finder{ GameState := GameState, Focus := Prop.Tweak, PlayerID := PlayerID }
                BoolGoo(SwitchMap(Base, Finder.FN))
            _ => BoolGoo(Prop.Default)

        if. set Values[PlayerID] = Result
        return Result

finder := class():
    GameState:game_state
    Focus:half_path
    PlayerID:string
    var Cache:[string]bool_goo = map{}

    FN<public>(ResourceID:string):bool_goo=
        if (Cached := Cache[ResourceID+PlayerID]). return Cached
        ExistsVM := GameState.AwaitResourceGoo(ResourceID)
        Result := BoolGoo(SwitchMap(ExistsVM, SwitchDefault))
        if. set Cache[ResourceID+PlayerID] = Result
        Result

    SwitchDefault<public>(ResourceID:string)<suspends>:bool_goo=
        if (ResourceID <> ""). GameState.GetBoolProp(ResourceID, Focus, PlayerID)
        else. BoolGoo(false)

StrProp<constructor>(State:resource_state, Prop:prop_str)<transacts> := str_vm{ State := State, Prop := Prop }
ToStrProp<constructor>(State:resource_state, Prop:prop, Focus:half_path)<transacts> := str_vm:
    State := State
    Prop := prop_str:
        CopyProp<constructor>(Prop)
        FN := "To String"
        Focus := Focus
StrProp<constructor>(State:resource_state)<transacts> := str_vm. State := State
str_vm<public> := class():
    State<public>:resource_state
    Prop<public>:prop_str = prop_str{}
    var Values<public>:[string]string_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:string_goo =
        if (Value := Values[PlayerID]). return Value

        Scoped := State.ToPlayer(PlayerID)
        Result := case(Prop.FN):
            "To String" => case(Prop.Type):
                prop_type.Bool => StrGoo(MapBoolToStr(Prop.Focus, Scoped.ToBool))
                prop_type.Agent => StrGoo(MapAgentToStr(Prop.Focus, Scoped.ToAgent))
                prop_type.Integer => StrGoo(MapIntToStr(Prop.Focus, Scoped.ToInt))
                prop_type.Float => StrGoo(MapFloatToStr(Prop.Focus, Scoped.ToFloat))
                prop_type.Num => StrGoo(MapNumToStr(Prop.Focus, Scoped.ToNum))
                prop_type.Vec2 => StrGoo(MapVec2ToStr(Prop.Focus, Scoped.ToVec2))
                prop_type.Vec3 => StrGoo(MapVec3ToStr(Prop.Focus, Scoped.ToVec3))
                _ => StrGoo(Prop.Default)
            "Append" => StrGoo(CompAppendStrs(Prop.Focus, Scoped.ToStr, Prop.Tweak, Scoped.ToStr))
            _ => StrGoo(Prop.Default)

        if. set Values[PlayerID] = Result
        return Result

Vec2Prop<constructor>(State:resource_state, Prop:prop_vec2)<transacts> := vec2_vm{ State := State, Prop := Prop }
Vec2Prop<constructor>(State:resource_state)<transacts> := vec2_vm. State := State
vec2_vm<public> := class():
    State<public>:resource_state
    Prop<public>:prop_vec2 = prop_vec2{}
    var Values<public>:[string]vec2_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:vec2_goo =
        if (Value := Values[PlayerID]). return Value

        Scoped := State.ToPlayer(PlayerID)
        Result := case(Prop.FN):
            "Append" => Vec2Goo(CompAppendFloats(Prop.Focus, Scoped.ToFloat, Prop.Tweak, Scoped.ToFloat))
            _ => Vec2Goo(Prop.Default)

        if. set Values[PlayerID] = Result
        return Result

Vec3Prop<constructor>(State:resource_state, Prop:prop_vec3)<transacts> := vec3_vm{ State := State, Prop := Prop }
Vec3Prop<constructor>(State:resource_state)<transacts> := vec3_vm. State := State
vec3_vm<public> := class():
    State<public>:resource_state
    Prop<public>:prop_vec3 = prop_vec3{}
    var Values<public>:[string]vec3_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:vec3_goo =
        if (Value := Values[PlayerID]). return Value

        Scoped := State.ToPlayer(PlayerID)
        Result := case(Prop.FN):
            "Append" => Vec3Goo(CompAppendVec2AndFloat(Prop.Focus, Scoped.ToVec2, Prop.Tweak, Scoped.ToFloat))
            _ => Vec3Goo(Prop.Default)

        if. set Values[PlayerID] = Result
        return Result

AgentProp<constructor>(State:resource_state, Prop:prop_agent)<transacts> := agent_vm{ State := State, Prop := Prop }
AgentProp<constructor>(State:resource_state)<transacts> := agent_vm. State := State
agent_vm<public> := class():
    State<public>:resource_state
    Prop<public>:prop_agent = prop_agent{}
    var Values<public>:[string]agent_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:agent_goo =
        if (Value := Values[PlayerID]). return Value

        Scoped := State.ToPlayer(PlayerID)
        Result := case(Prop.FN):
            _ => AgentGoo(Prop.Default)

        if. set Values[PlayerID] = Result
        return Result

FloatProp<constructor>(State:resource_state, Prop:prop_float)<transacts> := float_vm{ State := State, Prop := Prop }
ToFloatProp<constructor>(State:resource_state, Prop:prop, Focus:half_path)<transacts> := float_vm:
    State := State
    Prop := prop_float:
        CopyProp<constructor>(Prop)
        FN := "To Float"
        Focus := Focus
FloatProp<constructor>(State:resource_state)<transacts> := float_vm. State := State
float_vm<public> := class():
    State<public>:resource_state
    Prop<public>:prop_float = prop_float{}
    var Values<public>:[string]float_goo := map{}

    ValueFor<public>(PlayerID:string)<suspends>:float_goo =
        if (Value := Values[PlayerID]). return Value

        Scoped := State.ToPlayer(PlayerID)
        Result := case(Prop.FN):
            "*" => FloatGoo(CompFloatMultiply(Prop.Focus, Scoped.ToFloat, Prop.Tweak, Scoped.ToFloat))
            "To Float" => case(Prop.Type):
                prop_type.Num => FloatGoo(MapNumToFloat(Prop.Focus, Scoped.ToNum))
                prop_type.Integer => FloatGoo(MapIntToFloat(Prop.Focus, Scoped.ToInt))
                _ => FloatGoo(Prop.Default)
            _ => FloatGoo(Prop.Default)

        if. set Values[PlayerID] = Result
        return Result

action_maker<public> := class():
    GameState<public>:game_state
    Subject<public>:string
    Effects<public>:[]effect

    ActionFor<public>(NewTarget:string):action=
        action:
            GameState := GameState
            Subject := Subject
            Target := NewTarget
            Effects := Effects

action<public> := class():
    GameState<public>:game_state
    Subject<public>:string
    Target<public>:string
    Effects<public>:[]effect

    ExecuteEmpty<public>():void= spawn. Run()
    ExecuteAgentFloat<public>(Agent:agent, Float:float):void= spawn. Run()

    Run()<suspends>:void=
        var Iterator:int = 0
        loop:
            if (Effect := Effects[Iterator]):
                if (Effector := GameState.EffectorProvider.Get[Effect.FN]):
                    Focus := GameState.ResolvePath(Subject, Effect.Focus, Target)
                    Tweak := GameState.ResolvePath(Subject, Effect.Tweak, Target)

                    Commands := Effector.Play(Subject, Target, Focus, Tweak)

                    if (not Commands?). break
                    set Iterator += 1
                else:
                    ProjectLog("[{Effect.FN}] not found", log_level.Warning)
                    break
            else. break
