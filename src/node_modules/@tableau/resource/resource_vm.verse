
using. /Verse.org/Simulation
using. /UnrealEngine.com/Temporary/Diagnostics
using. /UnrealEngine.com/Temporary/SpatialMath

using. Goo
using. Numb
using. Tableau
using. Vertex

resource_state<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    ForProperty<public>(PropertyID:string)<transacts>:property_state = property_state:
        ResourceState := Self
        ResourceID := ResourceID
        PropertyID := PropertyID

    GetBoolProp<public>(TargetResourceID:string, HP:half_path, PlayerID:string):bool_goo= GameState.GetBoolProp(TargetResourceID, HP, PlayerID)
    GetIntProp<public>(TargetResourceID:string, HP:half_path, PlayerID:string):int_goo= GameState.GetIntProp(TargetResourceID, HP, PlayerID)
    GetFloatProp<public>(TargetResourceID:string, HP:half_path, PlayerID:string):float_goo= GameState.GetFloatProp(TargetResourceID, HP, PlayerID)
    GetNumProp<public>(TargetResourceID:string, HP:half_path, PlayerID:string):num_goo= GameState.GetNumProp(TargetResourceID, HP, PlayerID)
    GetStrProp<public>(TargetResourceID:string, HP:half_path, PlayerID:string):string_goo= GameState.GetStrProp(TargetResourceID, HP, PlayerID)
    GetAgentProp<public>(TargetResourceID:string, HP:half_path, PlayerID:string):agent_goo= GameState.GetAgentProp(TargetResourceID, HP, PlayerID)
    GetVec2Prop<public>(TargetResourceID:string, HP:half_path, PlayerID:string):vec2_goo= GameState.GetVec2Prop(TargetResourceID, HP, PlayerID)
    GetVec3Prop<public>(TargetResourceID:string, HP:half_path, PlayerID:string):vec3_goo= GameState.GetVec3Prop(TargetResourceID, HP, PlayerID)

property_player_scope<public> := class():
    GameState<public>:game_state
    Source<public>:string
    PropertyID<public>:string
    PlayerID<public>:string

    FindStr<public>(HP:half_path):string_goo= GameState.GetStrProp(Source, HP, PlayerID)
    AwaitBool<public>(ResourceID:string):bool_goo= GameState.GetBoolProp(ResourceID, PropertyID, PlayerID)
    AwaitInt<public>(ResourceID:string):int_goo= GameState.GetIntProp(ResourceID, PropertyID, PlayerID)
    AwaitFloat<public>(ResourceID:string):float_goo= GameState.GetFloatProp(ResourceID, PropertyID, PlayerID)
    AwaitNum<public>(ResourceID:string):num_goo= GameState.GetNumProp(ResourceID, PropertyID, PlayerID)
    AwaitStr<public>(ResourceID:string):string_goo= GameState.GetStrProp(ResourceID, PropertyID, PlayerID)
    AwaitAgent<public>(ResourceID:string):agent_goo= GameState.GetAgentProp(ResourceID, PropertyID, PlayerID)
    AwaitVec2<public>(ResourceID:string):vec2_goo= GameState.GetVec2Prop(ResourceID, PropertyID, PlayerID)
    AwaitVec3<public>(ResourceID:string):vec3_goo= GameState.GetVec3Prop(ResourceID, PropertyID, PlayerID)

property_state<public> := class():
    ResourceState<public>:resource_state
    ResourceID<public>:string
    PropertyID<public>:string

    ForPlayer<public>(PlayerID:string):player_state = player_state:
        ResourceState := ResourceState
        ResourceID := ResourceID
        PropertyID := PropertyID
        PlayerID := PlayerID

player_state<public> := class():
    ResourceState<public>:resource_state
    ResourceID<public>:string
    PropertyID<public>:string
    PlayerID<public>:string

    ToBool<public>(HP:half_path):bool_goo= ResourceState.GetBoolProp(ResourceID, HP, PlayerID)
    ToInt<public>(HP:half_path):int_goo= ResourceState.GetIntProp(ResourceID, HP, PlayerID)
    ToFloat<public>(HP:half_path):float_goo= ResourceState.GetFloatProp(ResourceID, HP, PlayerID)
    ToNum<public>(HP:half_path):num_goo= ResourceState.GetNumProp(ResourceID, HP, PlayerID)
    ToStr<public>(HP:half_path):string_goo= ResourceState.GetStrProp(ResourceID, HP, PlayerID)
    ToAgent<public>(HP:half_path):agent_goo= ResourceState.GetAgentProp(ResourceID, HP, PlayerID)
    ToVec2<public>(HP:half_path):vec2_goo= ResourceState.GetVec2Prop(ResourceID, HP, PlayerID)
    ToVec3<public>(HP:half_path):vec3_goo= ResourceState.GetVec3Prop(ResourceID, HP, PlayerID)

resource_vm<public> := class():
    State<public>:resource_state
    Resource<public>:resource
    var Abilities<public>:[string]action_maker = map{}

    Init<public>():void =
        for (AbilityID->Effects:Resource.Abilities):
            if. set Abilities[AbilityID] = action_maker:
                State := State
                Subject := Resource.ID
                Effects := Effects

    # ValidateProp(PropID:string, Prop:prop):void=
    #     if (Prop.FN <> ""). ProjectLog("{Prop.Type}[{Prop.FN}] does not exist for {Resource.ID}.{PropID}", log_level.Warning)

    GetPropType<public>(PropID:string)<transacts>:prop_type= Resource.Props[PropID].Type or prop_type.Unknown

    GetBool(PropID:string):prop_bool = prop_bool[Resource.Props[PropID]] or PropBool(Resource.ID, PropID, GetPropType(PropID))
    GetBoolProp<public>(PropID:string, PlayerID:string):bool_goo=
        BoolProp(State.ForProperty(PropID), GetBool(PropID)).ValueFor(PlayerID)

    GetFloat(PropID:string):prop_float = prop_float[Resource.Props[PropID]] or PropFloat(Resource.ID, PropID, GetPropType(PropID))
    GetFloatProp<public>(PropID:string, PlayerID:string):float_goo=
        FloatProp(State.ForProperty(PropID), GetFloat(PropID)).ValueFor(PlayerID)

    GetInt(PropID:string):prop_int = prop_int[Resource.Props[PropID]] or PropInt(Resource.ID, PropID, GetPropType(PropID))
    GetIntProp<public>(PropID:string, PlayerID:string):int_goo=
        IntProp(State.ForProperty(PropID), GetInt(PropID)).ValueFor(PlayerID)

    GetNum(PropID:string):prop_num = prop_num[Resource.Props[PropID]] or PropNum(Resource.ID, PropID, GetPropType(PropID))
    GetNumProp<public>(PropID:string, PlayerID:string):num_goo=
        NumProp(State.ForProperty(PropID), GetNum(PropID)).ValueFor(PlayerID)

    GetStr(PropID:string):prop_str = prop_str[Resource.Props[PropID]] or PropStr(Resource.ID, PropID, GetPropType(PropID))
    GetStrProp<public>(PropID:string, PlayerID:string):string_goo=
        StrProp(State.ForProperty(PropID), GetStr(PropID)).ValueFor(PlayerID)

    GetAgent(PropID:string):prop_agent = prop_agent[Resource.Props[PropID]] or PropAgent(Resource.ID, PropID, GetPropType(PropID))
    GetAgentProp<public>(PropID:string, PlayerID:string):agent_goo=
        AgentProp(State.ForProperty(PropID), GetAgent(PropID)).ValueFor(PlayerID)

    GetVec2(PropID:string):prop_vec2 = prop_vec2[Resource.Props[PropID]] or PropVec2(Resource.ID, PropID, GetPropType(PropID))
    GetVec2Prop<public>(PropID:string, PlayerID:string):vec2_goo=
        Vec2Prop(State.ForProperty(PropID), GetVec2(PropID)).ValueFor(PlayerID)

    GetVec3(PropID:string):prop_vec3 = prop_vec3[Resource.Props[PropID]] or PropVec3(Resource.ID, PropID, GetPropType(PropID))
    GetVec3Prop<public>(PropID:string, PlayerID:string):vec3_goo=
        Vec3Prop(State.ForProperty(PropID), GetVec3(PropID)).ValueFor(PlayerID)

PropBool<constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_bool{ Focus := Path(ResourceID, PropertyID), Type := Type }
BoolProp<constructor>(State:property_state, Prop:prop_bool)<transacts> := bool_vm{ State := State, Prop := Prop }
bool_vm<public> := class():
    State<public>:property_state
    Prop<public>:prop_bool = prop_bool{}

    ValueFor<public>(PlayerID:string):bool_goo =
        Scoped := State.ForPlayer(PlayerID)
        Result := case(Prop.FN):
            ">=" => BoolGoo(CompGTE(Prop.Focus, Scoped.ToNum, Prop.Tweak, Scoped.ToNum))
            "=" => BoolGoo(CompNumEquals(Prop.Focus, Scoped.ToNum, Prop.Tweak, Scoped.ToNum))
            "AND" => BoolGoo(CompAnd(Prop.Focus, Scoped.ToBool, Prop.Tweak, Scoped.ToBool))
            "OR" => BoolGoo(CompOr(Prop.Focus, Scoped.ToBool, Prop.Tweak, Scoped.ToBool))
            "NOT" => BoolGoo(MapNot(Prop.Focus, Scoped.ToBool))
            "Not Empty" => BoolGoo(MapNotEmpty(Prop.Focus, Scoped.ToStr))
            _ =>  case(Prop.Type):
                _ => if (not Prop.Focus.Empty[]). Scoped.ToBool(Prop.Focus) else. BoolGoo(Prop.Default)

PropInt<constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_int{ Focus := Path(ResourceID, PropertyID), Type := Type }
IntProp<constructor>(State:property_state, Prop:prop_int)<transacts> := int_vm{ State := State, Prop := Prop }
int_vm<public> := class():
    State<public>:property_state
    Prop<public>:prop_int = prop_int{}

    ValueFor<public>(PlayerID:string):int_goo =
        Scoped := State.ForPlayer(PlayerID)
        Result := case(Prop.FN):
            "+" => IntGoo(CompIntAdd(Prop.Focus, Scoped.ToInt, Prop.Tweak, Scoped.ToInt))
            _ => case(Prop.Type):
                prop_type.Float => IntGoo(MapFloatToInt(Prop.Focus, Scoped.ToFloat))
                _ => if (not Prop.Focus.Empty[]). Scoped.ToInt(Prop.Focus) else. IntGoo(Prop.Default)

PropFloat<constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_float{ Focus := Path(ResourceID, PropertyID), Type := Type }
FloatProp<constructor>(State:property_state, Prop:prop_float)<transacts> := float_vm{ State := State, Prop := Prop }
float_vm<public> := class():
    State<public>:property_state
    Prop<public>:prop_float = prop_float{}

    ValueFor<public>(PlayerID:string):float_goo =
        Scoped := State.ForPlayer(PlayerID)
        Result := case(Prop.FN):
            "*" => FloatGoo(CompFloatMultiply(Prop.Focus, Scoped.ToFloat, Prop.Tweak, Scoped.ToFloat))
            _ => case(Prop.Type):
                prop_type.Num => FloatGoo(MapNumToFloat(Prop.Focus, Scoped.ToNum))
                prop_type.Integer => FloatGoo(MapIntToFloat(Prop.Focus, Scoped.ToInt))
                _ => if (not Prop.Focus.Empty[]). Scoped.ToFloat(Prop.Focus) else. FloatGoo(Prop.Default)

PropNum<constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_num{ Focus := Path(ResourceID, PropertyID), Type := Type }
NumProp<constructor>(State:property_state, Prop:prop_num)<transacts> := num_vm{ State := State, Prop := Prop }
num_vm<public> := class():
    State<public>:property_state
    Prop<public>:prop_num = prop_num{}

    ValueFor<public>(PlayerID:string):num_goo =
        Scoped := State.ForPlayer(PlayerID)
        Result := case(Prop.FN):
            "Multiply" => NumGoo(CompNumMultiply(Prop.Focus, Scoped.ToNum, Prop.Tweak, Scoped.ToNum))
            "Power" => NumGoo(CompNumPower(Prop.Focus, Scoped.ToNum, Prop.Tweak, Scoped.ToFloat))
            "Reverse Power" => NumGoo(CompNumPower(Prop.Tweak, Scoped.ToNum, Prop.Focus, Scoped.ToFloat))
            _ => case(Prop.Type):
                prop_type.Float => NumGoo(MapFloatToNum(Prop.Focus, Scoped.ToFloat))
                prop_type.Integer => NumGoo(MapIntToNum(Prop.Focus, Scoped.ToInt))
                _ => if (not Prop.Focus.Empty[]). Scoped.ToNum(Prop.Focus) else. NumGoo(Prop.Default)

PropStr<constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_str{ Focus := Path(ResourceID, PropertyID), Type := Type }
StrProp<constructor>(State:property_state, Prop:prop_str)<transacts> := str_vm{ State := State, Prop := Prop }
str_vm<public> := class():
    State<public>:property_state
    Prop<public>:prop_str = prop_str{}

    ValueFor<public>(PlayerID:string):string_goo =
        Scoped := State.ForPlayer(PlayerID)
        Result := case(Prop.FN):
            "Append" => StrGoo(CompAppendStrs(Prop.Focus, Scoped.ToStr, Prop.Tweak, Scoped.ToStr))
            _ => case(Prop.Type):
                prop_type.Bool => StrGoo(MapBoolToStr(Prop.Focus, Scoped.ToBool))
                prop_type.Agent => StrGoo(MapAgentToStr(Prop.Focus, Scoped.ToAgent))
                prop_type.Integer => StrGoo(MapIntToStr(Prop.Focus, Scoped.ToInt))
                prop_type.Float => StrGoo(MapFloatToStr(Prop.Focus, Scoped.ToFloat))
                prop_type.Num => StrGoo(MapNumToStr(Prop.Focus, Scoped.ToNum))
                prop_type.Vec2 => StrGoo(MapVec2ToStr(Prop.Focus, Scoped.ToVec2))
                prop_type.Vec3 => StrGoo(MapVec3ToStr(Prop.Focus, Scoped.ToVec3))
                _ => if (not Prop.Focus.Empty[]). Scoped.ToStr(Prop.Focus) else. StrGoo(Prop.Default)

PropAgent<constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_agent{ Focus := Path(ResourceID, PropertyID), Type := Type }
AgentProp<constructor>(State:property_state, Prop:prop_agent)<transacts> := agent_vm{ State := State, Prop := Prop }
agent_vm<public> := class():
    State<public>:property_state
    Prop<public>:prop_agent = prop_agent{}

    ValueFor<public>(PlayerID:string):agent_goo =
        Scoped := State.ForPlayer(PlayerID)
        Result := case(Prop.FN):
            _ => case(Prop.Type):
                _ => if (not Prop.Focus.Empty[]). Scoped.ToAgent(Prop.Focus) else. AgentGoo(Prop.Default)

PropVec2<constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_vec2{ Focus := Path(ResourceID, PropertyID), Type := Type }
Vec2Prop<constructor>(State:property_state, Prop:prop_vec2)<transacts> := vec2_vm{ State := State, Prop := Prop }
vec2_vm<public> := class():
    State<public>:property_state
    Prop<public>:prop_vec2 = prop_vec2{}

    ValueFor<public>(PlayerID:string):vec2_goo =
        Scoped := State.ForPlayer(PlayerID)
        Result := case(Prop.FN):
            "Append" => Vec2Goo(CompAppendFloats(Prop.Focus, Scoped.ToFloat, Prop.Tweak, Scoped.ToFloat))
            _ => case(Prop.Type):
                _ => if (not Prop.Focus.Empty[]). Scoped.ToVec2(Prop.Focus) else. Vec2Goo(Prop.Default)

PropVec3<constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_vec3{ Focus := Path(ResourceID, PropertyID), Type := Type }
Vec3Prop<constructor>(State:property_state, Prop:prop_vec3)<transacts> := vec3_vm{ State := State, Prop := Prop }
vec3_vm<public> := class():
    State<public>:property_state
    Prop<public>:prop_vec3 = prop_vec3{}

    ValueFor<public>(PlayerID:string):vec3_goo =
        Scoped := State.ForPlayer(PlayerID)
        Result := case(Prop.FN):
            "Append" => Vec3Goo(CompAppendVec2AndFloat(Prop.Focus, Scoped.ToVec2, Prop.Tweak, Scoped.ToFloat))
            _ => case(Prop.Type):
                _ => if (not Prop.Focus.Empty[]). Scoped.ToVec3(Prop.Focus) else. Vec3Goo(Prop.Default)

action_maker<public> := class():
    State<public>:resource_state
    Subject<public>:string
    Effects<public>:[]effect

    ActionFor<public>(NewTarget:string):action=
        action:
            State := State
            Subject := Subject
            Target := NewTarget
            Effects := Effects

action<public> := class():
    State<public>:resource_state
    Subject<public>:string
    Target<public>:string
    Effects<public>:[]effect

    ExecuteEmpty<public>():void= spawn. Run()
    ExecuteAgentFloat<public>(Agent:agent, Float:float):void= spawn. Run()

    Run()<suspends>:void=
        var Iterator:int = 0
        loop:
            if (Effect := Effects[Iterator]):
                if (Effector := State.GameState.EffectorProvider.Get[Effect.FN]):
                    Focus := State.GameState.ResolvePath(Subject, Effect.Focus, Target)
                    Tweak := State.GameState.ResolvePath(Subject, Effect.Tweak, Target)

                    Commands := Effector.Play(Subject, Target, Focus, Tweak)

                    if (not Commands?). break
                    set Iterator += 1
                else:
                    ProjectLog("[{Effect.FN}] not found", log_level.Warning)
                    break
            else. break
