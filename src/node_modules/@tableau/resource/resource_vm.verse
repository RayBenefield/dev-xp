
using { Tableau }

stat_props_vm<public> := class():
    var Strs<public>:[string]gooey_string = map{}
    var Nums<public>:[string]gooey_num = map{}
    var Floats<public>:[string]gooey_float = map{}

props_vm<public> := class():
    var Strs<public>:[string]resource_str_property_vm = map{}
    var Nums<public>:[string]resource_num_property_vm = map{}
    var Floats<public>:[string]resource_float_property_vm = map{}

comp_props_vm<public> := class():
    var Nums<public>:[string]resource_comp_num_property_vm = map{}

resource_vm<public> := class():
    GameState<public>:game_state
    ID<public>:string
    var PropTypes<public>:[string]prop_type = map{}
    var StatProps<public>:stat_props_vm = stat_props_vm{}
    var Props<public>:props_vm = props_vm{}
    var CompProps<public>:comp_props_vm = comp_props_vm{}
    var Abilities<public>:[string]action_maker = map{}

    Init<public>(Resource:resource)<suspends>:void =
        for (Property:Resource.StatProps.Strs):
            VM := Property.ToVM()
            if. set StatProps.Strs[Property.ID] = VM
            if. set PropTypes[Property.ID] = prop_type.StatStr
        for (Property:Resource.StatProps.Nums):
            VM := Property.ToVM()
            if. set StatProps.Nums[Property.ID] = VM
            if. set PropTypes[Property.ID] = prop_type.StatNum
        for (Property:Resource.StatProps.Floats):
            VM := Property.ToVM()
            if. set StatProps.Floats[Property.ID] = VM
            if. set PropTypes[Property.ID] = prop_type.StatFloat
        for (Property:Resource.Props.Nums):
            VM := resource_num_property_vm{ Default := Property.Default }
            spawn. VM.Init(Property.ID)
            if. set Props.Nums[Property.ID] = VM
            if. set PropTypes[Property.ID] = prop_type.Num
        for (Property:Resource.Props.Strs):
            VM := resource_str_property_vm{ Default := Property.Default }
            spawn. VM.Init(Property.ID)
            if. set Props.Strs[Property.ID] = VM
            if. set PropTypes[Property.ID] = prop_type.Str
        for (Property:Resource.Props.Floats):
            VM := resource_float_property_vm{ Default := Property.Default }
            spawn. VM.Init(Property.ID)
            if. set Props.Floats[Property.ID] = VM
            if. set PropTypes[Property.ID] = prop_type.Float
        for (Ability:Resource.Abilities):
            if:
                set Abilities[Ability.ID] = action_maker:
                    GameState := GameState
                    Subject := Resource.ID
                    Effects := Ability.Effects
        for (Property:Resource.CompProps.Nums):
            VM := resource_comp_num_property_vm:
                GameState := GameState
                Transformers := Property.Transformers
                ResourceID := Resource.ID
                BaseProp := Property.BaseProp
            if. set CompProps.Nums[Property.ID] = VM
            if. set PropTypes[Property.ID] = prop_type.CompNum

resource_comp_num_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    BaseProp<public>:string
    Transformers<public>:[]transformer
    var Values<public>:[string]gooey_num := map{}

    # TODO: Switch to NumTransformProvider when parametrics support type aliasing
    ValueFor<public>(ParticipantID:string):gooey_num =
        var VM:gooey_num = GameState.GetNumProp(ResourceID, BaseProp, ParticipantID)
        for:
            Data:Transformers
            # Transformer:num_transformer = GameState.NumTransformerProvider.Get[Data.FN]
            Pay := Data.Pay
        do:
            case(Data.FN):
                "Multiply" =>
                    Pipe := GameState.GetNumProp(ResourceID, Pay.Str, ParticipantID)
                    set VM = gooey_num. VM := Computed(VM, Pipe, NumMultiply)
                "Power" =>
                    Pipe:gooey_float = GameState.GetFloatProp(ResourceID, Pay.Str, ParticipantID)
                    set VM = gooey_num. VM := Computed(VM, Pipe, NumPower)
                "Reverse Power" =>
                    Pipe:gooey_num = GameState.GetNumProp(ResourceID, Pay.Str, ParticipantID)
                    AsFloat:gooey_float = gooey_float. VM := Map(VM, ToFloat)
                    set VM = gooey_num. VM := Computed(Pipe, AsFloat, NumPower)
                _ => {}
            # set VM = gooey_num. VM := Computed(VM, Pipe, Transformer.FN)
        return VM

NumMultiply(First:num, Second:num):num = First * Second
NumPower(First:num, Second:float):num = First.Pow(Second)

resource_static_property_vm<public> := class():
    ID<public>:gooey_string := gooey_string{}
    Default<public>:string

    Init<public>(PropertyID:string)<suspends>:void =
        spawn. ID.Init(PropertyID)

resource_num_property_vm<public> := class():
    ID<public>:gooey_string := gooey_string{}
    Default<public>:num
    var Values<public>:[string]gooey_num := map{}

    Init<public>(PropertyID:string)<suspends>:void =
        spawn. ID.Init(PropertyID)

    # TODO: Make transacts when I can get rid of the `Init`
    ValueFor<public>(ParticipantID:string):gooey_num =
        if (Value := Values[ParticipantID]). return Value
        VM := gooey_num{}
        spawn. VM.Init(Default)
        if:
            set Values[ParticipantID] = VM

        return VM

resource_float_property_vm<public> := class():
    ID<public>:gooey_string := gooey_string{}
    Default<public>:float
    var Values<public>:[string]gooey_float := map{}

    Init<public>(PropertyID:string)<suspends>:void =
        spawn. ID.Init(PropertyID)

    # TODO: Make transacts when I can get rid of the `Init`
    ValueFor<public>(ParticipantID:string):gooey_float =
        if (Value := Values[ParticipantID]). return Value
        VM := gooey_float{}
        spawn. VM.Init(Default)
        if:
            set Values[ParticipantID] = VM

        return VM

resource_str_property_vm<public> := class():
    ID<public>:gooey_string := gooey_string{}
    Default<public>:string
    var Values<public>:[string]gooey_string := map{}

    Init<public>(PropertyID:string)<suspends>:void =
        spawn. ID.Init(PropertyID)

    # TODO: Make transacts when I can get rid of the `Init`
    ValueFor<public>(ParticipantID:string):gooey_string =
        if (Value := Values[ParticipantID]). return Value
        VM := gooey_string{}
        spawn. VM.Init(Default)
        if:
            set Values[ParticipantID] = VM

        return VM

action_maker<public> := class():
    GameState<public>:game_state
    Subject<public>:string
    Effects<public>:[]effect

    ActionFor<public>(NewTarget:string):action=
        action:
            GameState := GameState
            Subject := Subject
            Target := NewTarget
            Effects := Effects

action<public> := class():
    GameState<public>:game_state
    Subject<public>:string
    Target<public>:string
    Effects<public>:[]effect

    Execute<public>():void= spawn. Run(load{})
    ExecutePay<public>(Pay:load):void= spawn. Run(Pay)

    Run(Pay:load)<suspends>:void=
        var LastCommandModification:command = command:
            Subject := Subject
            Target := Target
            Pay := Pay
        for (Effect:Effects, Effector := GameState.EffectorProvider.Get[Effect.FN]):
            set LastCommandModification = Effector.Play(LastCommandModification, Effect.Pay)
