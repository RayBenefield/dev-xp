
using. /Verse.org/Simulation

using. Goo
using. Numb
using. Tableau

stat_props_vm<public> := class():
    var Strs<public>:[string]string_goo = map{}
    var Nums<public>:[string]num_goo = map{}
    var Floats<public>:[string]float_goo = map{}
    var Bools<public>:[string]bool_goo = map{}
    var Agents<public>:[string]agent_goo = map{}

props_vm<public> := class():
    var Strs<public>:[string]resource_str_property_vm = map{}
    var Nums<public>:[string]resource_num_property_vm = map{}
    var Floats<public>:[string]resource_float_property_vm = map{}
    var Bools<public>:[string]resource_bool_property_vm = map{}
    var Agents<public>:[string]resource_agent_property_vm = map{}

comp_props_vm<public> := class():
    var Nums<public>:[string]resource_comp_num_property_vm = map{}
    var Bools<public>:[string]resource_comp_bool_property_vm = map{}

resource_vm<public> := class():
    GameState<public>:game_state
    ID<public>:string
    var StatProps<public>:stat_props_vm = stat_props_vm{}
    var Props<public>:props_vm = props_vm{}
    var CompProps<public>:comp_props_vm = comp_props_vm{}
    var Abilities<public>:[string]action_maker = map{}

    Init<public>(Resource:resource)<suspends>:void =
        for (PropID->Prop:Resource.Props.Static):
            case(Prop.GetType()):
                prop_type.Num =>
                    if (Property := prop_num[Prop]):
                        VM := num_goo{}
                        spawn. VM.Init(Property.Default)
                        if. set StatProps.Nums[PropID] = VM
                prop_type.Str =>
                    if (Property := prop_str[Prop]):
                        VM := string_goo{}
                        spawn. VM.Init(Property.Default)
                        if. set StatProps.Strs[PropID] = VM
                prop_type.Float =>
                    if (Property := prop_float[Prop]):
                        VM := float_goo{}
                        spawn. VM.Init(Property.Default)
                        if. set StatProps.Floats[PropID] = VM
                prop_type.Bool =>
                    if (Property := prop_bool[Prop]):
                        VM := bool_goo{}
                        spawn. VM.Init(Property.Default)
                        if. set StatProps.Bools[PropID] = VM
                prop_type.Agent =>
                    if (Property := prop_agent[Prop]):
                        VM := agent_goo{}
                        spawn. VM.Init(Property.Default)
                        if. set StatProps.Agents[PropID] = VM
                _ => {}
        for (PropID->Prop:Resource.Props.Per):
            case(Prop.GetType()):
                prop_type.Num =>
                    if (Property := prop_num[Prop]):
                        VM := resource_num_property_vm{ Default := Property.Default }
                        spawn. VM.Init(PropID)
                        if. set Props.Nums[PropID] = VM
                prop_type.Str =>
                    if (Property := prop_str[Prop]):
                        VM := resource_str_property_vm{ Default := Property.Default }
                        spawn. VM.Init(PropID)
                        if. set Props.Strs[PropID] = VM
                prop_type.Float =>
                    if (Property := prop_float[Prop]):
                        VM := resource_float_property_vm{ Default := Property.Default }
                        spawn. VM.Init(PropID)
                        if. set Props.Floats[PropID] = VM
                prop_type.Bool =>
                    if (Property := prop_bool[Prop]):
                        VM := resource_bool_property_vm{ Default := Property.Default }
                        spawn. VM.Init(PropID)
                        if. set Props.Bools[PropID] = VM
                prop_type.Agent =>
                    if (Property := prop_agent[Prop]):
                        VM := resource_agent_property_vm{ Default := Property.Default }
                        spawn. VM.Init(PropID)
                        if. set Props.Agents[PropID] = VM
                _ => {}
        for (AbilityID->Effects:Resource.Abilities):
            if. set Abilities[AbilityID] = action_maker:
                GameState := GameState
                Subject := Resource.ID
                Effects := Effects
        for (Property:Resource.CompProps.Nums):
            VM := resource_comp_num_property_vm:
                GameState := GameState
                Computer := Property.Computer
                ResourceID := Resource.ID
                BaseProp := Property.BaseProp
            if. set CompProps.Nums[Property.ID] = VM
        for (Property:Resource.CompProps.Bools):
            VM := resource_comp_bool_property_vm:
                GameState := GameState
                Computer := Property.Computer
                ResourceID := Resource.ID
                BaseProp := Property.BaseProp
                BaseResource := Property.BaseResource
            if. set CompProps.Bools[Property.ID] = VM

resource_comp_num_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    BaseProp<public>:string
    Computer<public>:computer
    var Values<public>:[string]num_goo := map{}

    # TODO: Switch to NumTransformProvider when parametrics support type aliasing
    ValueFor<public>(PlayerID:string):num_goo =
        # Check Cache
        if (Value := Values[PlayerID]). return Value

        Pay := Computer.Pay
        # Computer:num_computer = GameState.NumComputerProvider.Get[Computer.FN]
        Result := case(Computer.FN):
            "Multiply" =>
                NewVM := num_goo{}
                Base:num_goo = GameState.GetNumProp(ResourceID, BaseProp, PlayerID)
                Pipe := if (PropPath := Pay.Prop?):
                    VM := GameState.GetNumProp(ResourceID, PropPath, PlayerID)
                    VM
                else. GameState.GetNumProp(ResourceID, Pay.Str, PlayerID)
                # num_goo. VM := Computed(Base, Pipe, NumMultiply)
                spawn. Combine(Base, Pipe, NumMultiply, NewVM)
                NewVM
            "Power" =>
                NewVM := num_goo{}
                Base:num_goo = GameState.GetNumProp(ResourceID, BaseProp, PlayerID)
                Pipe := if (PropPath := Pay.Prop?). GameState.GetFloatProp(ResourceID, PropPath, PlayerID)
                else. GameState.GetFloatProp(ResourceID, Pay.Str, PlayerID)
                # num_goo. VM := Computed(Base, Pipe, NumPower)
                spawn. Combine(Base, Pipe, NumPower, NewVM)
                NewVM
            "Reverse Power" =>
                NewVM := num_goo{}
                Base:float_goo = GameState.GetFloatProp(ResourceID, BaseProp, PlayerID)
                Pipe := if (PropPath := Pay.Prop?). GameState.GetNumProp(ResourceID, PropPath, PlayerID)
                else. GameState.GetNumProp(ResourceID, Pay.Str, PlayerID)
                # num_goo. VM := Computed(Pipe, Base, NumPower)
                spawn. Combine(Pipe, Base, NumPower, NewVM)
                NewVM
            _ => num_goo{}
        # set VM = num_goo. VM := Computed(VM, Pipe, Computer.FN)

        # Store in Cache
        if. set Values[PlayerID] = Result

        return Result

resource_comp_bool_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    BaseProp<public>:string
    BaseResource<public>:string
    Computer<public>:computer
    var Values<public>:[string]bool_goo := map{}

    # TODO: Switch to NumTransformProvider when parametrics support type aliasing
    ValueFor<public>(PlayerID:string):bool_goo =
        # Check Cache
        if (Value := Values[PlayerID]). return Value

        # Computer:num_computer = GameState.NumComputerProvider.Get[Computer.FN]
        Result := case(Computer.FN):
            ">=" =>
                NewVM := bool_goo{}
                Base := GameState.GetNumProp(BaseResource, BaseProp, PlayerID)
                Pipe := if (PropPath := Computer.Pay.Prop?). GameState.GetNumProp(ResourceID, PropPath, PlayerID)
                else if (Computer.Pay.Str <> ""):
                    GameState.GetNumProp(ResourceID, Computer.Pay.Str, PlayerID)
                else:
                    VM := num_goo{}
                    spawn. VM.Init(num. Value := Computer.Pay.Float)
                    VM

                # Workaround for parametric issues...
                spawn. Combine(Base, Pipe, GTE, NewVM)
                NewVM
                # ComputedBool(Base, Pipe, GTE)
            "=" =>
                NewVM := bool_goo{}
                Base := GameState.GetNumProp(BaseResource, BaseProp, PlayerID)
                Pipe := if (PropPath := Computer.Pay.Prop?):
                    GameState.GetNumProp(ResourceID, PropPath, PlayerID)
                else if (Computer.Pay.Str <> ""):
                    GameState.GetNumProp(ResourceID, Computer.Pay.Str, PlayerID)
                else:
                    VM := num_goo{}
                    spawn. VM.Init(num. Value := Computer.Pay.Float)
                    VM

                # Workaround for parametric issues...
                spawn. Combine(Base, Pipe, NumEquals, NewVM)
                NewVM
                # ComputedBool(Base, Pipe, GTE)
            "AND" =>
                NewVM := bool_goo{}
                Base := GameState.GetBoolProp(BaseResource, BaseProp, PlayerID)
                Pipe := if (PropPath := Computer.Pay.Prop?):
                    GameState.GetBoolProp(ResourceID, PropPath, PlayerID)
                else:
                    VM := bool_goo{}
                    spawn. VM.Init(Computer.Pay.Bool)
                    VM

                # Workaround for parametric issues...
                spawn. Combine(Base, Pipe, AndBools, NewVM)
                NewVM
                # ComputedBool(Base, Pipe, GTE)
            "NOT" =>
                NewVM := bool_goo{}
                Base := GameState.GetBoolProp(BaseResource, BaseProp, PlayerID)

                # Workaround for parametric issues...
                spawn. MapTransformer(Base, NotBools, NewVM)
                NewVM
                # ComputedBool(Base, Pipe, GTE)
            _ => bool_goo{}
        # set VM = num_goo. VM := Computed(VM, Pipe, Computer.FN)

        # Store in Cache
        if. set Values[PlayerID] = Result

        return Result

GTE(First:num, Second:num)<transacts>:logic = if (First.GreaterThanOrEqual[Second]). true else. false
NumEquals(First:num, Second:num)<transacts>:logic = if (First.Equals[Second]). true else. false
AndBools(First:logic, Second:logic)<transacts>:logic = if (First = true and Second = true). true else. false
NotBools(Bool:logic)<transacts>:logic = if (Bool?). false else. true

NumMultiply(First:num, Second:num):num = First * Second
NumPower(First:num, Second:float):num = First.Pow(Second)

resource_static_property_vm<public> := class():
    ID<public>:string_goo := string_goo{}
    Default<public>:string

    Init<public>(PropertyID:string)<suspends>:void =
        spawn. ID.Init(PropertyID)

resource_num_property_vm<public> := class():
    ID<public>:string_goo := string_goo{}
    Default<public>:num
    var Values<public>:[string]num_goo := map{}

    Init<public>(PropertyID:string)<suspends>:void =
        spawn. ID.Init(PropertyID)

    # TODO: Make transacts when I can get rid of the `Init`
    ValueFor<public>(PlayerID:string):num_goo =
        if (Value := Values[PlayerID]). return Value
        VM := num_goo{}
        spawn. VM.Init(Default)
        if. set Values[PlayerID] = VM

        return VM

resource_float_property_vm<public> := class():
    ID<public>:string_goo := string_goo{}
    Default<public>:float
    var Values<public>:[string]float_goo := map{}

    Init<public>(PropertyID:string)<suspends>:void =
        spawn. ID.Init(PropertyID)

    # TODO: Make transacts when I can get rid of the `Init`
    ValueFor<public>(PlayerID:string):float_goo =
        if (Value := Values[PlayerID]). return Value
        VM := float_goo{}
        spawn. VM.Init(Default)
        if. set Values[PlayerID] = VM

        return VM

resource_str_property_vm<public> := class():
    ID<public>:string_goo := string_goo{}
    Default<public>:string
    var Values<public>:[string]string_goo := map{}

    Init<public>(PropertyID:string)<suspends>:void =
        spawn. ID.Init(PropertyID)

    # TODO: Make transacts when I can get rid of the `Init`
    ValueFor<public>(PlayerID:string):string_goo =
        if (Value := Values[PlayerID]). return Value
        VM := string_goo{}
        spawn. VM.Init(Default)
        if. set Values[PlayerID] = VM

        return VM

resource_bool_property_vm<public> := class():
    ID<public>:string_goo := string_goo{}
    Default<public>:logic
    var Values<public>:[string]bool_goo := map{}

    Init<public>(PropertyID:string)<suspends>:void =
        spawn. ID.Init(PropertyID)

    # TODO: Make transacts when I can get rid of the `Init`
    ValueFor<public>(PlayerID:string):bool_goo =
        if (Value := Values[PlayerID]). return Value
        VM := bool_goo{}
        spawn. VM.Init(Default)
        if. set Values[PlayerID] = VM

        return VM

resource_agent_property_vm<public> := class():
    ID<public>:string_goo := string_goo{}
    Default<public>:?agent
    var Values<public>:[string]agent_goo := map{}

    Init<public>(PropertyID:string)<suspends>:void =
        spawn. ID.Init(PropertyID)

    # TODO: Make transacts when I can get rid of the `Init`
    ValueFor<public>(PlayerID:string):agent_goo =
        if (Value := Values[PlayerID]). return Value
        VM := agent_goo{}
        spawn. VM.Init(Default)
        if. set Values[PlayerID] = VM

        return VM

action_maker<public> := class():
    GameState<public>:game_state
    Subject<public>:string
    Effects<public>:[]effect

    ActionFor<public>(NewTarget:string):action=
        action:
            GameState := GameState
            Subject := Subject
            Target := NewTarget
            Effects := Effects

action<public> := class():
    GameState<public>:game_state
    Subject<public>:string
    Target<public>:string
    Effects<public>:[]effect

    Execute<public>():void= spawn. Run(load{})
    ExecutePay<public>(Pay:load):void= spawn. Run(Pay)

    Run(Pay:load)<suspends>:void=
        var LastCommandModification:command = command:
            Subject := Subject
            Target := Target
            Pay := Pay
        var Iterator:int = 0
        loop:
            if (Effect := Effects[Iterator]):
                if (Effector := GameState.EffectorProvider.Get[Effect.FN]):
                    Focus := Effect.Focus
                    EffectPay := Pay.Override(Effect.Pay)

                    Commands := Effector.Play(Subject, Target, Focus, EffectPay)

                    if (not Commands?). break

                    for (Command:Commands?). GameState.Commander.Fire(Command)
                    set Iterator += 1
                else:
                    Print("[{Effect.FN}] not found")
                    break
            else. break

(Pay:load).Override<public>(NewPay:load):load = load:
    Prop := if (NewPay.Prop?). NewPay.Prop else. Pay.Prop
    Str := if (NewPay.Str <> ""). NewPay.Str else. Pay.Str
    Num := if (not NewPay.Num.Equals[num{}]). NewPay.Num else. Pay.Num
    Float := if (NewPay.Float <> 0.0). NewPay.Float else. Pay.Float
