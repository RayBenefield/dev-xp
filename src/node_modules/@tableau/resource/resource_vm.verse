
using. /Verse.org/Simulation
using. /UnrealEngine.com/Temporary/Diagnostics
using. /UnrealEngine.com/Temporary/SpatialMath

using. Goo
using. Numb
using. Tableau
using. Vertex

resource_state<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    ForProperty<public>(PropertyID:string)<transacts>:property_state = property_state:
        ResourceState := Self
        ResourceID := ResourceID
        PropertyID := PropertyID

    GetBoolProp<public>(TargetResourceID:string, HP:half_path, PlayerID:string):bool_goo= GameState.GetBoolProp(TargetResourceID, HP, PlayerID)
    GetIntProp<public>(TargetResourceID:string, HP:half_path, PlayerID:string):int_goo= GameState.GetIntProp(TargetResourceID, HP, PlayerID)
    GetFloatProp<public>(TargetResourceID:string, HP:half_path, PlayerID:string):float_goo= GameState.GetFloatProp(TargetResourceID, HP, PlayerID)
    GetNumProp<public>(TargetResourceID:string, HP:half_path, PlayerID:string):num_goo= GameState.GetNumProp(TargetResourceID, HP, PlayerID)
    GetStrProp<public>(TargetResourceID:string, HP:half_path, PlayerID:string):string_goo= GameState.GetStrProp(TargetResourceID, HP, PlayerID)
    GetAgentProp<public>(TargetResourceID:string, HP:half_path, PlayerID:string):agent_goo= GameState.GetAgentProp(TargetResourceID, HP, PlayerID)
    GetVec2Prop<public>(TargetResourceID:string, HP:half_path, PlayerID:string):vec2_goo= GameState.GetVec2Prop(TargetResourceID, HP, PlayerID)
    GetVec3Prop<public>(TargetResourceID:string, HP:half_path, PlayerID:string):vec3_goo= GameState.GetVec3Prop(TargetResourceID, HP, PlayerID)

property_player_scope<public> := class():
    GameState<public>:game_state
    Source<public>:string
    PropertyID<public>:string
    PlayerID<public>:string

    FindStr<public>(HP:half_path):string_goo= GameState.GetStrProp(Source, HP, PlayerID)
    AwaitBool<public>(ResourceID:string):bool_goo= GameState.GetBoolProp(ResourceID, PropertyID, PlayerID)
    AwaitInt<public>(ResourceID:string):int_goo= GameState.GetIntProp(ResourceID, PropertyID, PlayerID)
    AwaitFloat<public>(ResourceID:string):float_goo= GameState.GetFloatProp(ResourceID, PropertyID, PlayerID)
    AwaitNum<public>(ResourceID:string):num_goo= GameState.GetNumProp(ResourceID, PropertyID, PlayerID)
    AwaitStr<public>(ResourceID:string):string_goo= GameState.GetStrProp(ResourceID, PropertyID, PlayerID)
    AwaitAgent<public>(ResourceID:string):agent_goo= GameState.GetAgentProp(ResourceID, PropertyID, PlayerID)
    AwaitVec2<public>(ResourceID:string):vec2_goo= GameState.GetVec2Prop(ResourceID, PropertyID, PlayerID)
    AwaitVec3<public>(ResourceID:string):vec3_goo= GameState.GetVec3Prop(ResourceID, PropertyID, PlayerID)

property_state<public> := class():
    ResourceState<public>:resource_state
    ResourceID<public>:string
    PropertyID<public>:string

    ForPlayer<public>(PlayerID:string):player_state = player_state:
        ResourceState := ResourceState
        ResourceID := ResourceID
        PropertyID := PropertyID
        PlayerID := PlayerID

player_state<public> := class():
    ResourceState<public>:resource_state
    ResourceID<public>:string
    PropertyID<public>:string
    PlayerID<public>:string

    ToBool<public>(HP:half_path):bool_goo= ResourceState.GetBoolProp(ResourceID, HP, PlayerID)
    ToInt<public>(HP:half_path):int_goo= ResourceState.GetIntProp(ResourceID, HP, PlayerID)
    ToFloat<public>(HP:half_path):float_goo= ResourceState.GetFloatProp(ResourceID, HP, PlayerID)
    ToNum<public>(HP:half_path):num_goo= ResourceState.GetNumProp(ResourceID, HP, PlayerID)
    ToStr<public>(HP:half_path):string_goo= ResourceState.GetStrProp(ResourceID, HP, PlayerID)
    ToAgent<public>(HP:half_path):agent_goo= ResourceState.GetAgentProp(ResourceID, HP, PlayerID)
    ToVec2<public>(HP:half_path):vec2_goo= ResourceState.GetVec2Prop(ResourceID, HP, PlayerID)
    ToVec3<public>(HP:half_path):vec3_goo= ResourceState.GetVec3Prop(ResourceID, HP, PlayerID)

props_vm<public> := class():
    var Ints<public>:[string]int_vm = map{}
    var Nums<public>:[string]num_vm = map{}
    var Floats<public>:[string]float_vm = map{}
    var Bools<public>:[string]bool_vm = map{}
    var Strs<public>:[string]str_vm = map{}
    var Vec2s<public>:[string]vec2_vm = map{}
    var Vec3s<public>:[string]vec3_vm = map{}
    var Agents<public>:[string]agent_vm = map{}

resource_vm<public> := class():
    State<public>:resource_state
    ResourceID<public>:string
    var Props<public>:props_vm = props_vm{}
    var Abilities<public>:[string]action_maker = map{}

    var PropTypes<public>:[string]prop_type = map{}
    GetPropType<public>(PropID:string)<transacts>:prop_type= PropTypes[PropID] or prop_type.Unknown

    Init<public>(Resource:resource):void =
        for (PropID->Prop:Resource.Props):
            # ValidateProp(PropID, Prop)
            StoreProp(PropID, Prop)

        for (AbilityID->Effects:Resource.Abilities):
            if. set Abilities[AbilityID] = action_maker:
                State := State
                Subject := ResourceID
                Effects := Effects

    # ValidateProp(PropID:string, Prop:prop):void=
    #     if (Prop.FN <> ""). ProjectLog("{Prop.Type}[{Prop.FN}] does not exist for {ResourceID}.{PropID}", log_level.Warning)

    StoreProp(PropID:string, Prop:prop):void=
        if. set PropTypes[PropID] = Prop.Type
        case(Prop.Type):
            prop_type.Integer => if (P := prop_int[Prop]):
                if. set Props.Ints[PropID] = int_vm{ State := State.ForProperty(PropID), Prop := P }
            prop_type.Num => if (P := prop_num[Prop]):
                if. set Props.Nums[PropID] = num_vm{ State := State.ForProperty(PropID), Prop := P }
            prop_type.Float => if (P := prop_float[Prop]):
                if. set Props.Floats[PropID] = float_vm{ State := State.ForProperty(PropID), Prop := P }
            prop_type.Bool => if (P := prop_bool[Prop]):
                if. set Props.Bools[PropID] = bool_vm{ State := State.ForProperty(PropID), Prop := P }
            prop_type.Str => if (P := prop_str[Prop]):
                if. set Props.Strs[PropID] = StrProp(State.ForProperty(PropID), P)
            prop_type.Vec2 => if (P := prop_vec2[Prop]):
                if. set Props.Vec2s[PropID] = vec2_vm{ State := State.ForProperty(PropID), Prop := P }
            prop_type.Vec3 => if (P := prop_vec3[Prop]):
                if. set Props.Vec3s[PropID] = vec3_vm{ State := State.ForProperty(PropID), Prop := P }
            prop_type.Agent => if (P := prop_agent[Prop]):
                if. set Props.Agents[PropID] = agent_vm{ State := State.ForProperty(PropID), Prop := P }
            _ => {}

    GetProp(PropID:string)<transacts>:prop= case(PropTypes[PropID] or prop_type.Unknown):
        prop_type.Integer => prop[Props.Ints[PropID].Prop] or prop{}
        prop_type.Num => prop[Props.Nums[PropID].Prop] or prop{}
        prop_type.Float => prop[Props.Floats[PropID].Prop] or prop{}
        prop_type.Bool => prop[Props.Bools[PropID].Prop] or prop{}
        prop_type.Str => prop[Props.Strs[PropID].Prop] or prop{}
        prop_type.Vec2 => prop[Props.Vec2s[PropID].Prop] or prop{}
        prop_type.Vec3 => prop[Props.Vec3s[PropID].Prop] or prop{}
        prop_type.Agent => prop[Props.Agents[PropID].Prop] or prop{}
        _ => prop{}

    GetBool(PropID:string):prop_bool = prop_bool[Props.Bools[PropID].Prop] or PropBool(ResourceID, PropID, PropTypes[PropID] or prop_type.Unknown)
    GetBoolProp<public>(PropID:string, PlayerID:string):bool_goo=
        if (PropVM := Props.Bools[PropID]). return PropVM.ValueFor(PlayerID)
        NewVM := BoolProp(State.ForProperty(PropID), GetBool(PropID))
        if. set Props.Bools[PropID] = NewVM
        NewVM.ValueFor(PlayerID)

    GetFloat(PropID:string):prop_float = prop_float[Props.Floats[PropID].Prop] or PropFloat(ResourceID, PropID, PropTypes[PropID] or prop_type.Unknown)
    GetFloatProp<public>(PropID:string, PlayerID:string):float_goo=
        if (PropVM := Props.Floats[PropID]). return PropVM.ValueFor(PlayerID)
        NewVM := FloatProp(State.ForProperty(PropID), GetFloat(PropID))
        if. set Props.Floats[PropID] = NewVM
        NewVM.ValueFor(PlayerID)

    GetInt(PropID:string):prop_int = prop_int[Props.Ints[PropID].Prop] or PropInt(ResourceID, PropID, PropTypes[PropID] or prop_type.Unknown)
    GetIntProp<public>(PropID:string, PlayerID:string):int_goo=
        if (PropVM := Props.Ints[PropID]). return PropVM.ValueFor(PlayerID)
        NewVM := IntProp(State.ForProperty(PropID), GetInt(PropID))
        if. set Props.Ints[PropID] = NewVM
        NewVM.ValueFor(PlayerID)

    GetNum(PropID:string):prop_num = prop_num[Props.Nums[PropID].Prop] or PropNum(ResourceID, PropID, PropTypes[PropID] or prop_type.Unknown)
    GetNumProp<public>(PropID:string, PlayerID:string):num_goo=
        if (PropVM := Props.Nums[PropID]). return PropVM.ValueFor(PlayerID)
        NewVM := NumProp(State.ForProperty(PropID), GetNum(PropID))
        if. set Props.Nums[PropID] = NewVM
        NewVM.ValueFor(PlayerID)

    GetStr(PropID:string):prop_str = prop_str[Props.Strs[PropID].Prop] or PropStr(ResourceID, PropID, PropTypes[PropID] or prop_type.Unknown)
    GetStrProp<public>(PropID:string, PlayerID:string):string_goo=
        if (PropVM := Props.Strs[PropID]). return PropVM.ValueFor(PlayerID)
        NewVM := StrProp(State.ForProperty(PropID), GetStr(PropID))
        if. set Props.Strs[PropID] = NewVM
        NewVM.ValueFor(PlayerID)

    GetAgent(PropID:string):prop_agent = prop_agent[Props.Agents[PropID].Prop] or PropAgent(ResourceID, PropID, PropTypes[PropID] or prop_type.Unknown)
    GetAgentProp<public>(PropID:string, PlayerID:string):agent_goo=
        if (PropVM := Props.Agents[PropID]). return PropVM.ValueFor(PlayerID)
        NewVM := AgentProp(State.ForProperty(PropID), GetAgent(PropID))
        if. set Props.Agents[PropID] = NewVM
        NewVM.ValueFor(PlayerID)

    GetVec2(PropID:string):prop_vec2 = prop_vec2[Props.Vec2s[PropID].Prop] or PropVec2(ResourceID, PropID, PropTypes[PropID] or prop_type.Unknown)
    GetVec2Prop<public>(PropID:string, PlayerID:string):vec2_goo=
        if (PropVM := Props.Vec2s[PropID]). return PropVM.ValueFor(PlayerID)
        NewVM := Vec2Prop(State.ForProperty(PropID), GetVec2(PropID))
        if. set Props.Vec2s[PropID] = NewVM
        NewVM.ValueFor(PlayerID)

    GetVec3(PropID:string):prop_vec3 = prop_vec3[Props.Vec3s[PropID].Prop] or PropVec3(ResourceID, PropID, PropTypes[PropID] or prop_type.Unknown)
    GetVec3Prop<public>(PropID:string, PlayerID:string):vec3_goo=
        if (PropVM := Props.Vec3s[PropID]). return PropVM.ValueFor(PlayerID)
        NewVM := Vec3Prop(State.ForProperty(PropID), GetVec3(PropID))
        if. set Props.Vec3s[PropID] = NewVM
        NewVM.ValueFor(PlayerID)

PropBool<constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_bool{ Focus := Path(ResourceID, PropertyID), Type := Type }
BoolProp<constructor>(State:property_state, Prop:prop_bool)<transacts> := bool_vm{ State := State, Prop := Prop }
bool_vm<public> := class():
    State<public>:property_state
    Prop<public>:prop_bool = prop_bool{}

    ValueFor<public>(PlayerID:string):bool_goo =
        Scoped := State.ForPlayer(PlayerID)
        Result := case(Prop.FN):
            ">=" => BoolGoo(CompGTE(Prop.Focus, Scoped.ToNum, Prop.Tweak, Scoped.ToNum))
            "=" => BoolGoo(CompNumEquals(Prop.Focus, Scoped.ToNum, Prop.Tweak, Scoped.ToNum))
            "AND" => BoolGoo(CompAnd(Prop.Focus, Scoped.ToBool, Prop.Tweak, Scoped.ToBool))
            "OR" => BoolGoo(CompOr(Prop.Focus, Scoped.ToBool, Prop.Tweak, Scoped.ToBool))
            "NOT" => BoolGoo(MapNot(Prop.Focus, Scoped.ToBool))
            "Not Empty" => BoolGoo(MapNotEmpty(Prop.Focus, Scoped.ToStr))
            _ =>  case(Prop.Type):
                _ => if (not Prop.Focus.Empty[]). Scoped.ToBool(Prop.Focus) else. BoolGoo(Prop.Default)

PropInt<constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_int{ Focus := Path(ResourceID, PropertyID), Type := Type }
IntProp<constructor>(State:property_state, Prop:prop_int)<transacts> := int_vm{ State := State, Prop := Prop }
int_vm<public> := class():
    State<public>:property_state
    Prop<public>:prop_int = prop_int{}

    ValueFor<public>(PlayerID:string):int_goo =
        Scoped := State.ForPlayer(PlayerID)
        Result := case(Prop.FN):
            "+" => IntGoo(CompIntAdd(Prop.Focus, Scoped.ToInt, Prop.Tweak, Scoped.ToInt))
            _ => case(Prop.Type):
                prop_type.Float => IntGoo(MapFloatToInt(Prop.Focus, Scoped.ToFloat))
                _ => if (not Prop.Focus.Empty[]). Scoped.ToInt(Prop.Focus) else. IntGoo(Prop.Default)

PropFloat<constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_float{ Focus := Path(ResourceID, PropertyID), Type := Type }
FloatProp<constructor>(State:property_state, Prop:prop_float)<transacts> := float_vm{ State := State, Prop := Prop }
float_vm<public> := class():
    State<public>:property_state
    Prop<public>:prop_float = prop_float{}

    ValueFor<public>(PlayerID:string):float_goo =
        Scoped := State.ForPlayer(PlayerID)
        Result := case(Prop.FN):
            "*" => FloatGoo(CompFloatMultiply(Prop.Focus, Scoped.ToFloat, Prop.Tweak, Scoped.ToFloat))
            _ => case(Prop.Type):
                prop_type.Num => FloatGoo(MapNumToFloat(Prop.Focus, Scoped.ToNum))
                prop_type.Integer => FloatGoo(MapIntToFloat(Prop.Focus, Scoped.ToInt))
                _ => if (not Prop.Focus.Empty[]). Scoped.ToFloat(Prop.Focus) else. FloatGoo(Prop.Default)

PropNum<constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_num{ Focus := Path(ResourceID, PropertyID), Type := Type }
NumProp<constructor>(State:property_state, Prop:prop_num)<transacts> := num_vm{ State := State, Prop := Prop }
num_vm<public> := class():
    State<public>:property_state
    Prop<public>:prop_num = prop_num{}

    ValueFor<public>(PlayerID:string):num_goo =
        Scoped := State.ForPlayer(PlayerID)
        Result := case(Prop.FN):
            "Multiply" => NumGoo(CompNumMultiply(Prop.Focus, Scoped.ToNum, Prop.Tweak, Scoped.ToNum))
            "Power" => NumGoo(CompNumPower(Prop.Focus, Scoped.ToNum, Prop.Tweak, Scoped.ToFloat))
            "Reverse Power" => NumGoo(CompNumPower(Prop.Tweak, Scoped.ToNum, Prop.Focus, Scoped.ToFloat))
            _ => case(Prop.Type):
                prop_type.Float => NumGoo(MapFloatToNum(Prop.Focus, Scoped.ToFloat))
                prop_type.Integer => NumGoo(MapIntToNum(Prop.Focus, Scoped.ToInt))
                _ => if (not Prop.Focus.Empty[]). Scoped.ToNum(Prop.Focus) else. NumGoo(Prop.Default)

PropStr<constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_str{ Focus := Path(ResourceID, PropertyID), Type := Type }
StrProp<constructor>(State:property_state, Prop:prop_str)<transacts> := str_vm{ State := State, Prop := Prop }
str_vm<public> := class():
    State<public>:property_state
    Prop<public>:prop_str = prop_str{}

    ValueFor<public>(PlayerID:string):string_goo =
        Scoped := State.ForPlayer(PlayerID)
        Result := case(Prop.FN):
            "Append" => StrGoo(CompAppendStrs(Prop.Focus, Scoped.ToStr, Prop.Tweak, Scoped.ToStr))
            _ => case(Prop.Type):
                prop_type.Bool => StrGoo(MapBoolToStr(Prop.Focus, Scoped.ToBool))
                prop_type.Agent => StrGoo(MapAgentToStr(Prop.Focus, Scoped.ToAgent))
                prop_type.Integer => StrGoo(MapIntToStr(Prop.Focus, Scoped.ToInt))
                prop_type.Float => StrGoo(MapFloatToStr(Prop.Focus, Scoped.ToFloat))
                prop_type.Num => StrGoo(MapNumToStr(Prop.Focus, Scoped.ToNum))
                prop_type.Vec2 => StrGoo(MapVec2ToStr(Prop.Focus, Scoped.ToVec2))
                prop_type.Vec3 => StrGoo(MapVec3ToStr(Prop.Focus, Scoped.ToVec3))
                _ => if (not Prop.Focus.Empty[]). Scoped.ToStr(Prop.Focus) else. StrGoo(Prop.Default)

PropAgent<constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_agent{ Focus := Path(ResourceID, PropertyID), Type := Type }
AgentProp<constructor>(State:property_state, Prop:prop_agent)<transacts> := agent_vm{ State := State, Prop := Prop }
agent_vm<public> := class():
    State<public>:property_state
    Prop<public>:prop_agent = prop_agent{}

    ValueFor<public>(PlayerID:string):agent_goo =
        Scoped := State.ForPlayer(PlayerID)
        Result := case(Prop.FN):
            _ => case(Prop.Type):
                _ => if (not Prop.Focus.Empty[]). Scoped.ToAgent(Prop.Focus) else. AgentGoo(Prop.Default)

PropVec2<constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_vec2{ Focus := Path(ResourceID, PropertyID), Type := Type }
Vec2Prop<constructor>(State:property_state, Prop:prop_vec2)<transacts> := vec2_vm{ State := State, Prop := Prop }
vec2_vm<public> := class():
    State<public>:property_state
    Prop<public>:prop_vec2 = prop_vec2{}

    ValueFor<public>(PlayerID:string):vec2_goo =
        Scoped := State.ForPlayer(PlayerID)
        Result := case(Prop.FN):
            "Append" => Vec2Goo(CompAppendFloats(Prop.Focus, Scoped.ToFloat, Prop.Tweak, Scoped.ToFloat))
            _ => case(Prop.Type):
                _ => if (not Prop.Focus.Empty[]). Scoped.ToVec2(Prop.Focus) else. Vec2Goo(Prop.Default)

PropVec3<constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_vec3{ Focus := Path(ResourceID, PropertyID), Type := Type }
Vec3Prop<constructor>(State:property_state, Prop:prop_vec3)<transacts> := vec3_vm{ State := State, Prop := Prop }
vec3_vm<public> := class():
    State<public>:property_state
    Prop<public>:prop_vec3 = prop_vec3{}

    ValueFor<public>(PlayerID:string):vec3_goo =
        Scoped := State.ForPlayer(PlayerID)
        Result := case(Prop.FN):
            "Append" => Vec3Goo(CompAppendVec2AndFloat(Prop.Focus, Scoped.ToVec2, Prop.Tweak, Scoped.ToFloat))
            _ => case(Prop.Type):
                _ => if (not Prop.Focus.Empty[]). Scoped.ToVec3(Prop.Focus) else. Vec3Goo(Prop.Default)

action_maker<public> := class():
    State<public>:resource_state
    Subject<public>:string
    Effects<public>:[]effect

    ActionFor<public>(NewTarget:string):action=
        action:
            State := State
            Subject := Subject
            Target := NewTarget
            Effects := Effects

action<public> := class():
    State<public>:resource_state
    Subject<public>:string
    Target<public>:string
    Effects<public>:[]effect

    ExecuteEmpty<public>():void= spawn. Run()
    ExecuteAgentFloat<public>(Agent:agent, Float:float):void= spawn. Run()

    Run()<suspends>:void=
        var Iterator:int = 0
        loop:
            if (Effect := Effects[Iterator]):
                if (Effector := State.GameState.EffectorProvider.Get[Effect.FN]):
                    Focus := State.GameState.ResolvePath(Subject, Effect.Focus, Target)
                    Tweak := State.GameState.ResolvePath(Subject, Effect.Tweak, Target)

                    Commands := Effector.Play(Subject, Target, Focus, Tweak)

                    if (not Commands?). break
                    set Iterator += 1
                else:
                    ProjectLog("[{Effect.FN}] not found", log_level.Warning)
                    break
            else. break
