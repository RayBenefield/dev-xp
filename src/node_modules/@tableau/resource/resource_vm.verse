
using. /Verse.org/Simulation
using. /UnrealEngine.com/Temporary/SpatialMath

using. Goo
using. Numb
using. Tableau

stat_props_vm<public> := class():
    var Strs<public>:[string]string_goo = map{}
    var Nums<public>:[string]num_goo = map{}
    var Floats<public>:[string]float_goo = map{}
    var Bools<public>:[string]bool_goo = map{}
    var Agents<public>:[string]agent_goo = map{}
    var Vec2s<public>:[string]vec2_goo = map{}
    var Vec3s<public>:[string]vec3_goo = map{}

props_vm<public> := class():
    var Strs<public>:[string]resource_str_property_vm = map{}
    var Nums<public>:[string]resource_num_property_vm = map{}
    var Floats<public>:[string]resource_float_property_vm = map{}
    var Bools<public>:[string]resource_bool_property_vm = map{}
    var Agents<public>:[string]resource_agent_property_vm = map{}

comp_props_vm<public> := class():
    var Nums<public>:[string]resource_comp_num_property_vm = map{}
    var Bools<public>:[string]resource_comp_bool_property_vm = map{}
    var Strs<public>:[string]resource_comp_str_property_vm = map{}
    var Vec2s<public>:[string]resource_comp_vec2_property_vm = map{}
    var Vec3s<public>:[string]resource_comp_vec3_property_vm = map{}

resource_vm<public> := class():
    GameState<public>:game_state
    ID<public>:string
    var StatProps<public>:stat_props_vm = stat_props_vm{}
    var Props<public>:props_vm = props_vm{}
    var CompProps<public>:comp_props_vm = comp_props_vm{}
    var Abilities<public>:[string]action_maker = map{}

    Init<public>(Resource:resource)<suspends>:void =
        for (PropID->Prop:Resource.Props.Static):
            case(Prop.GetType()):
                prop_type.Num =>
                    if (Property := prop_num[Prop]):
                        VM := NumGoo(Property.Default)
                        if. set StatProps.Nums[PropID] = VM
                prop_type.Str =>
                    if (Property := prop_str[Prop]):
                        VM := StrGoo(Property.Default)
                        if. set StatProps.Strs[PropID] = VM
                prop_type.Float =>
                    if (Property := prop_float[Prop]):
                        VM := FloatGoo(Property.Default)
                        if. set StatProps.Floats[PropID] = VM
                prop_type.Bool =>
                    if (Property := prop_bool[Prop]):
                        VM := BoolGoo(Property.Default)
                        if. set StatProps.Bools[PropID] = VM
                prop_type.Vec2 =>
                    if (Property := prop_vec2[Prop]):
                        VM := Vec2Goo(Property.Default)
                        if. set StatProps.Vec2s[PropID] = VM
                prop_type.Vec3 =>
                    if (Property := prop_vec3[Prop]):
                        VM := Vec3Goo(Property.Default)
                        if. set StatProps.Vec3s[PropID] = VM
                prop_type.Agent =>
                    if (Property := prop_agent[Prop]):
                        VM := AgentGoo(Property.Default)
                        if. set StatProps.Agents[PropID] = VM
                _ => {}
        for (PropID->Prop:Resource.Props.Per):
            case(Prop.GetType()):
                prop_type.Num =>
                    if (Property := prop_num[Prop]):
                        if. set Props.Nums[PropID] = resource_num_property_vm{ Default := Property.Default }
                prop_type.Str =>
                    if (Property := prop_str[Prop]):
                        if. set Props.Strs[PropID] = resource_str_property_vm{ Default := Property.Default }
                prop_type.Float =>
                    if (Property := prop_float[Prop]):
                        if. set Props.Floats[PropID] = resource_float_property_vm{ Default := Property.Default }
                prop_type.Bool =>
                    if (Property := prop_bool[Prop]):
                        if. set Props.Bools[PropID] = resource_bool_property_vm{ Default := Property.Default }
                prop_type.Agent =>
                    if (Property := prop_agent[Prop]):
                        if. set Props.Agents[PropID] = resource_agent_property_vm{ Default := Property.Default }
                _ => {}
        for (PropID->Prop:Resource.Props.Computed):
            case(Prop.GetType()):
                prop_type.Num =>
                    if (Property := comp_num[Prop]):
                        VM := resource_comp_num_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            Focus := Property.Focus
                            FN := Property.FN
                            Pay := Property.Pay
                        if. set CompProps.Nums[PropID] = VM
                prop_type.Bool =>
                    if (Property := comp_bool[Prop]):
                        VM := resource_comp_bool_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            Focus := Property.Focus
                            FN := Property.FN
                            Pay := Property.Pay
                        if. set CompProps.Bools[PropID] = VM
                prop_type.Str =>
                    if (Property := comp_str[Prop]):
                        VM := resource_comp_str_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            Focus := Property.Focus
                            FN := Property.FN
                            Pay := Property.Pay
                        if. set CompProps.Strs[PropID] = VM
                prop_type.Vec2 =>
                    if (Property := comp_vec2[Prop]):
                        VM := resource_comp_vec2_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            Focus := Property.Focus
                            FN := Property.FN
                            Pay := Property.Pay
                        if. set CompProps.Vec2s[PropID] = VM
                prop_type.Vec3 =>
                    if (Property := comp_vec3[Prop]):
                        VM := resource_comp_vec3_property_vm:
                            GameState := GameState
                            ResourceID := Resource.ID
                            Focus := Property.Focus
                            FN := Property.FN
                            Pay := Property.Pay
                        if. set CompProps.Vec3s[PropID] = VM
                _ => {}
        for (AbilityID->Effects:Resource.Abilities):
            if. set Abilities[AbilityID] = action_maker:
                GameState := GameState
                Subject := Resource.ID
                Effects := Effects

resource_comp_num_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Pay<public>:load
    var Values<public>:[string]num_goo := map{}

    ValueFor<public>(PlayerID:string):num_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            "Multiply" =>
                NewVM := num_goo{}
                Base:num_goo = GameState.GetNumProp(ResourceID, Focus, PlayerID)
                Pipe := if (P := Pay.HalfPath?). GameState.GetNumProp(ResourceID, P, PlayerID)
                else. GameState.GetNumProp(ResourceID, Pay.Str, PlayerID)
                spawn. Combine(Base, Pipe, NumMultiply, NewVM)
                NewVM
            "Power" =>
                NewVM := num_goo{}
                Base := GameState.GetNumProp(ResourceID, Focus, PlayerID)
                Pipe := if (P := Pay.HalfPath?). GameState.GetFloatProp(ResourceID, P, PlayerID)
                else. GameState.GetFloatProp(ResourceID, Pay.Str, PlayerID)
                spawn. Combine(Base, Pipe, NumPower, NewVM)
                NewVM
            "Reverse Power" =>
                NewVM := num_goo{}
                Base := GameState.GetFloatProp(ResourceID, Focus, PlayerID)
                Pipe := if (P := Pay.HalfPath?). GameState.GetNumProp(ResourceID, P, PlayerID)
                else. GameState.GetNumProp(ResourceID, Pay.Str, PlayerID)
                spawn. Combine(Pipe, Base, NumPower, NewVM)
                NewVM
            _ => NumGoo()

        if. set Values[PlayerID] = Result
        return Result

resource_comp_bool_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Pay<public>:load
    var Values<public>:[string]bool_goo := map{}

    ValueFor<public>(PlayerID:string):bool_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            ">=" =>
                NewVM := bool_goo{}
                Base := GameState.GetNumProp(ResourceID, Focus, PlayerID)
                Pipe := if (P := Pay.HalfPath?). GameState.GetNumProp(ResourceID, P, PlayerID)
                else if (Pay.Str <> ""). GameState.GetNumProp(ResourceID, Pay.Str, PlayerID)
                else. NumGoo(Pay.Float)

                # Workaround for parametric issues...
                spawn. Combine(Base, Pipe, GTE, NewVM)
                NewVM
                # ComputedBool(Base, Pipe, GTE)
            "=" =>
                NewVM := bool_goo{}
                Base := GameState.GetNumProp(ResourceID, Focus, PlayerID)
                Pipe := if (P := Pay.HalfPath?). GameState.GetNumProp(ResourceID, P, PlayerID)
                else if (Pay.Str <> ""). GameState.GetNumProp(ResourceID, Pay.Str, PlayerID)
                else. NumGoo(Pay.Float)

                spawn. Combine(Base, Pipe, NumEquals, NewVM)
                NewVM
            "AND" =>
                NewVM := bool_goo{}
                Base := GameState.GetBoolProp(ResourceID, Focus, PlayerID)
                Pipe := if (P := Pay.HalfPath?). GameState.GetBoolProp(ResourceID, P, PlayerID)
                else. BoolGoo(Pay.Bool)

                spawn. Combine(Base, Pipe, AndBools, NewVM)
                NewVM
            "NOT" =>
                NewVM := bool_goo{}
                Base := GameState.GetBoolProp(ResourceID, Focus, PlayerID)

                spawn. MapTransformer(Base, NotBools, NewVM)
                NewVM
            "Not Empty" =>
                NewVM := bool_goo{}
                Base := GameState.GetStrProp(ResourceID, Focus, PlayerID)

                spawn. MapTransformer(Base, NotEmpty, NewVM)
                NewVM
            "Adopt" =>
                NewVM := bool_goo{}
                Base := GameState.GetStrProp(ResourceID, Focus, PlayerID)
                Prop := if (P := Pay.HalfPath?). P else. Path(ResourceID, Pay.Str)
                Finder := finder{ GameState := GameState, Focus := Prop, PlayerID := PlayerID }
                spawn. Switcher(Base, Finder.FN, NewVM)
                NewVM
            _ => BoolGoo(false)

        if. set Values[PlayerID] = Result
        return Result

finder := class():
    GameState:game_state
    Focus:half_path
    PlayerID:string
    var ID:string = ""

    FN<public>(ResourceID:string):bool_goo=
        set ID = ResourceID
        ExistsVM := GameState.AwaitResourceGoo(ResourceID)
        BoolGoo(SwitchMap(ExistsVM, SwitchDefault))

    SwitchDefault<public>(ResourceExists:logic):bool_goo=
        if (ResourceExists?):
            GameState.GetBoolProp(ID, Focus, PlayerID)
        else. BoolGoo(false)

GTE(First:num, Second:num)<transacts>:logic = if (First.GreaterThanOrEqual[Second]). true else. false
NumEquals(First:num, Second:num)<transacts>:logic = if (First.Equals[Second]). true else. false
AndBools(First:logic, Second:logic)<transacts>:logic = if (First = true and Second = true). true else. false
NotBools(Bool:logic)<transacts>:logic = if (Bool?). false else. true
NotEmpty(Str:string)<transacts>:logic = if (Str <> ""). true else. false

NumMultiply(First:num, Second:num):num = First * Second
NumPower(First:num, Second:float):num = First.Pow(Second)

resource_comp_str_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Pay<public>:load
    var Values<public>:[string]string_goo := map{}

    ValueFor<public>(PlayerID:string):string_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            "To String" =>
                NewVM := string_goo{}
                PropType := GameState.GetPropType(ResourceID, Focus, PlayerID)
                case(PropType):
                    prop_type.Num =>
                        Base := GameState.GetNumProp(ResourceID, Focus, PlayerID)
                        spawn. MapTransformer(Base, NumToString, NewVM)
                    prop_type.StatNum =>
                        Base := GameState.GetNumProp(ResourceID, Focus, PlayerID)
                        spawn. MapTransformer(Base, NumToString, NewVM)
                    prop_type.CompNum =>
                        Base := GameState.GetNumProp(ResourceID, Focus, PlayerID)
                        spawn. MapTransformer(Base, NumToString, NewVM)
                    prop_type.Vec2 =>
                        Base := GameState.GetVec2Prop(ResourceID, Focus, PlayerID)
                        spawn. MapTransformer(Base, Vec2ToString, NewVM)
                    prop_type.CompVec2 =>
                        Base := GameState.GetVec2Prop(ResourceID, Focus, PlayerID)
                        spawn. MapTransformer(Base, Vec2ToString, NewVM)
                    prop_type.Vec3 =>
                        Base := GameState.GetVec3Prop(ResourceID, Focus, PlayerID)
                        spawn. MapTransformer(Base, Vec3ToString, NewVM)
                    prop_type.CompVec3 =>
                        Base := GameState.GetVec3Prop(ResourceID, Focus, PlayerID)
                        spawn. MapTransformer(Base, Vec3ToString, NewVM)
                    _ => StrGoo("")
                NewVM
            _ => StrGoo("")

        if. set Values[PlayerID] = Result
        return Result

NumToString(Num:num):string = "{Num}"
Vec2ToString(Vec2:vector2):string = "{Vec2}"
Vec3ToString(Vec3:vector3):string = "{Vec3}"

resource_comp_vec2_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Pay<public>:load
    var Values<public>:[string]vec2_goo := map{}

    ValueFor<public>(PlayerID:string):vec2_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            "Append" =>
                NewVM := vec2_goo{}
                Base:float_goo = GameState.GetFloatProp(ResourceID, Focus, PlayerID)
                Pipe:float_goo = if (HalfPath := Pay.HalfPath?). GameState.GetFloatProp(ResourceID, HalfPath, PlayerID)
                else. FloatGoo()
                spawn. Combine(Base, Pipe, AppendFloats, NewVM)
                NewVM
            _ => Vec2Goo()

        if. set Values[PlayerID] = Result
        return Result

AppendFloats(X:float, Y:float):vector2 = vector2{ X := X, Y := Y }

resource_comp_vec3_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    Focus<public>:half_path
    FN<public>:string
    Pay<public>:load
    var Values<public>:[string]vec3_goo := map{}

    ValueFor<public>(PlayerID:string):vec3_goo =
        if (Value := Values[PlayerID]). return Value

        Result := case(FN):
            "Append" =>
                NewVM := vec3_goo{}
                Base:vec2_goo = GameState.GetVec2Prop(ResourceID, Focus, PlayerID)
                Pipe:float_goo = if (HalfPath := Pay.HalfPath?). GameState.GetFloatProp(ResourceID, HalfPath, PlayerID)
                else. FloatGoo(Pay.Float)
                spawn. Combine(Base, Pipe, AppendVec2AndFloat, NewVM)
                NewVM
            _ => Vec3Goo()

        if. set Values[PlayerID] = Result
        return Result

AppendVec2AndFloat(Vec2:vector2, Z:float):vector3 = vector3{ X := Vec2.X, Y := Vec2.Y, Z := Z }

resource_num_property_vm<public> := class():
    Default<public>:num
    var Values<public>:[string]num_goo := map{}

    ValueFor<public>(PlayerID:string):num_goo =
        if (Value := Values[PlayerID]). return Value
        VM := NumGoo(Default)
        if. set Values[PlayerID] = VM
        return VM

resource_float_property_vm<public> := class():
    Default<public>:float
    var Values<public>:[string]float_goo := map{}

    ValueFor<public>(PlayerID:string):float_goo =
        if (Value := Values[PlayerID]). return Value
        VM := FloatGoo(Default)
        if. set Values[PlayerID] = VM
        return VM

resource_str_property_vm<public> := class():
    Default<public>:string
    var Values<public>:[string]string_goo := map{}

    ValueFor<public>(PlayerID:string):string_goo =
        if (Value := Values[PlayerID]). return Value
        VM := StrGoo(Default)
        if. set Values[PlayerID] = VM
        return VM

resource_bool_property_vm<public> := class():
    Default<public>:logic
    var Values<public>:[string]bool_goo := map{}

    ValueFor<public>(PlayerID:string):bool_goo =
        if (Value := Values[PlayerID]). return Value
        VM := BoolGoo(Default)
        if. set Values[PlayerID] = VM
        return VM

resource_agent_property_vm<public> := class():
    Default<public>:?agent
    var Values<public>:[string]agent_goo := map{}

    ValueFor<public>(PlayerID:string):agent_goo =
        if (Value := Values[PlayerID]). return Value
        VM := AgentGoo(Default)
        if. set Values[PlayerID] = VM
        return VM

action_maker<public> := class():
    GameState<public>:game_state
    Subject<public>:string
    Effects<public>:[]effect

    ActionFor<public>(NewTarget:string):action=
        action:
            GameState := GameState
            Subject := Subject
            Target := NewTarget
            Effects := Effects

action<public> := class():
    GameState<public>:game_state
    Subject<public>:string
    Target<public>:string
    Effects<public>:[]effect

    Execute<public>():void= spawn. Run(load{})
    ExecutePay<public>(Pay:load):void= spawn. Run(Pay)
    ExecuteAgentFloat<public>(Agent:agent, Float:float):void= spawn. Run(load{})

    Run(Pay:load)<suspends>:void=
        var Iterator:int = 0
        loop:
            if (Effect := Effects[Iterator]):
                if (Effector := GameState.EffectorProvider.Get[Effect.FN]):
                    Focus := GameState.ResolvePath(Subject, Effect.Focus, Target)
                    EffectPay := Pay.Override(Effect.Pay)

                    Commands := Effector.Play(Subject, Target, Focus, EffectPay)

                    if (not Commands?). break

                    for (Command:Commands?). GameState.Commander.Fire(Command)
                    set Iterator += 1
                else:
                    Print("[{Effect.FN}] not found")
                    break
            else. break

(Pay:load).Override<public>(NewPay:load):load = load:
    HalfPath := if (NewPay.HalfPath?). NewPay.HalfPath else. Pay.HalfPath
    Prop := if (NewPay.Prop.PropertyID <> ""). NewPay.Prop else. Pay.Prop
    Str := if (NewPay.Str <> ""). NewPay.Str else. Pay.Str
    Num := if (not NewPay.Num.Equals[num{}]). NewPay.Num else. Pay.Num
    Float := if (NewPay.Float <> 0.0). NewPay.Float else. Pay.Float
