
using { /Verse.org/Simulation }

using { Tableau }

stat_props_vm<public> := class():
    var Strs<public>:[string]gooey_string = map{}
    var Nums<public>:[string]gooey_num = map{}
    var Floats<public>:[string]gooey_float = map{}
    var Bools<public>:[string]gooey_bool = map{}
    var Agents<public>:[string]gooey_agent = map{}

props_vm<public> := class():
    var Strs<public>:[string]resource_str_property_vm = map{}
    var Nums<public>:[string]resource_num_property_vm = map{}
    var Floats<public>:[string]resource_float_property_vm = map{}
    var Bools<public>:[string]resource_bool_property_vm = map{}
    var Agents<public>:[string]resource_agent_property_vm = map{}

comp_props_vm<public> := class():
    var Nums<public>:[string]resource_comp_num_property_vm = map{}
    var Bools<public>:[string]resource_comp_bool_property_vm = map{}

resource_vm<public> := class():
    GameState<public>:game_state
    ID<public>:string
    var StatProps<public>:stat_props_vm = stat_props_vm{}
    var Props<public>:props_vm = props_vm{}
    var CompProps<public>:comp_props_vm = comp_props_vm{}
    var Abilities<public>:[string]action_maker = map{}

    Init<public>(Resource:resource)<suspends>:void =
        for (Property:Resource.StatProps.Strs):
            VM := gooey_string{}
            spawn. VM.Init(Property.Default)
            if. set StatProps.Strs[Property.ID] = VM
        for (Property:Resource.StatProps.Agents):
            VM := gooey_agent{}
            spawn. VM.Init(Property.Default)
            if. set StatProps.Agents[Property.ID] = VM
        for (Property:Resource.StatProps.Nums):
            VM := gooey_num{}
            spawn. VM.Init(Property.Default)
            if. set StatProps.Nums[Property.ID] = VM
        for (Property:Resource.StatProps.Floats):
            VM := gooey_float{}
            spawn. VM.Init(Property.Default)
            if. set StatProps.Floats[Property.ID] = VM
        for (Property:Resource.Props.Nums):
            VM := resource_num_property_vm{ Default := Property.Default }
            spawn. VM.Init(Property.ID)
            if. set Props.Nums[Property.ID] = VM
        for (Property:Resource.Props.Strs):
            VM := resource_str_property_vm{ Default := Property.Default }
            spawn. VM.Init(Property.ID)
            if. set Props.Strs[Property.ID] = VM
        for (Property:Resource.Props.Floats):
            VM := resource_float_property_vm{ Default := Property.Default }
            spawn. VM.Init(Property.ID)
            if. set Props.Floats[Property.ID] = VM
        for (Property:Resource.Props.Bools):
            VM := resource_bool_property_vm{ Default := Property.Default }
            spawn. VM.Init(Property.ID)
            if. set Props.Bools[Property.ID] = VM
        for (Property:Resource.Props.Agents):
            VM := resource_agent_property_vm{ Default := Property.Default }
            spawn. VM.Init(Property.ID)
            if. set Props.Agents[Property.ID] = VM
        for (Ability:Resource.Abilities):
            if:
                set Abilities[Ability.ID] = action_maker:
                    GameState := GameState
                    Subject := Resource.ID
                    Effects := Ability.Effects
        for (Property:Resource.CompProps.Nums):
            VM := resource_comp_num_property_vm:
                GameState := GameState
                Computer := Property.Computer
                ResourceID := Resource.ID
                BaseProp := Property.BaseProp
            if. set CompProps.Nums[Property.ID] = VM
        for (Property:Resource.CompProps.Bools):
            VM := resource_comp_bool_property_vm:
                GameState := GameState
                Computer := Property.Computer
                ResourceID := Resource.ID
                BaseProp := Property.BaseProp
                BaseResource := Property.BaseResource
            if. set CompProps.Bools[Property.ID] = VM

resource_comp_num_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    BaseProp<public>:string
    Computer<public>:computer
    var Values<public>:[string]gooey_num := map{}

    # TODO: Switch to NumTransformProvider when parametrics support type aliasing
    ValueFor<public>(ParticipantID:string):gooey_num =
        # Check Cache
        if (Value := Values[ParticipantID]). return Value

        Pay := Computer.Pay
        # Computer:num_computer = GameState.NumComputerProvider.Get[Computer.FN]
        Result := case(Computer.FN):
            "Multiply" =>
                NewVM := gooey_num{}
                Base:gooey_num = GameState.GetNumProp(ResourceID, BaseProp, ParticipantID)
                Pipe := if (PropPath := Pay.Prop?):
                    VM := GameState.GetNumProp(ResourceID, PropPath, ParticipantID)
                    VM
                else. GameState.GetNumProp(ResourceID, Pay.Str, ParticipantID)
                # gooey_num. VM := Computed(Base, Pipe, NumMultiply)
                spawn. Combine(Base, Pipe, NumMultiply, NewVM)
                NewVM
            "Power" =>
                NewVM := gooey_num{}
                Base:gooey_num = GameState.GetNumProp(ResourceID, BaseProp, ParticipantID)
                Pipe := if (PropPath := Pay.Prop?). GameState.GetFloatProp(ResourceID, PropPath, ParticipantID)
                else. GameState.GetFloatProp(ResourceID, Pay.Str, ParticipantID)
                # gooey_num. VM := Computed(Base, Pipe, NumPower)
                spawn. Combine(Base, Pipe, NumPower, NewVM)
                NewVM
            "Reverse Power" =>
                NewVM := gooey_num{}
                Base:gooey_float = GameState.GetFloatProp(ResourceID, BaseProp, ParticipantID)
                Pipe := if (PropPath := Pay.Prop?). GameState.GetNumProp(ResourceID, PropPath, ParticipantID)
                else. GameState.GetNumProp(ResourceID, Pay.Str, ParticipantID)
                # gooey_num. VM := Computed(Pipe, Base, NumPower)
                spawn. Combine(Pipe, Base, NumPower, NewVM)
                NewVM
            _ => gooey_num{}
        # set VM = gooey_num. VM := Computed(VM, Pipe, Computer.FN)

        # Store in Cache
        if. set Values[ParticipantID] = Result

        return Result

resource_comp_bool_property_vm<public> := class():
    GameState<public>:game_state
    ResourceID<public>:string
    BaseProp<public>:string
    BaseResource<public>:string
    Computer<public>:computer
    var Values<public>:[string]gooey_bool := map{}

    # TODO: Switch to NumTransformProvider when parametrics support type aliasing
    ValueFor<public>(ParticipantID:string):gooey_bool =
        # Check Cache
        if (Value := Values[ParticipantID]). return Value

        # Computer:num_computer = GameState.NumComputerProvider.Get[Computer.FN]
        Result := case(Computer.FN):
            ">=" =>
                NewVM := gooey_bool{}
                Base := GameState.GetNumProp(BaseResource, BaseProp, ParticipantID)
                Pipe := if (PropPath := Computer.Pay.Prop?). GameState.GetNumProp(ResourceID, PropPath, ParticipantID)
                else if (Computer.Pay.Str <> ""):
                    GameState.GetNumProp(ResourceID, Computer.Pay.Str, ParticipantID)
                else:
                    VM := gooey_num{}
                    spawn. VM.Init(num. Value := Computer.Pay.Float)
                    VM

                # Workaround for parametric issues...
                spawn. Combine(Base, Pipe, GTE, NewVM)
                NewVM
                # ComputedBool(Base, Pipe, GTE)
            "=" =>
                NewVM := gooey_bool{}
                Base := GameState.GetNumProp(BaseResource, BaseProp, ParticipantID)
                Pipe := if (PropPath := Computer.Pay.Prop?):
                    GameState.GetNumProp(ResourceID, PropPath, ParticipantID)
                else if (Computer.Pay.Str <> ""):
                    GameState.GetNumProp(ResourceID, Computer.Pay.Str, ParticipantID)
                else:
                    VM := gooey_num{}
                    spawn. VM.Init(num. Value := Computer.Pay.Float)
                    VM

                # Workaround for parametric issues...
                spawn. Combine(Base, Pipe, NumEquals, NewVM)
                NewVM
                # ComputedBool(Base, Pipe, GTE)
            "AND" =>
                NewVM := gooey_bool{}
                Base := GameState.GetBoolProp(BaseResource, BaseProp, ParticipantID)
                Pipe := if (PropPath := Computer.Pay.Prop?):
                    GameState.GetBoolProp(ResourceID, PropPath, ParticipantID)
                else:
                    VM := gooey_bool{}
                    spawn. VM.Init(Computer.Pay.Bool)
                    VM

                # Workaround for parametric issues...
                spawn. Combine(Base, Pipe, AndBools, NewVM)
                NewVM
                # ComputedBool(Base, Pipe, GTE)
            "NOT" =>
                NewVM := gooey_bool{}
                Base := GameState.GetBoolProp(BaseResource, BaseProp, ParticipantID)

                # Workaround for parametric issues...
                spawn. MapTransformer(Base, NotBools, NewVM)
                NewVM
                # ComputedBool(Base, Pipe, GTE)
            _ => gooey_bool{}
        # set VM = gooey_num. VM := Computed(VM, Pipe, Computer.FN)

        # Store in Cache
        if. set Values[ParticipantID] = Result

        return Result

GTE(First:num, Second:num)<transacts>:logic = if (First.GreaterThanOrEqual[Second]). true else. false
NumEquals(First:num, Second:num)<transacts>:logic = if (First.Equals[Second]). true else. false
AndBools(First:logic, Second:logic)<transacts>:logic = if (First = true and Second = true). true else. false
NotBools(Bool:logic)<transacts>:logic = if (Bool?). false else. true

NumMultiply(First:num, Second:num):num = First * Second
NumPower(First:num, Second:float):num = First.Pow(Second)

resource_static_property_vm<public> := class():
    ID<public>:gooey_string := gooey_string{}
    Default<public>:string

    Init<public>(PropertyID:string)<suspends>:void =
        spawn. ID.Init(PropertyID)

resource_num_property_vm<public> := class():
    ID<public>:gooey_string := gooey_string{}
    Default<public>:num
    var Values<public>:[string]gooey_num := map{}

    Init<public>(PropertyID:string)<suspends>:void =
        spawn. ID.Init(PropertyID)

    # TODO: Make transacts when I can get rid of the `Init`
    ValueFor<public>(ParticipantID:string):gooey_num =
        if (Value := Values[ParticipantID]). return Value
        VM := gooey_num{}
        spawn. VM.Init(Default)
        if. set Values[ParticipantID] = VM

        return VM

resource_float_property_vm<public> := class():
    ID<public>:gooey_string := gooey_string{}
    Default<public>:float
    var Values<public>:[string]gooey_float := map{}

    Init<public>(PropertyID:string)<suspends>:void =
        spawn. ID.Init(PropertyID)

    # TODO: Make transacts when I can get rid of the `Init`
    ValueFor<public>(ParticipantID:string):gooey_float =
        if (Value := Values[ParticipantID]). return Value
        VM := gooey_float{}
        spawn. VM.Init(Default)
        if. set Values[ParticipantID] = VM

        return VM

resource_str_property_vm<public> := class():
    ID<public>:gooey_string := gooey_string{}
    Default<public>:string
    var Values<public>:[string]gooey_string := map{}

    Init<public>(PropertyID:string)<suspends>:void =
        spawn. ID.Init(PropertyID)

    # TODO: Make transacts when I can get rid of the `Init`
    ValueFor<public>(ParticipantID:string):gooey_string =
        if (Value := Values[ParticipantID]). return Value
        VM := gooey_string{}
        spawn. VM.Init(Default)
        if. set Values[ParticipantID] = VM

        return VM

resource_bool_property_vm<public> := class():
    ID<public>:gooey_string := gooey_string{}
    Default<public>:logic
    var Values<public>:[string]gooey_bool := map{}

    Init<public>(PropertyID:string)<suspends>:void =
        spawn. ID.Init(PropertyID)

    # TODO: Make transacts when I can get rid of the `Init`
    ValueFor<public>(ParticipantID:string):gooey_bool =
        if (Value := Values[ParticipantID]). return Value
        VM := gooey_bool{}
        spawn. VM.Init(Default)
        if. set Values[ParticipantID] = VM

        return VM

resource_agent_property_vm<public> := class():
    ID<public>:gooey_string := gooey_string{}
    Default<public>:?agent
    var Values<public>:[string]gooey_agent := map{}

    Init<public>(PropertyID:string)<suspends>:void =
        spawn. ID.Init(PropertyID)

    # TODO: Make transacts when I can get rid of the `Init`
    ValueFor<public>(ParticipantID:string):gooey_agent =
        if (Value := Values[ParticipantID]). return Value
        VM := gooey_agent{}
        spawn. VM.Init(Default)
        if. set Values[ParticipantID] = VM

        return VM

action_maker<public> := class():
    GameState<public>:game_state
    Subject<public>:string
    Effects<public>:[]effect

    ActionFor<public>(NewTarget:string):action=
        action:
            GameState := GameState
            Subject := Subject
            Target := NewTarget
            Effects := Effects

action<public> := class():
    GameState<public>:game_state
    Subject<public>:string
    Target<public>:string
    Effects<public>:[]effect

    Execute<public>():void= spawn. Run(load{})
    ExecutePay<public>(Pay:load):void= spawn. Run(Pay)

    Run(Pay:load)<suspends>:void=
        var LastCommandModification:command = command:
            Subject := Subject
            Target := Target
            Pay := Pay
        var Iterator:int = 0
        loop:
            if (Effect := Effects[Iterator]):
                if (Effector := GameState.EffectorProvider.Get[Effect.FN]):
                    Focus := Effect.Focus
                    EffectPay := Pay.Override(Effect.Pay)

                    Commands := Effector.Play(Subject, Target, Focus, EffectPay)

                    if (not Commands?). break

                    for (Command:Commands?). GameState.Commander.Fire(Command)
                    set Iterator += 1
                else:
                    Print("[{Effect.FN}] not found")
                    break
            else. break

(Pay:load).Override<public>(NewPay:load):load = load:
    Prop := if (NewPay.Prop?). NewPay.Prop else. Pay.Prop
    Str := if (NewPay.Str <> ""). NewPay.Str else. Pay.Str
    Num := if (not NewPay.Num.Equals[num{}]). NewPay.Num else. Pay.Num
    Float := if (NewPay.Float <> 0.0). NewPay.Float else. Pay.Float
