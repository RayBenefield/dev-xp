
using. /Verse.org/Simulation
using. Goo

Filter(Keys:[]string, Values:[string]logic)<transacts>:[]string= for(K:Keys, Values[K]?). K
Reject(Keys:[]string, Values:[string]logic)<transacts>:[]string= for(K:Keys, not Values[K]?). K

Strs<public><constructor>(Default:[]string)<transacts> := prop_strs. Default := Default
Strs<public><constructor>(Focus:half_path)<transacts> := prop_strs. Focus := Focus
Strs<public><constructor>(Focus:prop_path)<transacts> := prop_strs. Focus := Focus.ToPath()
Strs<public><constructor>(Focus:half_path, FN:string)<transacts> := prop_strs{ Focus := Focus, FN := FN }
Strs<public><constructor>(FN:string, Focus:half_path)<transacts> := prop_strs{ Focus := Focus, FN := FN }
Strs<public><constructor>(Focus:half_path, FN:string, Tweak:half_path)<transacts> := prop_strs{ Focus := Focus, FN := FN, Tweak := Tweak }
MaybeStrs<public><constructor>(Focus:?prop_path)<transacts> := prop_strs. Focus := Focus?.ToPath() or EmptyPath()

PropStrs<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_strs{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_strs<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.StrsType
    @editable Default<public>:[]string = array{}
    ValueFor<public>(State:scoped_state):strs_goo= case(FN):
        "Filter" => StrsGoo(Computed(State.ToStrs(Focus), State.GatherBools(Focus, Tweak), Filter))
        "Reject" => StrsGoo(Computed(State.ToStrs(Focus), State.GatherBools(Focus, Tweak), Reject))
        _ => case(Type):
            _ => if (not Focus.Empty[]). State.ToStrs(Focus)
            else. StrsGoo(Default)
