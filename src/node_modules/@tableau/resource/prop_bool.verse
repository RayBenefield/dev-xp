
using. /Verse.org/Simulation

using. Goo
using. Numb

NotEmpty(Value:string)<transacts>:logic= if (Value <> ""). true else. false
NotBools(Value:logic)<transacts>:logic= if (Value?). false else. true
OrBools(First:logic, Second:logic)<transacts>:logic= if (First = true or Second = true). true else. false
AndBools(First:logic, Second:logic)<transacts>:logic= if (First = true and Second = true). true else. false
StrEquals(First:string, Second:string)<transacts>:logic= if (First = Second). true else. false
NumEquals(First:num, Second:num)<transacts>:logic= if (First.Equals[Second]). true else. false
GTE(First:num, Second:num)<transacts>:logic= if (First.GreaterThanOrEqual[Second]). true else. false
IntLT(First:int, Second:int)<transacts>:logic= if (First < Second). true else. false
IntGT(First:int, Second:int)<transacts>:logic= if (First > Second). true else. false
IntLTE(First:int, Second:int)<transacts>:logic= if (First <= Second). true else. false
IntGTE(First:int, Second:int)<transacts>:logic= if (First >= Second). true else. false
IntEquals(First:int, Second:int)<transacts>:logic= if (First = Second). true else. false
StrToBool(Value:string)<transacts>:logic= if (Value <> ""). true else. false

bool_plug<public> := class<concrete>():
    @editable Default:logic = false
    @editable Source:?prop_path = false
Bool<public>(Plug:bool_plug)<transacts>:prop_bool := (Bool of Plug.Source?) or (Bool of Plug.Default)

Bool<public><constructor>(Default:logic)<transacts> := prop_bool. Default := Default
Bool<public><constructor>(Focus:half_path)<transacts> := prop_bool. Focus := Focus
Bool<public><constructor>(Focus:prop_path)<transacts> := prop_bool. Focus := Focus.ToPath()
Bool<public><constructor>(Focus:half_path, FN:string)<transacts> := prop_bool{ Focus := Focus, FN := FN }
Bool<public><constructor>(FN:string, Focus:half_path)<transacts> := prop_bool{ Focus := Focus, FN := FN }
Bool<public><constructor>(Focus:half_path, FN:string, Tweak:half_path)<transacts> := prop_bool{ Focus := Focus, FN := FN, Tweak := Tweak }
MaybeBool<public><constructor>(Focus:?prop_path)<transacts> := prop_bool. Focus := Focus?.ToPath() or EmptyPath()

PropBool<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_bool{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_bool<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.BoolType
    @editable Default<public>:logic = false
    ValueFor<public>(State:scoped_state):bool_goo= case(FN):
        "Int >" => BoolGoo(Computed(State.ToInt(Focus), State.ToInt(Tweak), IntGT))
        "Int <" => BoolGoo(Computed(State.ToInt(Focus), State.ToInt(Tweak), IntLT))
        "Int >=" => BoolGoo(Computed(State.ToInt(Focus), State.ToInt(Tweak), IntGTE))
        "Int <=" => BoolGoo(Computed(State.ToInt(Focus), State.ToInt(Tweak), IntLTE))
        "Int =" => BoolGoo(Computed(State.ToInt(Focus), State.ToInt(Tweak), IntEquals))
        ">=" => BoolGoo(Computed(State.ToNum(Focus), State.ToNum(Tweak), GTE))
        "=" => BoolGoo(Computed(State.ToNum(Focus), State.ToNum(Tweak), NumEquals))
        "AND" => BoolGoo(Computed(State.ToBool(Focus), State.ToBool(Tweak), AndBools))
        "OR" => BoolGoo(Computed(State.ToBool(Focus), State.ToBool(Tweak), OrBools))
        "NOT" => BoolGoo(Map(State.ToBool(Focus), NotBools))
        "Not Empty" => BoolGoo(Map(State.ToStr(Focus), NotEmpty))
        "String Equals" => BoolGoo(Computed(State.ToStr(Focus), State.ToStr(Tweak), StrEquals))
        _ =>  case(Type):
            prop_type.StrType => BoolGoo(Map(State.ToStr(Focus), StrToBool))
            _ => if (not Focus.Empty[]). State.ToBool(Focus)
            else. BoolGoo(Default)
