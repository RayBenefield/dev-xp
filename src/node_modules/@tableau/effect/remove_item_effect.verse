
using. Numb

RemoveItem<public><constructor>(Focus:string)<transacts> := effect. RemoveItem<constructor>(Path(Focus))
RemoveItem<public><constructor>(ResID:string, PropID:string)<transacts> := effect. RemoveItem<constructor>(Path(ResID, PropID))
RemoveItem<public><constructor>(ResID:half_path, PropID:string)<transacts> := effect. RemoveItem<constructor>(Path(ResID, PropID))
RemoveItem<public><constructor>(ResID:string, PropID:half_path)<transacts> := effect. RemoveItem<constructor>(Path(ResID, PropID))
RemoveItem<public><constructor>(ResID:half_path, PropID:half_path)<transacts> := effect. RemoveItem<constructor>(Path(ResID, PropID))
RemoveItem<public><constructor>(Focus:half_path)<transacts> := effect{ FN := "Remove Item", Focus := Focus }
remove_item_effect<public> := class():
    Focus<public>:half_path
    Tweak<public>:half_path
    State<public>:scoped_state
    Affect<public>()<suspends>:?string=
        Prop := State.ToStrs(Tweak)
        Items := Prop.Get()
        ItemToRemove := State.ToStr(Focus).Get()
        if (IndexOfItem := Items.Find[ItemToRemove], NewItems := Items.RemoveElement[IndexOfItem]):
            Prop.Set(NewItems)
            return false

        return option. "Could not remove {ItemToRemove} from {Focus} with {Items.Length} items"
