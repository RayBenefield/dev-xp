
using. Numb

Remove<public><constructor>(Focus:string)<transacts> := effect. Remove<constructor>(Path(Focus))
Remove<public><constructor>(ResID:string, PropID:string)<transacts> := effect. Remove<constructor>(Path(ResID, PropID))
Remove<public><constructor>(ResID:half_path, PropID:string)<transacts> := effect. Remove<constructor>(Path(ResID, PropID))
Remove<public><constructor>(ResID:string, PropID:half_path)<transacts> := effect. Remove<constructor>(Path(ResID, PropID))
Remove<public><constructor>(ResID:half_path, PropID:half_path)<transacts> := effect. Remove<constructor>(Path(ResID, PropID))
Remove<public><constructor>(Focus:half_path)<transacts> := effect{ FN := "Remove", Focus := Focus }

RemoveEffect<public>(Focus:half_path, Tweak:half_path, State:scoped_state)<suspends>:?string=
    Prop := State.ToStrs(Tweak)
    Items := Prop.Get()
    ItemToRemove := State.ToInt(Focus).Get() - 1
    if (NewItems := Items.RemoveElement[ItemToRemove]):
        Prop.Set(NewItems)
        return false

    return option. "Could not remove {ItemToRemove} from {Focus} with {Items.Length} items"
