
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }

using { Tableau }
using { TableauTesting }
using { TableauProducer }
using { TableauParticipant }

producer_service_test := class(creative_device, test_suite):
    GetName<override>():string = "Producer Service"
    GetTests<override>():[]test_case = array:
        test_case:
            Name := "Should be able to buy an producer"
            Test := SimpleBuy
        test_case:
            Name := "Should not buy a producer you cannot afford"
            Test := CannotAfford
        test_case:
            Name := "Should buy a producer you can afford"
            Test := CanAffordTest
        test_case:
            Name := "Should not buy a producer if requirements not met"
            Test := DoesNotHaveRequiredProds
        test_case:
            Name := "Should buy a producer if requirements met, with no cost"
            Test := BuyWithRequiredAndNoCost
        test_case:
            Name := "Should buy a producer if requirements met, and can afford"
            Test := BuyWithRequiredAndCanAfford
        test_case:
            Name := "Should not buy a producer if requirements met, and can't afford"
            Test := NotBuyWithRequiredAndCannotAfford
        test_case:
            Name := "Should not buy a producer if requirements are not met, but can afford"
            Test := NotBuyWithoutRequiredAndCanAfford
        test_case:
            Name := "Should not buy a producer if requirements are not met, and can't afford"
            Test := NotBuyWithoutRequiredAndCannotAfford
        test_case:
            Name := "Should not need requirements"
            Test := NoRequirements
        test_case:
            Name := "Should have one requirement met"
            Test := PassesOneRequirement
        test_case:
            Name := "Should have one requirement but fail it"
            Test := FailOneRequirement
        test_case:
            Name := "Should have two requirement and pass both"
            Test := PassBothRequirements
        test_case:
            Name := "Should have two requirement and pass only one, so fail"
            Test := PassOneOfTwoRequirements
        test_case:
            Name := "Should have two requirement, but fail both"
            Test := FailBothRequirements
        test_case:
            Name := "VFX State should be maxed"
            Test := VFXState_Maxed
        test_case:
            Name := "VFX State should be bought"
            Test := VFXState_Bought
        test_case:
            Name := "VFX State should not be available"
            Test := VFXState_NotAvailable
        test_case:
            Name := "VFX State should be available and free"
            Test := VFXState_AvailableAndFree
        test_case:
            Name := "VFX State should be available and first is free"
            Test := VFXState_AvailableAndFirstFree
        test_case:
            Name := "VFX State should be available not affordable"
            Test := VFXState_AvailableNotAffordable
        test_case:
            Name := "VFX State should be available and affordable"
            Test := VFXState_AvailableAndAffordable

    SimpleBuy():?failure =
        # Arrange
        Producer := producer{ ID := 13 }
        Repo := producer_repository. Initial := array. Producer
        ParticipantRepo := participant_repository. Initial := array{}
        Service := producer_service{ Repo := Repo, ParticipantRepo := ParticipantRepo, EffectProvider := effect_provider{} }
        Ev1 := Ev_ProdPurchased(entity_producer{}, 13)
        Ev2 := Ev_ProdPurchased(entity_participant{}, 26)

        # Act
        Events := Service.Buy(13, 26)

        # Assert
        if(not Events.Length = 2). return fail("Not the right number of Domain Events")
        if(not Events.Includes[Ev1]). return fail("No producer purchased event for producer")
        if(not Events.Includes[Ev2]). return fail("No producer purchased event for participant")

        # Pass
        return false

    CannotAfford():?failure =
        # Arrange
        Producer := producer{ ID := 13, Cost := option. cost{ Amount := num. Value := 1.0, Type := 1 } }
        Repo := producer_repository. Initial := array. Producer
        Participant := participant{ ID := 26 }
        ParticipantRepo := participant_repository. Initial := array. Participant
        Service := producer_service{ Repo := Repo, ParticipantRepo := ParticipantRepo, EffectProvider := effect_provider{} }

        # Act
        Events := Service.Buy(13, 26)

        # Assert
        if(not Events.Length = 0). return fail("Not the right number of Domain Events")

        # Pass
        return false

    CanAffordTest():?failure =
        # Arrange
        Producer := producer{ ID := 13, Cost := option. cost{ Amount := num. Value := 1.0, Type := 1 } }
        Repo := producer_repository. Initial := array. Producer
        Participant := participant{ ID := 26, Resources := map{ 1 => num. Value := 2.0 } }
        ParticipantRepo := participant_repository. Initial := array. Participant
        Service := producer_service{ Repo := Repo, ParticipantRepo := ParticipantRepo, EffectProvider := effect_provider{} }
        Ev1 := Ev_ProdPurchased(entity_producer{}, 13)
        Ev2 := Ev_ProdPurchased(entity_participant{}, 26)
        ExpectedAmount := num. Value := 1.0

        # Act
        Events := Service.Buy(13, 26)

        # Assert
        if(not Events.Length = 2). return fail("Not the right number of Domain Events")
        if(not Events.Includes[Ev1]). return fail("No producer purchased event for producer")
        if(not Events.Includes[Ev2]). return fail("No producer purchased event for participant")
        if(Part := ParticipantRepo.GetByID[26], not Part.GetResource(1).Equals[ExpectedAmount]):
            return fail("Did not subtract resources.")

        # Pass
        return false

    DoesNotHaveRequiredProds():?failure =
        # Arrange
        RequiredProducer := producer{ ID := 13 }
        Producer := producer{ ID := 14, Required := option. array. 13 }
        Repo := producer_repository. Initial := array{ RequiredProducer, Producer }
        ParticipantRepo := participant_repository. Initial := array{}
        Service := producer_service{ Repo := Repo, ParticipantRepo := ParticipantRepo, EffectProvider := effect_provider{} }

        # Act
        Events := Service.Buy(14, 26)

        # Assert
        if(not Events.Length = 0). return fail("Not the right number of Domain Events")

        # Pass
        return false

    BuyWithRequiredAndNoCost():?failure =
        # Arrange
        Participant := participant. ID := 26
        RequiredProducer := producer{ ID := 13, Counts := map{ 26 => 1 } }
        Producer := producer{ ID := 14, Required := option. array. 13 }
        Repo := producer_repository. Initial := array{ RequiredProducer, Producer }
        ParticipantRepo := participant_repository. Initial := array. Participant
        Service := producer_service{ Repo := Repo, ParticipantRepo := ParticipantRepo, EffectProvider := effect_provider{} }
        Ev1 := Ev_ProdPurchased(entity_producer{}, 14)
        Ev2 := Ev_ProdPurchased(entity_participant{}, 26)

        # Act
        Events := Service.Buy(14, 26)

        # Assert
        if(not Events.Length = 2). return fail("Not the right number of Domain Events")
        if(not Events.Includes[Ev1]). return fail("No producer purchased event for producer")
        if(not Events.Includes[Ev2]). return fail("No producer purchased event for participant")

        # Pass
        return false

    BuyWithRequiredAndCanAfford():?failure =
        # Arrange
        Cost := option. cost{ Amount := num. Value := 1.0, Type := 1 }
        Participant := participant{ ID := 26, Resources := map{ 1 => num. Value := 2.0 } }
        RequiredProducer := producer{ ID := 13, Counts := map{ 26 => 1 } }
        Producer := producer{ ID := 14, Required := option. array. 13, Cost := Cost }
        Repo := producer_repository. Initial := array{ RequiredProducer, Producer }
        ParticipantRepo := participant_repository. Initial := array. Participant
        Service := producer_service{ Repo := Repo, ParticipantRepo := ParticipantRepo, EffectProvider := effect_provider{} }
        Ev1 := Ev_ProdPurchased(entity_producer{}, 14)
        Ev2 := Ev_ProdPurchased(entity_participant{}, 26)
        ExpectedAmount := num. Value := 1.0

        # Act
        Events := Service.Buy(14, 26)

        # Assert
        if(not Events.Length = 2). return fail("Not the right number of Domain Events")
        if(not Events.Includes[Ev1]). return fail("No producer purchased event for producer")
        if(not Events.Includes[Ev2]). return fail("No producer purchased event for participant")
        if(Part := ParticipantRepo.GetByID[26], not Part.GetResource(1).Equals[ExpectedAmount]):
            return fail("Did not subtract resources.")

        # Pass
        return false

    NotBuyWithRequiredAndCannotAfford():?failure =
        # Arrange
        Cost := option. cost{ Amount := num. Value := 1.0, Type := 1 }
        Participant := participant{ ID := 26, Resources := map{ 1 => num. Value := 0.0 } }
        RequiredProducer := producer{ ID := 13, Counts := map{ 26 => 1 } }
        Producer := producer{ ID := 14, Required := option. array. 13, Cost := Cost }
        Repo := producer_repository. Initial := array{ RequiredProducer, Producer }
        ParticipantRepo := participant_repository. Initial := array. Participant
        Service := producer_service{ Repo := Repo, ParticipantRepo := ParticipantRepo, EffectProvider := effect_provider{} }
        ExpectedAmount := num. Value := 0.0

        # Act
        Events := Service.Buy(14, 26)

        # Assert
        if(not Events.Length = 0). return fail("Not the right number of Domain Events")
        if(Part := ParticipantRepo.GetByID[26], not Part.GetResource(1).Equals[ExpectedAmount]):
            return fail("Should not change resources.")

        # Pass
        return false

    NotBuyWithoutRequiredAndCanAfford():?failure =
        # Arrange
        Cost := option. cost{ Amount := num. Value := 1.0, Type := 1 }
        Participant := participant{ ID := 26, Resources := map{ 1 => num. Value := 2.0 } }
        RequiredProducer := producer{ ID := 13, Counts := map{ 26 => 0 } }
        Producer := producer{ ID := 14, Required := option. array. 13, Cost := Cost }
        Repo := producer_repository. Initial := array{ RequiredProducer, Producer }
        ParticipantRepo := participant_repository. Initial := array. Participant
        Service := producer_service{ Repo := Repo, ParticipantRepo := ParticipantRepo, EffectProvider := effect_provider{} }
        ExpectedAmount := num. Value := 2.0

        # Act
        Events := Service.Buy(14, 26)

        # Assert
        if(not Events.Length = 0). return fail("Not the right number of Domain Events")
        if(Part := ParticipantRepo.GetByID[26], not Part.GetResource(1).Equals[ExpectedAmount]):
            return fail("Did not subtract resources.")

        # Pass
        return false

    NotBuyWithoutRequiredAndCannotAfford():?failure =
        # Arrange
        Cost := option. cost{ Amount := num. Value := 1.0, Type := 1 }
        Participant := participant{ ID := 26, Resources := map{ 1 => num. Value := 0.0 } }
        RequiredProducer := producer{ ID := 13, Counts := map{ 26 => 0 } }
        Producer := producer{ ID := 14, Required := option. array. 13, Cost := Cost }
        Repo := producer_repository. Initial := array{ RequiredProducer, Producer }
        ParticipantRepo := participant_repository. Initial := array. Participant
        Service := producer_service{ Repo := Repo, ParticipantRepo := ParticipantRepo, EffectProvider := effect_provider{} }
        ExpectedAmount := num. Value := 0.0

        # Act
        Events := Service.Buy(14, 26)

        # Assert
        if(not Events.Length = 0). return fail("Not the right number of Domain Events")
        if(Part := ParticipantRepo.GetByID[26], not Part.GetResource(1).Equals[ExpectedAmount]):
            return fail("Did not subtract resources.")

        # Pass
        return false

    NoRequirements():?failure =
        # Arrange
        Producer := producer{ ID := 14 }
        All := map:
            14 => Producer

        # Act, Assert
        if(not HasRequiredProducers[All, Producer, 26]). return fail("Should pass requirements")

        # Pass
        return false

    PassesOneRequirement():?failure =
        # Arrange
        RequiredProducer := producer{ ID := 13, Counts := map{ 26 => 1 } }
        Producer := producer{ ID := 14, Required := option. array. 13 }
        All := map:
            13 => RequiredProducer
            14 => Producer

        # Act, Assert
        if(not HasRequiredProducers[All, Producer, 26]). return fail("Should pass requirements")

        # Pass
        return false

    FailOneRequirement():?failure =
        # Arrange
        RequiredProducer := producer{ ID := 13, Counts := map{ 26 => 0 } }
        Producer := producer{ ID := 14, Required := option. array. 13 }
        All := map:
            13 => RequiredProducer
            14 => Producer

        # Act, Assert
        if(HasRequiredProducers[All, Producer, 26]). return fail("Should not pass requirements")

        # Pass
        return false

    PassBothRequirements():?failure =
        # Arrange
        RequiredProducer := producer{ ID := 13, Counts := map{ 26 => 1 } }
        RequiredProducer2 := producer{ ID := 15, Counts := map{ 26 => 1 } }
        Producer := producer{ ID := 14, Required := option. array{ 13, 15 } }
        All := map:
            13 => RequiredProducer
            14 => Producer
            15 => RequiredProducer2

        # Act, Assert
        if(not HasRequiredProducers[All, Producer, 26]). return fail("Should pass requirements")

        # Pass
        return false

    PassOneOfTwoRequirements():?failure =
        # Arrange
        RequiredProducer := producer{ ID := 13, Counts := map{ 26 => 1 } }
        RequiredProducer2 := producer{ ID := 15, Counts := map{ 26 => 0 } }
        Producer := producer{ ID := 14, Required := option. array{ 13, 15 } }
        Repo := producer_repository. Initial := array{ RequiredProducer, RequiredProducer2, Producer }
        All := map:
            13 => RequiredProducer
            14 => Producer
            15 => RequiredProducer2

        # Act, Assert
        if(HasRequiredProducers[All, Producer, 26]). return fail("Should not pass requirements")

        # Pass
        return false

    FailBothRequirements():?failure =
        # Arrange
        RequiredProducer := producer{ ID := 13, Counts := map{ 26 => 0 } }
        RequiredProducer2 := producer{ ID := 15, Counts := map{ 26 => 0 } }
        Producer := producer{ ID := 14, Required := option. array{ 13, 15 } }
        All := map:
            13 => RequiredProducer
            14 => Producer
            15 => RequiredProducer2

        # Act, Assert
        if(HasRequiredProducers[All, Producer, 26]). return fail("Should not pass requirements")

        # Pass
        return false

    VFXState_Maxed():?failure =
        # Arrange
        Producer := producer{ ID := 13, MaxCount := 1, Counts := map{ 26 => 1 } }
        Participant := participant{ ID := 26 }
        All := map:
            13 => Producer

        # Act
        Result := WhichVFXState(All, Producer, Participant, 1)

        # Assert
        if(not Result = producer_vfx_state.Maxed). return fail("Should be maxed")

        # Pass
        return false

    VFXState_NotAvailable():?failure =
        # Arrange
        Producer := producer{ ID := 13, MaxCount := 1, Counts := map{ 26 => 0 }, Required := option. array. 14 }
        Participant := participant{ ID := 26 }
        All := map:
            13 => Producer

        # Act
        Result := WhichVFXState(All, Producer, Participant, 0)

        # Assert
        if(not Result = producer_vfx_state.NotAvailable). return fail("Should not be available")

        # Pass
        return false

    VFXState_AvailableAndFree():?failure =
        # Arrange
        Producer := producer{ ID := 13, MaxCount := 1, Counts := map{ 26 => 0 } }
        Participant := participant{ ID := 26 }
        All := map:
            13 => Producer

        # Act
        Result := WhichVFXState(All, Producer, Participant, 0)

        # Assert
        if(not Result = producer_vfx_state.AvailableAndFree). return fail("Should be available and free")

        # Pass
        return false

    VFXState_AvailableAndFirstFree():?failure =
        # Arrange
        Cost := cost{ Amount := num. Value := 1.0, Type := 1 }
        Producer := producer{ ID := 13, Cost := option. Cost, MaxCount := 1, Counts := map{ 26 => 0 }, FirstIsFree := true }
        Participant := participant{ ID := 26 }
        All := map:
            13 => Producer

        # Act
        Result := WhichVFXState(All, Producer, Participant, 0)

        # Assert
        if(not Result = producer_vfx_state.AvailableAndFree). return fail("Should be available but not affordable")

        # Pass
        return false

    VFXState_AvailableNotAffordable():?failure =
        # Arrange
        Cost := cost{ Amount := num. Value := 1.0, Type := 1 }
        Producer := producer{ ID := 13, Cost := option. Cost, MaxCount := 1, Counts := map{ 26 => 0 } }
        Participant := participant{ ID := 26 }
        All := map:
            13 => Producer

        # Act
        Result := WhichVFXState(All, Producer, Participant, 0)

        # Assert
        if(not Result = producer_vfx_state.AvailableNotAffordable). return fail("Should be available but not affordable")

        # Pass
        return false

    VFXState_AvailableAndAffordable():?failure =
        # Arrange
        Cost := cost{ Amount := num. Value := 1.0, Type := 1 }
        Producer := producer{ ID := 13, Cost := option. Cost, MaxCount := 1, Counts := map{ 26 => 0 } }
        Participant := participant{ ID := 26, Resources := map{ 1 => num. Value := 2.0 } }
        All := map:
            13 => Producer

        # Act
        Result := WhichVFXState(All, Producer, Participant, 0)

        # Assert
        if(not Result = producer_vfx_state.AvailableAndAffordable). return fail("Should be available and affordable")

        # Pass
        return false

    VFXState_Bought():?failure =
        # Arrange
        Producer := producer{ ID := 13, MaxCount := 1, Counts := map{ 26 => 1 } }
        Participant := participant{ ID := 26 }
        All := map:
            13 => Producer

        # Act
        Result := WhichVFXState(All, Producer, Participant, 0)

        # Assert
        if(not Result = producer_vfx_state.Bought). return fail("Should be bought")

        # Pass
        return false
