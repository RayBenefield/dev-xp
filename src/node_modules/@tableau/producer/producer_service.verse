using { Tableau }
using { TableauParticipant }

Ev_ProdPurchased<constructor>(Type:entity, ID:int) := domain_event:
    Entity := Type
    EntityID := ID
    Event := ev_producer_purchased{}

prod_int_lens := type{_(:producer):[]int}
prod_num_lens := type{_(:producer):[]num}

producer_service<public> := class(service):
    Repo<public>:producer_repository
    ParticipantRepo<public>:participant_repository
    EffectProvider<public>:effect_provider

    Buy<public>(ProducerID:int, BuyerID:int):[]domain_event=
        var DomainEvents:[]domain_event = array{}
        if:
            Prod := Repo.GetByID[ProducerID]
        then:
            # Required Producers
            if (not HasRequiredProducers[Repo, Prod, BuyerID]). return DomainEvents

            if (Cost := Prod.Cost?):
                if:
                    Buyer := ParticipantRepo.GetByID[BuyerID]
                    Amount := Buyer.GetResource(Cost.Type)
                    Amount.GreaterThanOrEqual[Cost.Amount]
                then:
                    # TODO: Move Repo update to actual domain event generation
                    if (NewParticipant := Buyer.RemoveResources[Cost.Type, Cost.Amount]):
                        if (ParticipantRepo.Update[NewParticipant]) {}
                else:
                    return DomainEvents

            if (NewProducer := Prod.IncreaseCount[BuyerID]):
                if (Repo.Update[NewProducer]):
                    set DomainEvents += array:
                        Ev_ProdPurchased(entity_producer{}, Prod.ID)
                        Ev_ProdPurchased(entity_participant{}, BuyerID)

        return DomainEvents

    #
    # EXPERIMENTAL
    #
    Collect<public>():[]domain_event=
        var DomainEvents:[]domain_event = array{}

        Prods := Repo.GetAll()
        for(Prod:Prods, Abilities := Prod.Abilities, Ability:Abilities):
            var LastCommandModification:command = ProducerAbilityToCommand(Ability, Prod)
            for (Effect:LastCommandModification.AfterEffects):
                set LastCommandModification = Effect.Play(LastCommandModification)

        return DomainEvents

    Lens_ProducerID(Prod:producer):[]int = array. Prod.ID
    Lens_ProducerResourceID(Prod:producer):[]int = if (ResID := Prod.ResourceID?). array. ResID else. array {}
    # TODO: Add as producer domain object function
    Lens_ProducerAllOwners(Prod:producer):[]int = for(Owner->Count : Prod.Counts). Owner
    Lens_ProducerProductionRate(Prod:producer):[]num = array. Prod.Production

    ProducerAbilityToCommand<public>(Ability:producer_ability, Prod:producer):command=
        IntLenses:[producer_int_lenses]prod_int_lens = map:
            producer_int_lenses.ID => Lens_ProducerID
            producer_int_lenses.ResourceID => Lens_ProducerResourceID
            producer_int_lenses.AllOwners => Lens_ProducerAllOwners
        NumLenses:[producer_num_lenses]prod_num_lens = map:
            producer_num_lenses.ProductionRate => Lens_ProducerProductionRate

        return if:
            SubjectLens := IntLenses[Ability.Subjects]
            TargetLens := IntLenses[Ability.Targets]
            MagnitudeLens := NumLenses[Ability.Magnitudes]
        then:
            command:
                Subjects := SubjectLens(Prod)
                Targets := TargetLens(Prod)
                Magnitudes := MagnitudeLens(Prod)
                AfterEffects := for(Eff:Ability.AfterEffects, Effect := EffectProvider.Get[Eff]). Effect
        else:
            command{}

HasRequiredProducers<public>(Repo:producer_repository, Prod:producer, ParticipantID:int)<decides><transacts>:int=
    NotOwned := for (Required:Prod.Required?, not Repo.OwnsProducer[ParticipantID, Required]). Required
    NotOwned.Length <= 0

# TODO: Add tests for all the SHOULDs below
ShouldBeBuyable<public>(Repo:producer_repository, Prod:producer, ParticipantID:int)<decides><transacts>:void=
    HasRequiredProducers[Repo, Prod, ParticipantID]
    not Prod.IsMaxed[ParticipantID]

ShouldBeBuyableNow<public>(Repo:producer_repository, Prod:producer, OldProd:producer, ParticipantID:int)<decides><transacts>:void=
    # TODO: Include historical check of whether or not required producers exist
    # not HasRequiredProducers[Repo, OldProd, ParticipantID]
    HasRequiredProducers[Repo, Prod, ParticipantID]
    not Prod.IsMaxed[ParticipantID]

ShouldBeBoughtNow<public>(Repo:producer_repository, Prod:producer, OldProd:producer, ParticipantID:int)<decides><transacts>:void=
    HasRequiredProducers[Repo, Prod, ParticipantID]
    not OldProd.IsMaxed[ParticipantID]
    Prod.IsMaxed[ParticipantID]
