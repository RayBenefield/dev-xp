
using { /Fortnite.com/Devices }
using { /Verse.org/Simulation }

using { Tableau }
using { TableauTesting }
using { TableauProducer }

producer_test := class(creative_device, test_suite):
    GetName<override>():string = "Producer"
    GetTests<override>():[]test_case = array:
        test_case:
            Name := "Producer Non-Owner should not be maxed"
            Test := IsNotMaxed
        test_case:
            Name := "Producer Non-Owner should be maxed"
            Test := IsMaxed
        test_case:
            Name := "Producer should have a cost"
            Test := ShouldHaveCost
        test_case:
            Name := "Producer should get the cost of one count"
            Test := GetCostOfOne
        test_case:
            Name := "Producer should get the cost of two count"
            Test := GetCostOfTwo
        test_case:
            Name := "Producer should increase its count"
            Test := IncreaseCount
        test_case:
            Name := "Producer should not increase its count when maxed"
            Test := NoIncreaseCountCuzMax
        test_case:
            Name := "Should have no production Amount none are owned"
            Test := GetNoAmount
        test_case:
            Name := "Should have the default Amount of production with 1 count"
            Test := GetDefaultAmount
        test_case:
            Name := "Should have double the Amount of production with 2 counts"
            Test := GetDoubleAmount
        test_case:
            Name := "Should be owned by"
            Test := IsOwnedBy
        test_case:
            Name := "Should have a default 1.0 rate"
            Test := GetDefaultProductionRate
        test_case:
            Name := "Should have a set value of 2.0 rate"
            Test := GetProductionRate
        test_case:
            Name := "Should have an explicit default 3.0 rate"
            Test := GetSetDefaultProductionRate

    IsNotMaxed():?failure =
        # Arrange
        Producer := producer{ ID := 13, MaxCount := 1, Counts := map{ 26 => 1, 39 => 0 } }

        # Act, Assert
        if (Producer.IsMaxed[39]). return fail("Producer shouldn't be maxed")

        # Pass
        return false

    IsMaxed():?failure =
        # Arrange
        Producer := producer{ ID := 13, MaxCount := 1, Counts := map{ 26 => 0, 39 => 1 } }

        # Act, Assert
        if (not Producer.IsMaxed[39]). return fail("Producer should be maxed")

        # Pass
        return false

    ShouldHaveCost():?failure =
        # Arrange
        Cost := option. cost{ Amount := num. Value := 1.0, Type := 1 }
        Producer := producer{ ID := 13, Cost := Cost }

        # Act, Assert
        if (not Producer.HasCost[]). return fail("Producer should should have a cost")

        # Pass
        return false

    GetCostOfOne():?failure =
        # Arrange
        Amount := num. Value := 3.74
        Cost := option. cost{ Amount := Amount, Type := 1 }
        Producer := producer{ ID := 13, Cost := Cost, Counts := map{ 26 => 0 } }

        # Act, Assert
        if (ActualCost := Producer.GetCost[26]):
            if (not ActualCost.Amount.Equals[Amount]). return fail("Should have the right cost")
        else:
            return fail("Producer should should have a cost")

        # Pass
        return false

    GetCostOfTwo():?failure =
        # Arrange
        Amount := num. Value := 4.0
        Cost := option. cost{ Amount := Amount, Type := 1 }
        Producer := producer{ ID := 13, Cost := Cost, Counts := map{ 26 => 1 } }
        ExpectedAmount := num. Value := 4.0

        # Act, Assert
        if (ActualCost := Producer.GetCost[26]):
            if (not ActualCost.Amount.Equals[ExpectedAmount]). return fail("Should have the right cost")
        else:
            return fail("Producer should should have a cost")

        # Pass
        return false

    IncreaseCount():?failure =
        # Arrange
        Producer := producer{ ID := 13, MaxCount := 1, Counts := map{ 26 => 0 } }
        var NewProd:producer = Producer

        # Act
        if (Value := Producer.IncreaseCount[26], set NewProd = Value) {}

        # Assert
        Count := NewProd.GetCount(26)
        if (Count = 0). return fail("Producer count didn't increase")

        # Pass
        return false

    NoIncreaseCountCuzMax():?failure =
        # Arrange
        Producer := producer{ ID := 13, MaxCount := 1, Counts := map{ 26 => 1 } }
        var NewProd:producer = Producer

        # Act
        if (Value := Producer.IncreaseCount[26], set NewProd = Value) {}

        # Assert
        Count := NewProd.GetCount(26)
        if (Count = 2). return fail("Producer should not have increased")

        # Pass
        return false

    GetNoAmount():?failure =
        # Arrange
        Producer := producer{ ID := 13, Counts := map{ 26 => 0 } }
        var NewProd:producer = Producer

        # Act
        Amount := Producer.GetProductionAmount(26)

        # Assert
        if (Amount.Value <> 0.0 or Amount.Exponent <> 0). return fail("Should not have a production Amount")

        # Pass
        return false

    GetDefaultAmount():?failure =
        # Arrange
        Producer := producer{ ID := 13, Counts := map{ 26 => 1 } }
        var NewProd:producer = Producer

        # Act
        Amount := Producer.GetProductionAmount(26)

        # Assert
        if (Amount.Value <> 1.67 or Amount.Exponent <> 0). return fail("Should have default production Amount")

        # Pass
        return false

    GetDoubleAmount():?failure =
        # Arrange
        Producer := producer{ ID := 13, Counts := map{ 26 => 2 } }
        var NewProd:producer = Producer

        # Act
        Amount := Producer.GetProductionAmount(26)

        # Assert
        if (Amount.Value <> 3.34 or Amount.Exponent <> 0). return fail("Should have the expected production Amount")

        # Pass
        return false

    IsOwnedBy():?failure =
        # Arrange
        Prod:= producer{ ID := 13, Counts := map{ 26 => 1 } }

        # Act, Assert
        if (not Prod.OwnedBy[26]). return fail("Should be owned by")

        # Pass
        return false

    IsNotOwnedBy():?failure =
        # Arrange
        Prod:= producer{ ID := 13 }

        # Act, Assert
        if (Prod.OwnedBy[26]). return fail("Should not be owned by")

        # Pass
        return false

    GetDefaultProductionRate():?failure =
        # Arrange
        Prod:= producer{ ID := 13 }

        # Act
        Rate := Prod.GetRate(26)

        # Assert
        if (not Rate = 1.0). return fail("Should have production rate of 1.0")

        # Pass
        return false

    GetProductionRate():?failure =
        # Arrange
        Prod:= producer{ ID := 13, Rates := map { 26 => 2.0 } }

        # Act
        Rate := Prod.GetRate(26)

        # Assert
        if (not Rate = 2.0). return fail("Should have production rate of 2.0")

        # Pass
        return false

    GetSetDefaultProductionRate():?failure =
        # Arrange
        Prod:= producer{ ID := 13, DefaultRate := 3.0 }

        # Act
        Rate := Prod.GetRate(26)

        # Assert
        if (not Rate = 3.0). return fail("Should have production rate of 3.0")

        # Pass
        return false
