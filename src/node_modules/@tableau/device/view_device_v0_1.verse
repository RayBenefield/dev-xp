
using. /Verse.org/Simulation
using. /Fortnite.com/Characters
using. /UnrealEngine.com/Temporary/SpatialMath

using. Vertex

rotation_yaw_getter_v0_1<public> := class():
    var Agent<public>:?agent = false
    SetAgent<public>(Value:?agent):void= set Agent = Value

    GetRotation<public>():vector3= Agent?.GetFortCharacter[].GetViewRotation().ToVector3() or vector3{}
    GetYaw<public>():float= GetRotation().X + 180.0

angle_snapper_v0_1<public> := class():
    ValueSource<public>:type{_():float}
    RotationSource<public>:type{_():vector3}
    PollingTime<public>:float = 0.0

    var ActiveIncrement<public>:float = 0.0
    var Notis<public>:[float]event() = map{}

    StartSnap<public>:event() = event(){}
    EndSnap<public>:event() = event(){}
    NewAngle<public>:event(float) = event(float){}
    NewOrientation<public>:event(float) = event(float){}

    Init()<suspends>:void=
        sync:
            WaitForSnap()
            CalculateOrientation()

    CalculateOrientation()<suspends>:void=
        var LastValue:float = 0.0
        loop:
            NewValue := ValueSource()
            if (NewValue<> LastValue):
                NewOrientation.Signal(NewValue)
                set LastValue = NewValue
            Sleep(PollingTime)

    WhenIncrementEquals<public>(Value:float):event()=
        NewEvent := event(){}
        option. set Notis[Value] = NewEvent
        NewEvent

    SnapTrigger<public>(Value:logic):void= if (Value?). StartSnap.Signal() else. EndSnap.Signal()

    WaitForSnap<public>()<suspends>:void=
        loop:
            StartSnap.Await()
            spawn. Snapping()

    Snapping<public>()<suspends>:void=
        BaseRotation := RotationSource()
        StartingRotation := vector3{ X := BaseRotation.X, Y := -45.0, Z := BaseRotation.Z }
        var LastValue:float = 0.0
        race:
            loop:
                NewRotation := RotationSource()
                ResultWithoutRatio := (StartingRotation) - (NewRotation)
                Result2 := vector3{ X := ResultWithoutRatio.X / 2.0, Y := ResultWithoutRatio.Y, Z := ResultWithoutRatio.Z }
                Rad := ArcTan(Result2.X, Result2.Y)
                Result := (Rad * (180.0/PiFloat)) + 180.0
                FinalValue := if (Result = 360.0). 0.0 else. Result
                if (FinalValue <> LastValue):
                    NewAngle.Signal(FinalValue)
                    set LastValue = FinalValue
                Sleep(0.0)
            EndSnap.Await()

view_device_v0_1<public> := class(tableau_device):
    DeviceType<override>:string = "VIEW"

    @editable EnableRadial:bool_plug = bool_plug{}
    @editable EnableSnap:bool_plug = bool_plug{}

    GetResources<override>():[]resource= array. resource:
        Props := map:
            "Radial Angle" => Float of 0.0
            "Radial Steps" => Integer of 8
            "Radial Snap" => Integer of (Path("Radial Angle"), "Get Pie Slice", Path("Radial Steps"))
            "Enable Radial" => Bool of EnableRadial
            "Active Radial Snap" => Integer of (Path("Enable Radial"), "If True", Path("Radial Snap"))
            "Enable Snap" => Bool of EnableSnap
            "Orientation Angle" => Float of 0.0
            "Orientation Steps" => Integer of 4
            "Orientation Snap" => Integer of (Path("Orientation Angle"), "Get Pie Slice", Path("Orientation Steps"))

    GetSideEffects<override>(State:scoped_state)<suspends>:[]side_effect=
        YawGetter := rotation_yaw_getter_v0_1{}
        Snapper := angle_snapper_v0_1{ ValueSource := YawGetter.GetYaw, RotationSource := YawGetter.GetRotation }

        array:
            StartWith(Snapper.Init)
            PushAgent(SubPath("Possessed By"), YawGetter.SetAgent)
            PushBool("Enable Snap", Snapper.SnapTrigger)
            SyncFloat("Radial Angle", Snapper.NewAngle)
            SyncFloat("Orientation Angle", Snapper.NewOrientation)
