
using. /Verse.org/Simulation
using. /Fortnite.com/Devices

using. Banding
using. Vertex

ReturnPool<constructor>(GameState:game_state, Type:string)<transacts> := pool_returner{ GameState := GameState, Type := Type }
pool_returner := class():
    GameState:game_state
    Type:string
    FN<public>():[]string= GameState.ResourceTypePools[Type] or array{}

ReturnID<constructor>(ID:string)<transacts> := id_returner. ID := ID
id_returner := class():
    ID:string
    FN<public>():[]string= array. ID

game_device_v0_1 := class(creative_device):

    @editable DebugResources:[]string = array{"","",""}

    IsDebug(R:resource)<decides><transacts>:void= DebugResources.Find[R.ID]

    OnBegin<override>()<suspends>:void=
        TableauDevices := LoadTableauDevices(Self)
        Print("Found Devices: {TableauDevices.Length}")

        Definitions := CombineAllArrays of for(Device:TableauDevices):
            Device.GetResources().Map(ToDefinition(Device).FN)

        NewTemplateMap := Definitions.GetTemplateMap()
        UntypedResources := Definitions.GetUntypedResourceMap()
        TypedResources := Definitions.GetTypedResourceMap()
        MergedResources := ConcatenateResourceMaps(TypedResources, UntypedResources)
        FinalResources := AddTemplatesToResources(NewTemplateMap, MergedResources)
        NewStaticResources := Definitions.GetStaticResourceMap()
        NewStaticTypes := Definitions.GetStaticTypeMap()
        NewResourceTypePools := Definitions.GetTypePoolMap()
        NewRelationshipMap := Definitions.GetRelationshipMap()

        PrintingResources := FinalResources.OnlyValues().Filter(IsDebug)
        for(P:PrintingResources). Print("{P}")

        AllResources := CombineAllArrays of array:
            FinalResources.OnlyValues()
            array. CreateGlobalsResource()
        Resources := CreateResourceMap of for(Resource:AllResources, ID := Resource.ID):
            (ID, AddProps(Resource, map{ "ID" => Str of ID }))

        LinkMap := CombineResourcePropMaps of for(P:Resources). P.GetRelevantProps()
        PlantUMLParents := for(P:NewTemplateMap, Links := LinkMap[P.Type]). P.ToPlantUMLParents(Links)
        PlantUMLMaps := for(P:Resources, Links := LinkMap[P.ID]). P.ToPlantUMLMaps(Links)
        PlantUMLLinks := for(P:Resources). P.ToPlantUMLLinks()
        Header := "\n@startuml\n" + "left to right direction\n"
        Footer := "\n@enduml\n"
        Print(Header + PlantUMLParents.Join("\n") + PlantUMLMaps.Join("\n") + PlantUMLLinks.Join("\n") + Footer)

        GameState := game_state:
            Resources := Resources
            ResourceTemplates := NewTemplateMap
            ResourceTypePools := NewResourceTypePools
            StaticResources := NewStaticResources
            StaticTypes := NewStaticTypes
            RelationshipMap := NewRelationshipMap

        for(Device:TableauDevices):
            ResourceID := Device.GetResID()
            SubResourceID := Device.GetSubResID()

            TypeResourceGetter := if (Type := Device.GetPerType()?). ReturnPool(GameState, Type).FN else. ReturnID(ResourceID).FN
            SubTypeResourceGetter := if (SubType := Device.GetPerSubType()?). ReturnPool(GameState, SubType).FN else. ReturnID(SubResourceID).FN
            if (SubType := Device.GetPerSubType()?):
                spawn. PrimeSideEffectForSubtype(GameState, Device, SubType, TypeResourceGetter)
            if (Type := Device.GetPerType()?):
                spawn. PrimeSideEffectForType(GameState, Device, Type, SubTypeResourceGetter)

            spawn. ProcessAllSideEffects(GameState, Device, TypeResourceGetter, SubTypeResourceGetter)

    PrimeSideEffectForSubtype(GameState:game_state, Device:tableau_device, SubType:string, ResourceGetter:type{_():[]string})<suspends>:void=
        loop:
            NewResource := GameState.ResourceAddedEvent(SubType).Await()
            spawn. ProcessAllSideEffects(GameState, Device, ResourceGetter, ReturnID(NewResource).FN)

    PrimeSideEffectForType(GameState:game_state, Device:tableau_device, Type:string, ResourceGetter:type{_():[]string})<suspends>:void=
        loop:
            NewResource := GameState.ResourceAddedEvent(Type).Await()
            spawn. ProcessAllSideEffects(GameState, Device, ReturnID(NewResource).FN, ResourceGetter)

    ProcessAllSideEffects(GameState:game_state, Device:tableau_device, TypeGetter:type{_():[]string}, SubTypeGetter:type{_():[]string})<suspends>:void=
        Types := TypeGetter()
        SubTypes := SubTypeGetter()
        for(ID:Types, SubID:SubTypes):
            spawn. ProcessSideEffects(GameState, Device, ID, SubID)

    ProcessSideEffects(GameState:game_state, Device:tableau_device, ResourceID:string, SubTypeID:string)<suspends>:void=
        sync:
            GameState.AwaitResource(ResourceID)
            GameState.AwaitResource(SubTypeID)
        SubID := if (SubTypeID <> ""). SubTypeID else. ResourceID
        NonDebugSideEffects := Device.GetSideEffects()
        Debugs := for(Property:Device.GetDebugs(), Property <> ""). Debug(Property)
        SideEffects := Concatenate(NonDebugSideEffects, Debugs)

        for (Effect:SideEffects). if (E := debug_pipe[Effect], PropSource := E.PropertySource.TryComplete(ResourceID, SubID)?):
            GameState.PrimeCache(PropSource.ResourceID, PropSource.PropertyID, SubID)
            set E.ResourceID = option. ResourceID
            set E.SubID = option. SubID
            spawn. GameState.SyncStr(PropSource, SubID, E.FN)
        Sleep(0.0)

        for (Effect:SideEffects). if (E := generate_pipe[Effect]). spawn. GameState.AttachGenerator(E.Event)
        Sleep(0.0)
        # TODO: Currently only the player manager needs this to run after the generate pipe side effect
        for (Effect:SideEffects). if (E := first_side_effect[Effect]). spawn. E.FN()
        Sleep(0.0)

        for (Effect:SideEffects):
            # if(Effect.PropertyID <> ""). GameState.PrimeCache(ResourceID, Effect.PropertyID, SubID)
            PP := HardPath(ResourceID, Effect.PropertyID)

            if (E := tap_pipe[Effect]):
                GameState.PrimeCache(ResourceID, Effect.PropertyID, SubID)
                spawn. GameState.OnUpdated(PP, SubID, E.FN)
            if (E := bool_pipe[Effect]):
                GameState.PrimeCache(ResourceID, Effect.PropertyID, SubID)
                spawn. GameState.SyncBool(PP, SubID, E.FN)
            if (E := int_pipe[Effect]):
                GameState.PrimeCache(ResourceID, Effect.PropertyID, SubID)
                spawn. GameState.SyncInt(PP, SubID, E.FN)
            if (E := float_pipe[Effect]):
                GameState.PrimeCache(ResourceID, Effect.PropertyID, SubID)
                spawn. GameState.SyncFloat(PP, SubID, E.FN)
            if (E := str_pipe[Effect], PropSource := E.PropertySource.TryComplete(ResourceID, SubID)?):
                GameState.PrimeCache(PropSource.ResourceID, PropSource.PropertyID, SubID)
                spawn. GameState.SyncStr(PropSource, SubID, E.FN)
            if (E := agent_pipe[Effect], PropSource := E.PropertySource.TryComplete(ResourceID, SubID)?):
                GameState.PrimeCache(PropSource.ResourceID, PropSource.PropertyID, SubID)
                spawn. GameState.SyncAgent(PropSource, SubID, E.FN)
            if (E := msg_pipe[Effect], PropSource := E.PropertySource.TryComplete(ResourceID, SubID)?):
                GameState.PrimeCache(PropSource.ResourceID, PropSource.PropertyID, SubID)
                spawn. GameState.SyncStr(PropSource, SubID, E.FN)
            if (E := vec3_pipe[Effect], PropSource := E.PropertySource.TryComplete(ResourceID, SubID)?):
                GameState.PrimeCache(PropSource.ResourceID, PropSource.PropertyID, SubID)
                spawn. GameState.SyncVec3(PropSource, SubID, E.FN)
            if (E := action_pipe[Effect], PropSource := E.PropertySource.TryComplete(ResourceID, SubID)?):
                spawn. GameState.AttachAction(PropSource, SubID, E.Event)
            if (E := arg_action_pipe[Effect], PropSource := E.PropertySource.TryComplete(ResourceID, SubID)?):
                spawn. GameState.AttachArgAction(PropSource, SubID, E.Event)
            if (E := sync_float_side_effect[Effect]):
                PropSource := HardPath(ResourceID, E.PropertyID)
                spawn. GameState.UpdateFloat(PropSource, SubID, E.From)
            if (E := widget_binding[Effect]):
                spawn. GameState.AddUI(E.Widget, SubID, E.Position)
