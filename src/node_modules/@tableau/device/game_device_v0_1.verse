
using. /Fortnite.com/Devices
using. /Verse.org/Simulation
using. /Verse.org/Simulation/Tags
using. /UnrealEngine.com/Temporary/Diagnostics

using. Banding
using. Vertex

ReturnPool<constructor>(GameState:game_state, Type:string)<transacts> := pool_returner{ GameState := GameState, Type := Type }
pool_returner := class():
    GameState:game_state
    Type:string
    FN<public>():[]string= GameState.ResourceTypePools[Type] or array{}

ReturnID<constructor>(ID:string)<transacts> := id_returner. ID := ID
id_returner := class():
    ID:string
    FN<public>():[]string= array. ID

EnsureID<constructor>(Device:tableau_device)<transacts> := ensure_id. Device := Device
ensure_id := class():
    Device:tableau_device
    FN<public>(Resource:resource)<transacts>:resource=
        if (Device.GetPerType()?). return Resource
        CreateFromTemplate((Resource.ID <> "") or Device.ResourceID, Resource)

MarkStatic<constructor>(Device:tableau_device)<transacts> := mark_static. Device := Device
mark_static := class():
    Device:tableau_device
    FN<public>(Resource:resource)<transacts>:resource=
        if (Device.GetSubResID() = ""). MakeStatic(Resource) else. Resource

game_device_v0_1 := class(creative_device):

    OnBegin<override>()<suspends>:void=
        Globals := map{ "GLOBAL" => CreateGlobalsResource() }

        TableauDevices := LoadTableauDevices(Self)
        Print("Found Devices: {TableauDevices.Length}")
        DeviceResources := CombineAllArrays of for(Device:TableauDevices):
            Raw := Device.GetResources()
            WithID := Raw.Map(EnsureID(Device).FN)
            MarkedStatic := WithID.Map(MarkStatic(Device).FN)
        Print("Device Resources: {DeviceResources.Length}")

        AllResources := CombineAllArrays of array:
            DeviceResources
            array. CreateGlobalsResource()
        Resources := CreateResourceMap of for(Resource:AllResources, ID := Resource.ID):
            (ID, AddProps(Resource, map{ "ID" => Str of ID }))

        ResourceTemplates := CreateMap of for(Resource:AllResources, Resource.ID = "", Type := Resource.Type <> ""):
            Print("Adding Resource Template for {Type}")
            (Type, Resource)

        ResourceIDtoType := CreateMap of for(Resource:AllResources, ID := Resource.ID <> "", Type := Resource.Type <> ""):
            Print("Resource [{ID}] has Type [{Type}]")
            (ID, Type)
        ResourceTypePools := ResourceIDtoType.GroupByValue()
        for(Type->Pool:ResourceTypePools):
            Print("Type [{Type}] has [{Pool.Length}] IDs:")
            for(ID:Pool). Print("    - {ID}")

        StaticResources := CreateMap of for(Resource:AllResources, Resource.Static?, ID := Resource.ID <> ""). (ID, true)
        StaticTypes := CreateMap of for(Resource:AllResources, Resource.Static?, Resource.ID = "", Type := Resource.Type). (Type, true)

        RelationshipMap := CreateMap of for(Device:TableauDevices):
            (Device.ResourceID, array{Device.GetSubResID()})

        GameState := game_state:
            Resources := Resources
            ResourceTemplates := ResourceTemplates
            ResourceTypePools := ResourceTypePools
            StaticResources := StaticResources
            StaticTypes := StaticTypes
            RelationshipMap := RelationshipMap

        for(Device:TableauDevices):
            ResourceID := Device.GetResID()
            SubResourceID := Device.GetSubResID()

            TypeResourceGetter := if (Type := Device.GetPerType()?). ReturnPool(GameState, Type).FN else. ReturnID(ResourceID).FN
            SubTypeResourceGetter := if (SubType := Device.GetPerSubType()?). ReturnPool(GameState, SubType).FN else. ReturnID(SubResourceID).FN
            if (SubType := Device.GetPerSubType()?):
                spawn. PrimeSideEffectForSubtype(GameState, Device, SubType, TypeResourceGetter)
            if (Type := Device.GetPerType()?):
                spawn. PrimeSideEffectForType(GameState, Device, Type, SubTypeResourceGetter)

            spawn. ProcessAllSideEffects(GameState, Device, TypeResourceGetter, SubTypeResourceGetter)

    PrimeSideEffectForSubtype(GameState:game_state, Device:tableau_device, SubType:string, ResourceGetter:type{_():[]string})<suspends>:void=
        loop:
            NewResource := GameState.ResourceAddedEvent(SubType).Await()
            spawn. ProcessAllSideEffects(GameState, Device, ResourceGetter, ReturnID(NewResource).FN)

    PrimeSideEffectForType(GameState:game_state, Device:tableau_device, Type:string, ResourceGetter:type{_():[]string})<suspends>:void=
        loop:
            NewResource := GameState.ResourceAddedEvent(Type).Await()
            spawn. ProcessAllSideEffects(GameState, Device, ReturnID(NewResource).FN, ResourceGetter)

    ProcessAllSideEffects(GameState:game_state, Device:tableau_device, TypeGetter:type{_():[]string}, SubTypeGetter:type{_():[]string})<suspends>:void=
        Types := TypeGetter()
        SubTypes := SubTypeGetter()
        for(ID:Types, SubID:SubTypes):
            spawn. ProcessSideEffects(GameState, Device, ID, SubID)

    ProcessSideEffects(GameState:game_state, Device:tableau_device, ResourceID:string, SubTypeID:string)<suspends>:void=
        sync:
            GameState.AwaitResource(ResourceID)
            GameState.AwaitResource(SubTypeID)
        SubID := if (SubTypeID <> ""). SubTypeID else. ResourceID
        NonDebugSideEffects := Device.GetSideEffects()
        Debugs := for(Property:Device.GetDebugs(), Property <> ""). Debug(Property)
        SideEffects := Concatenate(NonDebugSideEffects, Debugs)

        for (Effect:SideEffects). if (E := debug_pipe[Effect], PropSource := E.PropertySource.TryComplete(ResourceID, SubID)?):
            set E.ResourceID = option. ResourceID
            set E.SubID = option. SubID
            spawn. GameState.SyncStr(PropSource, SubID, E.FN)
        Sleep(0.0)

        for (Effect:SideEffects). if (E := generate_pipe[Effect]). spawn. GameState.AttachGenerator(E.Event)
        Sleep(0.0)
        for (Effect:SideEffects). if (E := first_side_effect[Effect]). spawn. E.FN()
        Sleep(0.0)

        for (Effect:SideEffects):
            if (E := tap_pipe[Effect], PropSource := E.PropertySource.TryComplete(ResourceID, SubID)?):
                spawn. GameState.OnUpdated(PropSource, SubID, E.FN)
            if (E := bool_pipe[Effect], PropSource := E.PropertySource.TryComplete(ResourceID, SubID)?):
                spawn. GameState.SyncBool(PropSource, SubID, E.FN)
            if (E := int_pipe[Effect], PropSource := E.PropertySource.TryComplete(ResourceID, SubID)?):
                spawn. GameState.SyncInt(PropSource, SubID, E.FN)
            if (E := float_pipe[Effect], PropSource := E.PropertySource.TryComplete(ResourceID, SubID)?):
                spawn. GameState.SyncFloat(PropSource, SubID, E.FN)
            if (E := str_pipe[Effect], PropSource := E.PropertySource.TryComplete(ResourceID, SubID)?):
                spawn. GameState.SyncStr(PropSource, SubID, E.FN)
            if (E := agent_pipe[Effect], PropSource := E.PropertySource.TryComplete(ResourceID, SubID)?):
                spawn. GameState.SyncAgent(PropSource, SubID, E.FN)
            if (E := msg_pipe[Effect], PropSource := E.PropertySource.TryComplete(ResourceID, SubID)?):
                spawn. GameState.SyncStr(PropSource, SubID, E.FN)
            if (E := vec3_pipe[Effect], PropSource := E.PropertySource.TryComplete(ResourceID, SubID)?):
                spawn. GameState.SyncVec3(PropSource, SubID, E.FN)
            if (E := action_pipe[Effect], PropSource := E.PropertySource.TryComplete(ResourceID, SubID)?):
                spawn. GameState.AttachAction(PropSource, SubID, E.Event)
            if (E := sync_float_side_effect[Effect]):
                PropSource := HardPath(ResourceID, E.PropertyID)
                spawn. GameState.UpdateFloat(PropSource, SubID, E.From)
            if (E := widget_binding[Effect]):
                spawn. GameState.AddUI(E.Widget, SubID, E.Position)
