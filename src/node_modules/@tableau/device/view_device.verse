
using. /Verse.org/Simulation
using. /Fortnite.com/Devices
using. /Fortnite.com/Characters
using. /UnrealEngine.com/Temporary/SpatialMath

using. Anima
using. Tableau
using. Vertex

rotation_yaw_getter<public> := class():
    Agent<public>:?agent

    GetRotation<public>():vector3= if (F := Agent?.GetFortCharacter[]):
        F.GetViewRotation().ToVector3()
    else. vector3{}

    FN<public>():float=
        Rotation := GetRotation()
        Rotation.X + 180.0

angle_snapper<public> := class():
    Increment<public>:float
    ValueSource<public>:type{_():float}
    RotationSource<public>:type{_():vector3}
    PollingTime<public>:float = 0.0

    var ActiveIncrement<public>:float = 0.0
    var Notis<public>:[float]event() = map{}

    StartSnap<public>:event() = event(){}
    EndSnap<public>:event() = event(){}
    NewAngle<public>:event(float) = event(float){}

    Init()<suspends>:void=
        sync:
            WaitForSnap()
            CalculateOrientation()

    CalculateOrientation()<suspends>:void=
        loop:
            NewValue := ValueSource()
            MidPoint := Increment/2.0
            SnapPoint := (Ceil[(NewValue - MidPoint) / Increment] * Increment) or 0.0
            SnapTest := if (SnapPoint = 360.0). 0.0 else. SnapPoint
            if (ActiveIncrement <> SnapTest):
                set ActiveIncrement = SnapTest
                if (N := Notis[ActiveIncrement]). N.Signal()

            Sleep(PollingTime)

    WhenIncrementEquals<public>(Value:float):event()=
        NewEvent := event(){}
        option. set Notis[Value] = NewEvent
        NewEvent

    SnapTrigger<public>(Value:logic):void= if (Value?). StartSnap.Signal() else. EndSnap.Signal()

    WaitForSnap<public>()<suspends>:void=
        loop:
            StartSnap.Await()
            spawn. Snapping()

    Snapping<public>()<suspends>:void=
        BaseRotation := RotationSource()
        StartingRotation := vector3{ X := BaseRotation.X, Y := -45.0, Z := BaseRotation.Z }
        var LastValue:float = 0.0
        race:
            loop:
                NewRotation := RotationSource()
                ResultWithoutRatio := (StartingRotation) - (NewRotation)
                Result2 := vector3{ X := ResultWithoutRatio.X / 2.0, Y := ResultWithoutRatio.Y, Z := ResultWithoutRatio.Z }
                Rad := ArcTan(Result2.X, Result2.Y)
                Result := (Rad * (180.0/PiFloat)) + 180.0
                FinalValue := if (Result = 360.0). 0.0 else. Result
                if (FinalValue <> LastValue):
                    NewAngle.Signal(FinalValue)
                    set LastValue = FinalValue
                Sleep(0.0)
            EndSnap.Await()

view_device<public> := class(tableau_device):
    @editable IncrementActions:[]string = array{}
    @editable ActiveRadial:prop_path = prop_path{}
    @editable ShouldSnapSource:?prop_path = false

    GetResources<override>():[]resource= array. resource:
        ID := ResourceID
        Props := map:
            "Radial Angle" => Float of 0.0
            "Radial Steps" => Integer of 8
            "Radial Snap" => Integer of (Path("Radial Angle"), "Get Pie Slice", Path("Radial Steps"))
            "Active Radial Snap" => Integer of (Path(ActiveRadial), "If True", Path("Radial Snap"))

    GetSideEffects<override>(State:scoped_state)<suspends>:[]side_effect=
        Increment := 360.0 / (IncrementActions.Length*1.0)
        Agent := State.GetSubAgent("Possessed By").Get()
        YawGetter := rotation_yaw_getter. Agent := Agent
        Snapper := angle_snapper{ Increment := Increment, ValueSource := YawGetter.FN, RotationSource := YawGetter.GetRotation }

        for (Index->ActionID:IncrementActions, TargetIncrement := Index * Increment):
            State.AttachAction(ActionID, Snapper.WhenIncrementEquals(TargetIncrement))

        FilterOptions of array:
            option. StartWith(Snapper.Init)
            option. PushBool(ShouldSnapSource?, Snapper.SnapTrigger)
            option. SyncFloat("Radial Angle", Snapper.NewAngle)
