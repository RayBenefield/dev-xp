
using. /Fortnite.com/Devices
using. /Verse.org/Simulation
using. /Verse.org/Simulation/Tags
using. /UnrealEngine.com/Temporary/Diagnostics

using. Tableau
using. TableauResource

game_device := class(creative_device):

    OnBegin<override>()<suspends>:void=
        ResourceRepository:resource_repository = resource_repository{}
        Dispatcher:dispatcher = dispatcher{}
        EffectorProvider := effector_provider{}
        Commander := commander{}

        GameState := game_state:
            ResourceRepository := ResourceRepository
            Commander := Commander
            EffectorProvider := EffectorProvider

        Effects:[string]effector = map:
            "Is True" => check_effector. GameState := GameState
            "Is False" => check_effector{ GameState := GameState, CheckFalse := true }
            "Make True" => bool_effector. GameState := GameState
            "Make False" => bool_effector{ GameState := GameState, Value := false }
            "Increase" => adjust_effector. GameState := GameState
            "Decrease" => adjust_effector{ GameState := GameState, Sign := sign.Negative }
            "Set" => set_effector. GameState := GameState
            "Create Resource" => create_effector. GameState := GameState
            "Execute Ability" => execute_ability_effector. GameState := GameState
            "Delay" => delay_effector. GameState := GameState
            "Log" => log_effector. GameState := GameState

        for (Name->Effect:Effects). EffectorProvider.Register(Name, Effect)

        SideEffectDevices := LoadSideEffectDevices()
        for(Device:SideEffectDevices). spawn. SetupSideEffects(GameState, Device)
        Print("Play Devices: {SideEffectDevices.Length}")

        ResourceMutator:resource_mutator = resource_mutator:
            GameState := GameState
            Repo := ResourceRepository

        Mutators:[]mutator = array:
            ResourceMutator

        spawn. MutateGameState(Dispatcher, Mutators)
        spawn. PseudoController(Dispatcher, ResourceRepository, Commander)

        ConfigDevices := LoadConfigDevices()
        for (Device:ConfigDevices):
            NewResources := Device.GetResources()
            for (Resource:NewResources). Commander.Create(Resource)
        Print("Logic Devices: {ConfigDevices.Length}")

        PlayerResource := resource:
            ID := "Player1"
            Type := "Player"
            Props := props:
                Static := map:
                    "Possessed By" => prop_agent. Default := option. GetPlayspace().GetPlayers()[0]
        Commander.Create(PlayerResource)

    SetupSideEffects(GameState:game_state, Device:side_effect_device)<suspends>:void=
        if (SubType := Device.GetPerSubType()?, Type := Device.GetPerType()?):
            TypeSideEffectPocessor(GameState, Device, Type, SubType)
        if (SubType := Device.GetPerSubType()?, ResourceID := Device.GetResourceID()?):
            ResourceSideEffectPocessor(GameState, Device, ResourceID, SubType)
        else if (Type := Device.GetPerType()?):
            TypeSideEffectPocessor(GameState, Device, Type)
        else if (ResourceID := Device.GetResourceID()?):
            ResourceSideEffectPocessor(GameState, Device, ResourceID)

    ResourceSideEffectPocessor(GameState:game_state, Device:side_effect_device, ResourceID:string)<suspends>:void=
        GameState.AwaitResource(ResourceID)
        ProcessSideEffects(GameState, Device, ResourceID, "")
    ResourceSideEffectPocessor(GameState:game_state, Device:side_effect_device, ResourceID:string, SubType:string)<suspends>:void=
        var AllSubTypes:[]string = array{}
        var ProcessedPairs:[string]logic = map{}
        loop:
            block:
                NewSubType := GameState.ResourceAddedEvent(SubType).Await()
                set AllSubTypes += array. NewSubType
            for (NewSubType:AllSubTypes):
                if (not ProcessedPairs[ResourceID+" "+NewSubType]):
                    if. set ProcessedPairs[ResourceID+" "+NewSubType] = true
                    spawn. ProcessSideEffects(GameState, Device, ResourceID, NewSubType)

    TypeSideEffectPocessor(GameState:game_state, Device:side_effect_device, Type:string, SubType:string)<suspends>:void=
        var AllTypes:[]string = array{}
        var AllSubTypes:[]string = array{}
        var ProcessedPairs:[string]logic = map{}
        loop:
            race:
                block:
                    NewType := GameState.ResourceAddedEvent(Type).Await()
                    set AllTypes += array. NewType
                block:
                    NewSubType := GameState.ResourceAddedEvent(SubType).Await()
                    set AllSubTypes += array. NewSubType
            for (NewType:AllTypes, NewSubType:AllSubTypes):
                if (not ProcessedPairs[NewType+" "+NewSubType]):
                    if. set ProcessedPairs[NewType+" "+NewSubType] = true
                    spawn. ProcessSideEffects(GameState, Device, NewType, NewSubType)

    TypeSideEffectPocessor(GameState:game_state, Device:side_effect_device, Type:string)<suspends>:void=
        loop:
            ResourceID := GameState.ResourceAddedEvent(Type).Await()
            spawn. ProcessSideEffects(GameState, Device, ResourceID, "")

    ProcessSideEffects(GameState:game_state, Device:side_effect_device, ResourceID:string, SubTypeID:string)<suspends>:void=
        SideEffects := Device.GetSideEffects(GameState, ResourceID, SubTypeID)
        for (Effect:SideEffects):
            Focus := GameState.ResolvePath(ResourceID, Effect.GetFocus(), SubTypeID)
            if (E := tap_side_effect[Effect]):
                spawn. GameState.OnUpdated(Focus.ResourceID, Focus.PropertyID, SubTypeID, E.FN)
            if (E := bool_side_effect[Effect]):
                spawn. GameState.SyncBool(Focus.ResourceID, Focus.PropertyID, SubTypeID, E.FN)
            if (E := int_side_effect[Effect]):
                spawn. GameState.SyncInt(Focus.ResourceID, Focus.PropertyID, SubTypeID, E.FN)
            if (E := num_side_effect[Effect]):
                spawn. GameState.SyncNum(Focus.ResourceID, Focus.PropertyID, SubTypeID, E.FN)
            if (E := str_side_effect[Effect]):
                spawn. GameState.SyncStr(Focus.ResourceID, Focus.PropertyID, SubTypeID, E.FN)
            if (E := vec3_side_effect[Effect]):
                spawn. GameState.SyncVec3(Focus.ResourceID, Focus.PropertyID, SubTypeID, E.FN)

    MutateGameState(Dispatcher:dispatcher, Mutators:[]mutator)<suspends>:void=
        loop:
            DomainEvents := Dispatcher.DomainEvents().Await()
            for (Mutator:Mutators). Mutator.ApplyEvents(DomainEvents)

    PseudoController(Dispatcher:dispatcher, Repo:resource_repository, Commander:commander)<suspends>:void=
        loop:
            race:
                UpdateProperty(Dispatcher, Repo, Commander)
                block:
                    Resource := Commander.CreatedEvent.Await()
                    if (Repo.Add[Resource]):
                        Dispatcher.Dispatch(Ev_ResourceAdded(Resource.ID))

    UpdateProperty(Dispatcher:dispatcher, Repo:resource_repository, Commander:commander)<suspends>:void=
        Command := Commander.FiredEvent.Await()
        ResourceID := Command.Subject
        PropertyID := Command.Property
        PlayerID := Command.Target
        if (Resource:= Repo.GetByID[ResourceID]):
            PropType := Repo.GetPropTypes[ResourceID][PropertyID] or prop_type.Unknown
            case(PropType):
                prop_type.Bool =>
                    Value := Command.Pay.Bool
                    if (NewResource := Resource.SetBoolProperty[PropertyID, PlayerID, Value]):
                        if (Repo.Update[NewResource]). Dispatcher.Dispatch(Ev_PropertyUpdated(ResourceID, PropertyID, PlayerID))
                prop_type.Num =>
                    Value := Command.Pay.Num
                    if (NewResource := Resource.SetNumProperty[PropertyID, PlayerID, Value]):
                        if (Repo.Update[NewResource]). Dispatcher.Dispatch(Ev_PropertyUpdated(ResourceID, PropertyID, PlayerID))
                prop_type.Float =>
                    Value := Command.Pay.Float
                    if (NewResource := Resource.SetFloatProperty[PropertyID, PlayerID, Value]):
                        if (Repo.Update[NewResource]). Dispatcher.Dispatch(Ev_PropertyUpdated(ResourceID, PropertyID, PlayerID))
                prop_type.Str =>
                    Value := Command.Pay.Str
                    if (NewResource := Resource.SetStrProperty[PropertyID, PlayerID, Value]):
                        if (Repo.Update[NewResource]). Dispatcher.Dispatch(Ev_PropertyUpdated(ResourceID, PropertyID, PlayerID))
                prop_type.StatNum =>
                    Value := Command.Pay.Num
                    if (NewResource := Resource.SetStatNumProperty[PropertyID, Value]):
                        if (Repo.Update[NewResource]). Dispatcher.Dispatch(Ev_PropertyUpdated(ResourceID, PropertyID, PlayerID))
                prop_type.StatFloat =>
                    Value := Command.Pay.Float
                    if (NewResource := Resource.SetStatFloatProperty[PropertyID, Value]):
                        if (Repo.Update[NewResource]). Dispatcher.Dispatch(Ev_PropertyUpdated(ResourceID, PropertyID, PlayerID))
                prop_type.StatBool =>
                    Value := Command.Pay.Bool
                    if (NewResource := Resource.SetStatBoolProperty[PropertyID, Value]):
                        if (Repo.Update[NewResource]). Dispatcher.Dispatch(Ev_PropertyUpdated(ResourceID, PropertyID, PlayerID))
                prop_type.StatStr =>
                    Value := Command.Pay.Str
                    if (NewResource := Resource.SetStatStrProperty[PropertyID, Value]):
                        if (Repo.Update[NewResource]). Dispatcher.Dispatch(Ev_PropertyUpdated(ResourceID, PropertyID, PlayerID))
                _ => {}
