
using. /Verse.org/Assets
using. /Verse.org/Simulation
using. /Fortnite.com/Devices
using. /UnrealEngine.com/Assets
using. /Verse.org/Simulation/Tags
using. /Fortnite.com/Devices/CreativeAnimation
using. /UnrealEngine.com/Temporary/SpatialMath

using. Anima
using. Numb
using. Vertex
using. Tableau

tap := type{_():void}
str_tap := type{_(:string):void}
int_tap := type{_(:int):void}
bool_tap := type{_(:logic):void}
float_tap := type{_(:float):void}
float_sustap := type{_(:float)<suspends>:void}
msg_tap := type{_(:message):void}
num_tap := type{_(:num):void}
vec2_tap := type{_(:vector2):void}
vec3_tap := type{_(:vector3):void}
vec3_sustap := type{_(:vector3)<suspends>:void}
str_map := type{_(:string):string}
str_to_msg := type{_(:string):message}

side_effect_device_tag := class(tag){}
side_effect_device<public> := interface:
    GetResourceID<public>()<computes>:?string
    GetPerType<public>()<computes>:?string
    GetPerSubType<public>()<computes>:?string
    GetSideEffects<public>(State:scoped_state)<suspends>:[]side_effect

LoadSideEffectDevices<public>():[]side_effect_device=
    TaggedDevices := GetCreativeObjectsWithTag(side_effect_device_tag{})
    for(Index -> Tagged : TaggedDevices, Device := side_effect_device[Tagged]). Device

side_effect<public> := interface(). GetPropertyID<public>()<computes>:string
first_side_effect<public> := interface(side_effect). FN<public>()<suspends>:void
tap_side_effect<public> := interface(side_effect). FN<public>()<suspends>:void
bool_side_effect<public> := interface(side_effect). FN<public>(Value:logic)<suspends>:void
int_side_effect<public> := interface(side_effect). FN<public>(Value:int)<suspends>:void
float_side_effect<public> := interface(side_effect). FN<public>(Value:float)<suspends>:void
num_side_effect<public> := interface(side_effect). FN<public>(Value:num)<suspends>:void
str_side_effect<public> := interface(side_effect). FN<public>(Value:string)<suspends>:void
vec3_side_effect<public> := interface(side_effect). FN<public>(Value:vector3)<suspends>:void

IdentityStr(Str:string):string = Str

PushToMsg<public><constructor>(PropertyID:string, To:msg_tap) := str_to_msg_pipe:
    PropertyID := PropertyID
    To := To
    From := IdentityStr
PushToMsg<public><constructor>(PropertyID:string, From:str_map, To:msg_tap) := str_to_msg_pipe:
    PropertyID := PropertyID
    To := To
    From := From
# REQUEST - Supported by parametrics... message->t
str_to_msg_pipe<public> := class(str_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    To<public>:msg_tap
    From<public>:str_map

    FN<override>(Value:string)<suspends>:void= To(Str2Msg(From(Value)))

First<public><constructor>(To:tap) := first_pipe. To := To
first_pipe<public> := class(first_side_effect):
    GetPropertyID<override>()<computes>:string= ""
    To<public>:tap
    FN<override>()<suspends>:void= To()

Push<public><constructor>(PropertyID:string, To:tap) := tap_pipe{ PropertyID := PropertyID, To := To }
tap_pipe<public> := class(tap_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    To<public>:tap

    FN<override>()<suspends>:void= To()

PushStr<public><constructor>(PropertyID:string, To:str_tap) := str_pipe{ PropertyID := PropertyID, To := To }
str_pipe<public> := class(str_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    To<public>:str_tap

    FN<override>(Value:string)<suspends>:void= To(Value)

PushBool<public><constructor>(PropertyID:string, To:bool_tap) := bool_pipe{ PropertyID := PropertyID, To := To }
bool_pipe<public> := class(bool_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    To<public>:bool_tap

    FN<override>(Value:logic)<suspends>:void= To(Value)

PushFloat<public><constructor>(PropertyID:string, To:float_tap) := float_pipe{ PropertyID := PropertyID, To := To }
float_pipe<public> := class(float_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID
    To<public>:float_tap
    FN<override>(Value:float)<suspends>:void= To(Value)
PushSusFloat<public><constructor>(PropertyID:string, To:float_sustap) := float_suspipe{ PropertyID := PropertyID, To := To }
float_suspipe<public> := class(float_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID
    To<public>:float_sustap
    FN<override>(Value:float)<suspends>:void= To(Value)

PushVec3<public><constructor>(PropertyID:string, To:vec3_tap) := vec3_pipe{ PropertyID := PropertyID, To := To }
vec3_pipe<public> := class(vec3_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID
    To<public>:vec3_tap
    FN<override>(Value:vector3)<suspends>:void= To(Value)
PushSusVec3<public><constructor>(PropertyID:string, To:vec3_sustap) := vec3_suspipe{ PropertyID := PropertyID, To := To }
vec3_suspipe<public> := class(vec3_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID
    To<public>:vec3_sustap
    FN<override>(Value:vector3)<suspends>:void= To(Value)

Debug<public><constructor>(PropertyID:string) := debug_pipe. PropertyID := PropertyID
Debug<public><constructor>(PropertyID:string, Label:string) := debug_pipe{ PropertyID := PropertyID, Label := option. Label }
debug_pipe<public> := class(str_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    Label<public>:?string = false

    FN<override>(Value:string)<suspends>:void= Print("[{Label? or PropertyID}] {Value}")

toggle_prop<public> := class(bool_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    Prop<public>:?creative_prop = false

    FN<override>(Value:logic)<suspends>:void= if (P := Prop?):
        if (Value?). P.Show() else. P.Hide()

toggle_material<public> := class(bool_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    Prop<public>:?creative_prop = false
    True<public>:material
    False<public>:material

    FN<override>(Value:logic)<suspends>:void= if (P := Prop?):
        if (Value?). P.SetMaterial(True) else. P.SetMaterial(False)

toggle_animation<public> := class(bool_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    Prop<public>:?creative_prop = false
    True<public>:[]keyframe_delta = array{}
    False<public>:[]keyframe_delta = array{}
    Mode<public>:animation_mode = animation_mode.OneShot
    Reset<public>:logic = true

    var ResetAnima:?frame = false

    FN<override>(Value:logic)<suspends>:void= if (P := Prop?, A := P.GetAnimationController[]):
        Frames := if (Value?). True else. False
        WithReset := if (F := ResetAnima?). Concatenate(array. F.Delta(P.GetTransform()), Frames)
        else. Frames

        A.SetAnimation(WithReset, ?Mode := Mode)

    block:
        if (Reset?, P := Prop?):
            Transform := P.GetTransform()
            set ResetAnima = option. ResetFrame(Transform)

toggle_anim<public> := class(bool_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    Prop<public>:type{_()<transacts>:?creative_prop}
    True<public>:[]frame = array{}
    False<public>:[]frame = array{}
    Mode<public>:animation_mode = animation_mode.OneShot
    Reset<public>:logic = true

    var ResetAnima:?frame = false

    FN<override>(Value:logic)<suspends>:void= if (P := Prop()?, A := P.GetAnimationController[]):
        Frames := if (Value?). True else. False
        Sleep(0.1)
        A.SetAnimation(Frames.Deltas(P.GetTransform()), ?Mode := Mode)
        A.Play()

set_mesh<public> := class(int_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    Prop<public>:?creative_prop = false
    AllMeshes<public>:[]mesh = array{}

    FN<override>(Value:int)<suspends>:void= if (P := Prop?):
        if (Mesh := AllMeshes[Value]). P.SetMesh(Mesh)

play_animation<public> := class(tap_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    Prop<public>:?creative_prop = false

    FN<override>()<suspends>:void= if (P := Prop?, A := P.GetAnimationController[]):
        A.Play()

move<public> := class(vec3_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    Prop<public>:?creative_prop = false
    Time<public>:float = 0.0

    FN<override>(Value:vector3)<suspends>:void= if (P := Prop?):
        P.MoveTo(Value, IdentityRotation(), Time)

spawn_vfx<public> := class(tap_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    VFX<public>:?particle_system = false
    Location<public>:vector3 = vector3{}

    FN<override>()<suspends>:void= if (V := VFX?):
        SpawnParticleSystem(V, Location)
