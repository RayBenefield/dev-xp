
using. /Verse.org/Assets
using. /Verse.org/Simulation
using. /Fortnite.com/Devices
using. /UnrealEngine.com/Assets
using. /Verse.org/Simulation/Tags
using. /UnrealEngine.com/Temporary/UI
using. /Fortnite.com/Devices/CreativeAnimation
using. /UnrealEngine.com/Temporary/SpatialMath

using. Anima
using. Banding
using. Numb
using. Vertex
using. Tableau

tap := type{_()<suspends>:void}
str_tap := type{_(:string)<suspends>:void}
int_tap := type{_(:int)<suspends>:void}
bool_tap := type{_(:logic)<suspends>:void}
float_tap := type{_(:float)<suspends>:void}
msg_tap := type{_(:message)<suspends>:void}
num_tap := type{_(:num)<suspends>:void}
vec2_tap := type{_(:vector2)<suspends>:void}
vec3_tap := type{_(:vector3)<suspends>:void}

str_map := type{_(:string)<suspends>:string}

side_effect_device_tag := class(tag){}
side_effect_device<public> := interface:
    GetResourceID<public>()<computes>:?string
    GetPerType<public>()<computes>:?string
    GetPerSubType<public>()<computes>:?string
    GetSideEffects<public>(State:scoped_state)<suspends>:[]side_effect

LoadSideEffectDevices<public>():[]side_effect_device=
    TaggedDevices := GetCreativeObjectsWithTag(side_effect_device_tag{})
    for(Index -> Tagged : TaggedDevices, Device := side_effect_device[Tagged]). Device

side_effect<public> := interface(). GetPropertyID<public>()<computes>:string
first_side_effect<public> := interface(side_effect). FN<public>()<suspends>:void
tap_side_effect<public> := interface(side_effect). FN<public>()<suspends>:void
bool_side_effect<public> := interface(side_effect). FN<public>(Value:logic)<suspends>:void
int_side_effect<public> := interface(side_effect). FN<public>(Value:int)<suspends>:void
float_side_effect<public> := interface(side_effect). FN<public>(Value:float)<suspends>:void
num_side_effect<public> := interface(side_effect). FN<public>(Value:num)<suspends>:void
str_side_effect<public> := interface(side_effect). FN<public>(Value:string)<suspends>:void
vec3_side_effect<public> := interface(side_effect). FN<public>(Value:vector3)<suspends>:void

Identity(Value:t where t:type):t = Value

PushMsg<public><constructor>(PropertyID:string, To:msg_tap) := str_to_msg_pipe:
    PropertyID := PropertyID
    To := To
    From := Identity
PushMsg<public><constructor>(PropertyID:string, From:str_map, To:msg_tap) := str_to_msg_pipe:
    PropertyID := PropertyID
    To := To
    From := From
# REQUEST - Supported by parametrics... message->t
str_to_msg_pipe<public> := class(str_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    To<public>:msg_tap
    From<public>:str_map

    FN<override>(Value:string)<suspends>:void= To(Str2Msg(From(Value)))

First<public><constructor>(To:tap) := first_pipe. To := To
first_pipe<public> := class(first_side_effect):
    GetPropertyID<override>()<computes>:string= ""
    To<public>:tap
    FN<override>()<suspends>:void= To()

Push<public><constructor>(PropertyID:string, To:tap) := tap_pipe{ PropertyID := PropertyID, To := To }
tap_pipe<public> := class(tap_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    To<public>:tap

    FN<override>()<suspends>:void= To()

PushStr<public><constructor>(PropertyID:string, To:str_tap) := str_pipe{ PropertyID := PropertyID, To := To }
str_pipe<public> := class(str_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    To<public>:str_tap

    FN<override>(Value:string)<suspends>:void= To(Value)

PushBool<public><constructor>(PropertyID:string, To:bool_tap) := bool_pipe{ PropertyID := PropertyID, To := To }
bool_pipe<public> := class(bool_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    To<public>:bool_tap

    FN<override>(Value:logic)<suspends>:void= To(Value)

PushFloat<public><constructor>(PropertyID:string, To:float_tap) := float_pipe{ PropertyID := PropertyID, To := To }
float_pipe<public> := class(float_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID
    To<public>:float_tap
    FN<override>(Value:float)<suspends>:void= To(Value)

PushVec3<public><constructor>(PropertyID:string, To:vec3_tap) := vec3_pipe{ PropertyID := PropertyID, To := To }
vec3_pipe<public> := class(vec3_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID
    To<public>:vec3_tap
    var Latest:?vector3 = false
    FN<override>(Value:vector3)<suspends>:void=
        if (not Latest?):
            To(Value)
            set Latest = option. Value
            return

        if (L := Latest?, not IsAlmostEqual[Value, L, 0.01]):
            set Latest = option. Value
            To(Value)

Debug<public><constructor>(PropertyID:string) := debug_pipe. PropertyID := PropertyID
Debug<public><constructor>(PropertyID:string, Label:string) := debug_pipe{ PropertyID := PropertyID, Label := option. Label }
debug_pipe<public> := class(str_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    Label<public>:?string = false

    FN<override>(Value:string)<suspends>:void= Print("[{Label? or PropertyID}] {Value}")

toggle_prop<public> := class(bool_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    Prop<public>:?creative_prop = false

    FN<override>(Value:logic)<suspends>:void= if (P := Prop?):
        if (Value?). P.Show() else. P.Hide()

toggle_material<public> := class(bool_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    Prop<public>:?creative_prop = false
    True<public>:material
    False<public>:material

    FN<override>(Value:logic)<suspends>:void= if (P := Prop?):
        if (Value?). P.SetMaterial(True) else. P.SetMaterial(False)

toggle_animation<public> := class(bool_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    Prop<public>:?creative_prop = false
    True<public>:[]keyframe_delta = array{}
    False<public>:[]keyframe_delta = array{}
    Mode<public>:animation_mode = animation_mode.OneShot
    Reset<public>:logic = true

    var ResetAnima:?frame = false

    FN<override>(Value:logic)<suspends>:void= if (P := Prop?, A := P.GetAnimationController[]):
        Frames := if (Value?). True else. False
        WithReset := if (F := ResetAnima?). Concatenate(array. F.Delta(P.GetTransform()), Frames)
        else. Frames

        A.SetAnimation(WithReset, ?Mode := Mode)

    block:
        if (Reset?, P := Prop?):
            Transform := P.GetTransform()
            set ResetAnima = option. ResetFrame(Transform)

set_mesh<public> := class(int_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    Prop<public>:?creative_prop = false
    AllMeshes<public>:[]mesh = array{}

    FN<override>(Value:int)<suspends>:void= if (P := Prop?):
        if (Mesh := AllMeshes[Value]). P.SetMesh(Mesh)

play_animation<public> := class(tap_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    Prop<public>:?creative_prop = false

    FN<override>()<suspends>:void= if (P := Prop?, A := P.GetAnimationController[]):
        A.Play()

move<public> := class(vec3_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    Prop<public>:?creative_prop = false
    Time<public>:float = 0.0

    FN<override>(Value:vector3)<suspends>:void= if (P := Prop?):
        P.MoveTo(Value, IdentityRotation(), Time)

spawn_vfx<public> := class(tap_side_effect):
    PropertyID<public>:string
    GetPropertyID<override>()<computes>:string= PropertyID

    VFX<public>:?particle_system = false
    Location<public>:vector3 = vector3{}

    FN<override>()<suspends>:void= if (V := VFX?):
        SpawnParticleSystem(V, Location)

<#>
    New Side Effects that are subclasses

Toggle<public><constructor>(Prop:?creative_prop) := toggle_prop. Prop := Prop
toggle_prop<public> := class():
    Prop<public>:?creative_prop = false
    FN<public>(Value:logic):void= if (P := Prop?):
        if (Value?). P.Show() else. P.Hide()

Move<public><constructor>(Prop:?creative_prop, Time:float) := move_prop{ Prop := Prop, Time := Time }
Move<public><constructor>(Prop:?creative_prop, Time:float, Offset:vector3) := move_prop{ Prop := Prop, Time := Time, Offset := Offset }
move_prop<public> := class():
    Prop<public>:?creative_prop = false
    Time<public>:float = 0.0
    Offset<public>:vector3 = vector3{}
    FN<public>(Value:vector3)<suspends>:void= if (P := Prop?):
        P.MoveTo(Value + Offset, P.GetTransform().Rotation, Time)

SetLocation<public><constructor>(Prop:?creative_prop) := set_location_fn. Prop := Prop
set_location_fn<public> := class():
    Prop<public>:?creative_prop
    FN<public>(Value:vector3):void= if (P := Prop?):
        if. P.TeleportTo[Value, P.GetTransform().Rotation]

tex_tap := type{_(:texture):void}
SetTexture<public><constructor>(Setter:tex_tap, TexMap:[string]texture, Default:texture) := set_texture_fn{ Setter := Setter, TexMap := TexMap, Default := Default }
set_texture_fn<public> := class():
    Setter<public>:tex_tap
    TexMap<public>:[string]texture
    Default<public>:texture
    FN<public>(Key:string):void= Setter(TexMap[Key] or Default)

SetText<public><constructor>(Text:text_base) := set_text. Text := Text
set_text<public> := class():
    Text<public>:text_base
    FN<public>(Value:message):void= Text.SetText(Value)

SetText<public><constructor>(Billboard:billboard_device) := set_billboard_text. Billboard := Billboard
set_billboard_text<public> := class():
    Billboard<public>:billboard_device
    FN<public>(Value:message):void= Billboard.SetText(Value)

SetVisibility<public><constructor>(Widget:widget) := set_visibility. Widget:= Widget
set_visibility<public> := class():
    Widget<public>:widget
    FN<public>(Value:logic):void=
        Visibility := if (Value?). widget_visibility.Visible else. widget_visibility.Collapsed
        Widget.SetVisibility(Visibility)

SetEnabled<public><constructor>(Widget:widget) := set_enabled. Widget:= Widget
set_enabled<public> := class():
    Widget<public>:widget
    FN<public>(Value:logic):void= Widget.SetEnabled(Value)

<#>
    Side Effect Modifiers

Wait<public><constructor>(Time:float) := wait. Time := Time
wait<public> := class():
    Time<public>:float
    FN<public>(Value:t where t:type)<suspends>:t= { Sleep(Time); return Value; }
