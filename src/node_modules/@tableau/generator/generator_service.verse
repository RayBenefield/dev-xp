using { Tableau }
using { TableauParticipant }

Ev_GenPurchased<constructor>(Type:entity, ID:int) := domain_event:
    Entity := Type
    EntityID := ID
    Event := ev_generator_purchased{}

gen_int_lens := type{_(:generator):[]int}
gen_num_lens := type{_(:generator):[]num}

generator_service<public> := class(service):
    Repo<public>:generator_repository
    ParticipantRepo<public>:participant_repository
    EffectProvider<public>:effect_provider

    Buy<public>(GeneratorID:int, BuyerID:int):[]domain_event=
        var DomainEvents:[]domain_event = array{}
        if:
            Gen := Repo.GetByID[GeneratorID]
        then:
            # Required Generators
            if (not HasRequiredGenerators[Repo, Gen, BuyerID]). return DomainEvents

            if (Cost := Gen.Cost?):
                if:
                    Buyer := ParticipantRepo.GetByID[BuyerID]
                    Amount := Buyer.GetResource(Cost.Type)
                    Amount.GreaterThanOrEqual[Cost.Amount]
                then:
                    # TODO: Move Repo update to actual domain event generation
                    if (NewParticipant := Buyer.RemoveResources[Cost.Type, Cost.Amount]):
                        if (ParticipantRepo.Update[NewParticipant]) {}
                else:
                    return DomainEvents

            if (NewGenerator := Gen.IncreaseCount[BuyerID]):
                if (Repo.Update[NewGenerator]):
                    set DomainEvents += array:
                        Ev_GenPurchased(entity_generator{}, Gen.ID)
                        Ev_GenPurchased(entity_participant{}, BuyerID)

        return DomainEvents

    #
    # EXPERIMENTAL
    #
    Collect<public>():[]domain_event=
        var DomainEvents:[]domain_event = array{}

        Gens := Repo.GetAll()
        for(Gen:Gens, Abilities := Gen.Abilities, Ability:Abilities):
            var LastCommandModification:command = GeneratorAbilityToCommand(Ability, Gen)
            for (Effect:LastCommandModification.AfterEffects):
                set LastCommandModification = Effect.Play(LastCommandModification)

        return DomainEvents

    Lens_GeneratorID(Gen:generator):[]int = array. Gen.ID
    Lens_GeneratorResourceID(Gen:generator):[]int = if (ResID := Gen.ResourceID?). array. ResID else. array {}
    # TODO: Add as generator domain object function
    Lens_GeneratorAllOwners(Gen:generator):[]int = for(Owner->Count : Gen.Counts). Owner
    Lens_GeneratorProductionRate(Gen:generator):[]num = array. Gen.Production

    GeneratorAbilityToCommand<public>(Ability:generator_ability, Gen:generator):command=
        IntLenses:[generator_int_lenses]gen_int_lens = map:
            generator_int_lenses.ID => Lens_GeneratorID
            generator_int_lenses.ResourceID => Lens_GeneratorResourceID
            generator_int_lenses.AllOwners => Lens_GeneratorAllOwners
        NumLenses:[generator_num_lenses]gen_num_lens = map:
            generator_num_lenses.ProductionRate => Lens_GeneratorProductionRate

        return if:
            SubjectLens := IntLenses[Ability.Subjects]
            TargetLens := IntLenses[Ability.Targets]
            MagnitudeLens := NumLenses[Ability.Magnitudes]
        then:
            command:
                Subjects := SubjectLens(Gen)
                Targets := TargetLens(Gen)
                Magnitudes := MagnitudeLens(Gen)
                AfterEffects := for(Eff:Ability.AfterEffects, Effect := EffectProvider.Get[Eff]). Effect
        else:
            command{}

HasRequiredGenerators<public>(Repo:generator_repository, Gen:generator, ParticipantID:int)<decides><transacts>:int=
    NotOwned := for (Required:Gen.Required?, not Repo.OwnsGenerator[ParticipantID, Required]). Required
    NotOwned.Length <= 0

# TODO: Add tests for all the SHOULDs below
ShouldBeBuyable<public>(Repo:generator_repository, Gen:generator, ParticipantID:int)<decides><transacts>:void=
    HasRequiredGenerators[Repo, Gen, ParticipantID]
    not Gen.IsMaxed[ParticipantID]

ShouldBeBuyableNow<public>(Repo:generator_repository, Gen:generator, OldGen:generator, ParticipantID:int)<decides><transacts>:void=
    not HasRequiredGenerators[Repo, OldGen, ParticipantID]
    HasRequiredGenerators[Repo, Gen, ParticipantID]
    not Gen.IsMaxed[ParticipantID]

ShouldBeBoughtNow<public>(Repo:generator_repository, Gen:generator, OldGen:generator, ParticipantID:int)<decides><transacts>:void=
    HasRequiredGenerators[Repo, Gen, ParticipantID]
    not OldGen.IsMaxed[ParticipantID]
    Gen.IsMaxed[ParticipantID]
