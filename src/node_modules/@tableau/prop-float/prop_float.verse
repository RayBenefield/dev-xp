
using. /Verse.org/Random
using. /Verse.org/Simulation
using. /UnrealEngine.com/Temporary/SpatialMath

using. Goo
using. Numb

IntToFloat(Value:int)<transacts>:float= Value*1.0
FloatMultiply(First:float, Second:float)<transacts>:float= First * Second
FloatDivide(First:float, Second:float)<transacts>:float= if (Second <> 0.0). First / Second else. 0.0
FloatNegate(Value:float)<transacts>:float= Value * -1.0
NumToFloat<public>(Value:num)<transacts>:float= Value.Value * Pow(10.0, Value.Exponent * 1.0)
RandFloat(MaxRange:float):float = GetRandomFloat(0.0, MaxRange)
AddFloat(First:float, Second:float)<computes>:float = First + Second
BoolToFloat<public>(Value:logic)<transacts>:float= if(Value?). 1.0 else. 0.0
StrToFloat<public>(Value:string)<transacts>:float= if(Value <> ""). 1.0 else. 0.0
FloatLerp(Values:vector2, Delta:float)<computes><reads>:float= Lerp(Values.X, Values.Y, Delta)
GetVec2X(Value:vector2)<computes>:float= Value.X
GetVec2Y(Value:vector2)<computes>:float= Value.Y

float_plug<public> := class<concrete>():
    @editable Default:float = 0.0
    @editable Source:?prop_path = false
Float<public>(Plug:float_plug)<transacts>:prop_float := (Float of Plug.Source?) or (Float of Plug.Default)

Float<public><constructor>(Default:float)<transacts> := prop_float. Default := Default
Float<public><constructor>(Focus:half_path)<transacts> := prop_float. Focus := Focus
Float<public><constructor>(Focus:prop_path)<transacts> := prop_float. Focus := Focus.ToPath()
Float<public><constructor>(Focus:half_path, FN:string)<transacts> := prop_float{ Focus := Focus, FN := FN }
Float<public><constructor>(FN:string, Focus:half_path)<transacts> := prop_float{ Focus := Focus, FN := FN }
Float<public><constructor>(Focus:half_path, FN:string, Tweak:half_path)<transacts> := prop_float{ Focus := Focus, FN := FN, Tweak := Tweak }
Float<public><constructor>(Focus:prop_path, FN:string, Tweak:prop_path)<transacts> := prop_float{ Focus := Focus.ToPath(), FN := FN, Tweak := Tweak.ToPath() }
MaybeFloat<public><constructor>(Focus:?prop_path)<transacts> := prop_float. Focus := Focus?.ToPath() or EmptyPath()

PropFloat<public><constructor>(ResourceID:string, PropertyID:string, Type:prop_type)<transacts> := prop_float{ Focus := Path(ResourceID, PropertyID), Type := Type }
prop_float<public> := class<concrete>(prop):
    @editable Type<override>:prop_type = prop_type.FloatType
    @editable Default<public>:float = 0.0
    ValueFor<public>(State:scoped_state):float_goo= case(FN):
        "+" => FloatGoo(Computed(State.ToFloat(Focus), State.ToFloat(Tweak), AddFloat))
        "*" => FloatGoo(Computed(State.ToFloat(Focus), State.ToFloat(Tweak), FloatMultiply))
        "Divide" => FloatGoo(Computed(State.ToFloat(Focus), State.ToFloat(Tweak), FloatDivide))
        "Negate" => FloatGoo(Map(State.ToFloat(Focus), FloatNegate))
        "Random" => FloatGoo(Map(State.ToFloat(Focus), RandFloat))
        "Lerp" => FloatGoo(Computed(State.ToVec2(Focus), State.ToFloat(Tweak), FloatLerp))
        "Vec2 X" => FloatGoo(Map(State.ToVec2(Focus), GetVec2X))
        "Vec2 Y" => FloatGoo(Map(State.ToVec2(Focus), GetVec2Y))
        _ => case(Type):
            prop_type.NumType => FloatGoo(Map(State.ToNum(Focus), NumToFloat))
            prop_type.IntegerType => FloatGoo(Map(State.ToInt(Focus), IntToFloat))
            prop_type.BoolType => FloatGoo(Map(State.ToBool(Focus), BoolToFloat))
            prop_type.StrType => FloatGoo(Map(State.ToStr(Focus), StrToFloat))
            _ => if (not Focus.Empty[]). State.ToFloat(Focus)
            else. FloatGoo(Default)
