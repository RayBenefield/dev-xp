
using. /Verse.org/Assets
using. /Verse.org/Simulation
using. /Fortnite.com/Devices
using. /Verse.org/Concurrency
using. /UnrealEngine.com/Assets
using. /Verse.org/Simulation/Tags
using. /UnrealEngine.com/Temporary/UI
using. /Fortnite.com/Devices/CreativeAnimation
using. /UnrealEngine.com/Temporary/SpatialMath

using. Banding
using. Numb
using. Vertex

tap := type{_()<suspends>:void}
str_tap := type{_(:string)<suspends>:void}
int_tap := type{_(:int)<suspends>:void}
bool_tap := type{_(:logic)<suspends>:void}
float_tap := type{_(:float)<suspends>:void}
msg_tap := type{_(:message)<suspends>:void}
num_tap := type{_(:num)<suspends>:void}
agent_tap := type{_(:?agent)<suspends>:void}
vec2_tap := type{_(:vector2)<suspends>:void}
vec3_tap := type{_(:vector3)<suspends>:void}

bool_map := type{_(:logic)<suspends>:logic}
str_map := type{_(:string)<suspends>:string}
int_map := type{_(:int)<suspends>:int}
float_map := type{_(:float)<suspends>:float}
vec3_map := type{_(:vector3)<suspends>:vector3}

side_effect<public> := interface(). PropertyID<public>:string
first_side_effect<public> := interface(side_effect). FN<public>()<suspends>:void
tap_side_effect<public> := interface(side_effect). FN<public>()<suspends>:void
bool_side_effect<public> := interface(side_effect). FN<public>(Value:logic)<suspends>:void
int_side_effect<public> := interface(side_effect). FN<public>(Value:int)<suspends>:void
float_side_effect<public> := interface(side_effect). FN<public>(Value:float)<suspends>:void
str_side_effect<public> := interface(side_effect). FN<public>(Value:string)<suspends>:void
vec3_side_effect<public> := interface(side_effect). FN<public>(Value:vector3)<suspends>:void
agent_side_effect<public> := interface(side_effect). FN<public>(Value:?agent)<suspends>:void
attach_side_effect<public> := interface(side_effect){}
attach_arg_side_effect<public> := interface(side_effect){}
generate_side_effect<public> := interface(side_effect){}

SyncFloat<public><constructor>(PropertyID:string, From:event(float))<transacts> := sync_float_side_effect{ PropertyID := PropertyID, From := From }
sync_float_side_effect<public> := class(side_effect):
    PropertyID<override>:string = ""
    From<public>:event(float)

Identity(Value:t where t:type):t = Value

StartWith<public><constructor>(To:tap)<transacts> := first_pipe. To := To
first_pipe<public> := class(first_side_effect):
    PropertyID<override>:string = ""
    To<public>:tap
    FN<override>()<suspends>:void= To()

Attach<public><constructor>(ActionID:string, Event:awaitable(t) where t:type)<transacts> := action_pipe{ PropertySource := Path(ActionID), Event := Event }
Attach<public><constructor>(ActionPath:prop_path, Event:awaitable(t) where t:type)<transacts> := action_pipe{ PropertySource := Path(ActionPath), Event := Event }
action_pipe<public> := class(attach_side_effect):
    PropertyID<override>:string = ""
    PropertySource<public>:half_path
    Event<public>:awaitable()

AttachWithArg<public><constructor>(ActionID:string, Event:awaitable(prop_path))<transacts> := arg_action_pipe{ PropertySource := Path(ActionID), Event := Event }
AttachWithArg<public><constructor>(ActionPath:prop_path, Event:awaitable(prop_path))<transacts> := arg_action_pipe{ PropertySource := Path(ActionPath), Event := Event }
arg_action_pipe<public> := class(attach_arg_side_effect):
    PropertyID<override>:string = ""
    PropertySource<public>:half_path
    Event<public>:awaitable(prop_path)

Generate<public><constructor>(Event:awaitable(resource))<transacts> := generate_pipe{ Event := Event }
generate_pipe<public> := class(generate_side_effect):
    PropertyID<override>:string = ""
    Event<public>:awaitable(resource)

Push<public><constructor>(PropertyID:string, To:tap)<transacts> := tap_pipe{ PropertyID := PropertyID, To := To }
tap_pipe<public> := class(tap_side_effect):
    PropertyID<override>:string = ""
    To<public>:tap
    FN<override>()<suspends>:void= To()

PushStr<public><constructor>(PropertyID:string, To:str_tap)<transacts> := str_pipe{ PropertyID := PropertyID, To := To }
str_pipe<public> := class(str_side_effect):
    PropertyID<override>:string = ""
    To<public>:str_tap
    FN<override>(Value:string)<suspends>:void= To(Value)

PushBool<public><constructor>(PropertyID:string, To:bool_tap)<transacts> := bool_pipe{ PropertyID := PropertyID, To := To }
bool_pipe<public> := class(bool_side_effect):
    PropertyID<override>:string = ""
    To<public>:bool_tap
    FN<override>(Value:logic)<suspends>:void= To(Value)

PushFloat<public><constructor>(PropertyID:string, To:float_tap)<transacts> := float_pipe{ PropertyID := PropertyID, To := To }
float_pipe<public> := class(float_side_effect):
    PropertyID<override>:string = ""
    To<public>:float_tap
    FN<override>(Value:float)<suspends>:void= To(Value)

PushInt<public><constructor>(PropertyID:string, To:int_tap)<transacts> := int_pipe{ PropertyID := PropertyID, To := To }
int_pipe<public> := class(int_side_effect):
    PropertyID<override>:string = ""
    To<public>:int_tap
    FN<override>(Value:int)<suspends>:void= To(Value)

PushAgent<public><constructor>(PropertyID:string, To:agent_tap)<transacts> := agent_pipe{ PropertyID := PropertyID, To := To }
agent_pipe<public> := class(agent_side_effect):
    PropertyID<override>:string = ""
    To<public>:agent_tap
    FN<override>(Value:?agent)<suspends>:void= To(Value)

PushVec3<public><constructor>(PropertyID:string, To:vec3_tap)<transacts> := vec3_pipe{ PropertySource := Path(PropertyID), To := To }
PushVec3<public><constructor>(PropertyID:string, From:vec3_map, To:vec3_tap)<transacts> := vec3_pipe{ PropertySource := Path(PropertyID), From := From, To := To }
PushVec3<public><constructor>(PropertySource:prop_path, To:vec3_tap)<transacts> := vec3_pipe{ PropertySource := Path(PropertySource), To := To }
PushVec3<public><constructor>(PropertySource:prop_path, From:vec3_map, To:vec3_tap)<transacts> := vec3_pipe{ PropertySource := Path(PropertySource), From := From, To := To }
vec3_pipe<public> := class(vec3_side_effect):
    PropertyID<override>:string = ""
    PropertySource<public>:half_path
    To<public>:vec3_tap
    From<public>:vec3_map = Identity
    var Latest:?vector3 = false
    FN<override>(Value:vector3)<suspends>:void=
        if ((not Latest?) or (not IsAlmostEqual[Value, Latest?, 0.01])):
            To(From(Value))
            set Latest = option. Value

PushMsg<public><constructor>(PropertyID:string, To:msg_tap)<transacts> := msg_pipe{ PropertySource := Path(PropertyID), To := To }
PushMsg<public><constructor>(PropertyID:string, From:str_map, To:msg_tap)<transacts> := msg_pipe{ PropertySource := Path(PropertyID), To := To, From := From }
PushMsg<public><constructor>(PropertySource:prop_path, To:msg_tap)<transacts> := msg_pipe{ PropertySource := Path(PropertySource), To := To }
PushMsg<public><constructor>(PropertySource:prop_path, From:str_map, To:msg_tap)<transacts> := msg_pipe{ PropertySource := Path(PropertySource), From := From, To := To }
# REQUEST - Supported by parametrics... message->t
msg_pipe<public> := class(str_side_effect):
    PropertyID<override>:string = ""
    PropertySource<public>:half_path
    To<public>:msg_tap
    From<public>:str_map = Identity
    FN<override>(Value:string)<suspends>:void= To(Str2Msg(From(Value)))

Debug<public><constructor>(PropertyID:string)<transacts> := debug_pipe{ PropertySource := Path(PropertyID) }
Debug<public><constructor>(PropertySource:prop_path)<transacts> := debug_pipe. PropertySource := Path(PropertySource)
Debug<public><constructor>(PropertyID:string, Label:string)<transacts> := debug_pipe{ PropertySource := Path(PropertyID), Label := option. Label }
debug_pipe<public> := class(str_side_effect):
    PropertyID<override>:string = ""
    PropertySource<public>:half_path
    Label<public>:?string = false
    var ResourceID<public>:?string = false
    var SubID<public>:?string = false
    FN<override>(Value:string)<suspends>:void=
        FinalLabel := "[{Label?}]" or "{PropertySource.TryComplete(ResourceID?, SubID?)?}@{SubID?}" or "[{PropertySource.GetKey()}]"
        FinalValue := if(Value <> ""). Value else. "<EMPTY>"
        Print("{FinalLabel} {FinalValue}")

BindWidget<public><constructor>(Widget:widget, Position:canvas_settings)<transacts> := widget_binding{ Widget := Widget, Position := Position }
widget_binding<public> := class(side_effect):
    PropertyID<override>:string = ""
    Widget<public>:widget
    Position<public>:canvas_settings

<#>
    New Side Effects that are subclasses

SpawnVFX<public><constructor>(VFX:?particle_system, Location:vector3)<transacts> := spawn_vfx_fn{ VFX := VFX, Location := Location }
spawn_vfx_fn<public> := class():
    VFX<public>:?particle_system = false
    Location<public>:vector3 = vector3{}
    FN<public>()<suspends>:void= if (V := VFX?). SpawnParticleSystem(V, Location)

tex_tap := type{_(:texture):void}
SetTexture<public><constructor>(Setter:tex_tap, TexMap:[string]texture)<transacts> := set_texture_fn{ Setter := Setter, TexMap := TexMap }
SetTexture<public><constructor>(Setter:tex_tap, TexMap:[string]texture, Default:texture)<transacts> := set_texture_fn{ Setter := Setter, TexMap := TexMap, Default := option. Default }
set_texture_fn<public> := class():
    Setter<public>:tex_tap
    TexMap<public>:[string]texture
    Default<public>:?texture = false
    FN<public>(Key:string)<suspends>:void= if(Texture := TexMap[Key] or Default?). Setter(Texture)

SetScalar<public><constructor>(Setter:float_tap)<transacts> := set_scalar_fn. Setter := Setter
set_scalar_fn<public> := class():
    Setter<public>:float_tap
    FN<public>(Value:float)<suspends>:void= Setter(Value)

SetText<public><constructor>(Text:text_base)<transacts> := set_text. Text := Text
set_text<public> := class():
    Text<public>:text_base
    FN<public>(Value:message):void= Text.SetText(Value)

SetText<public><constructor>(Billboard:billboard_device)<transacts> := set_billboard_text. Billboard := Billboard
set_billboard_text<public> := class():
    Billboard<public>:billboard_device
    FN<public>(Value:message):void= Billboard.SetText(Value)

SetVisibility<public><constructor>(Widget:widget)<transacts> := set_visibility. Widget:= Widget
set_visibility<public> := class():
    Widget<public>:widget
    FN<public>(Value:logic):void=
        Visibility := if (Value?). widget_visibility.Visible else. widget_visibility.Collapsed
        Widget.SetVisibility(Visibility)

SetEnabled<public><constructor>(Widget:widget)<transacts> := set_enabled. Widget:= Widget
set_enabled<public> := class():
    Widget<public>:widget
    FN<public>(Value:logic):void= Widget.SetEnabled(Value)

<#>
    Side Effect Modifiers

Wait<public><constructor>(Time:float)<transacts> := wait. Time := Time
wait<public> := class():
    Time<public>:float
    FN<public>(Value:t where t:type)<suspends>:t= { Sleep(Time); return Value; }

Offsetter<public><constructor>(Amount:vector3)<transacts> := vec3_offsetter. Amount := Amount
vec3_offsetter<public> := class():
    Amount<public>:vector3
    FN<public>(Value:vector3):vector3= Value + Amount

Offsetter<public><constructor>(Amount:float)<transacts> := float_offsetter. Amount := Amount
float_offsetter<public> := class():
    Amount<public>:float
    FN<public>(Value:float):float= Value + Amount
