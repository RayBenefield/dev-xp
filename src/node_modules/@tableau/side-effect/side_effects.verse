
using. /Verse.org/Assets
using. /Verse.org/Simulation
using. /Fortnite.com/Devices
using. /Verse.org/Concurrency
using. /UnrealEngine.com/Assets
using. /Verse.org/Simulation/Tags
using. /UnrealEngine.com/Temporary/UI
using. /Fortnite.com/Devices/CreativeAnimation
using. /UnrealEngine.com/Temporary/SpatialMath

using. Banding
using. Numb
using. Vertex

tap := type{_()<suspends>:void}
str_tap := type{_(:string)<suspends>:void}
int_tap := type{_(:int)<suspends>:void}
bool_tap := type{_(:logic)<suspends>:void}
float_tap := type{_(:float)<suspends>:void}
msg_tap := type{_(:message)<suspends>:void}
num_tap := type{_(:num)<suspends>:void}
vec2_tap := type{_(:vector2)<suspends>:void}
vec3_tap := type{_(:vector3)<suspends>:void}

str_map := type{_(:string)<suspends>:string}
float_map := type{_(:float)<suspends>:float}
vec3_map := type{_(:vector3)<suspends>:vector3}

side_effect<public> := interface(){}
first_side_effect<public> := interface(side_effect). FN<public>()<suspends>:void
tap_side_effect<public> := interface(side_effect). FN<public>()<suspends>:void
bool_side_effect<public> := interface(side_effect). FN<public>(Value:logic)<suspends>:void
float_side_effect<public> := interface(side_effect). FN<public>(Value:float)<suspends>:void
str_side_effect<public> := interface(side_effect). FN<public>(Value:string)<suspends>:void
vec3_side_effect<public> := interface(side_effect). FN<public>(Value:vector3)<suspends>:void
attach_side_effect<public> := interface(side_effect){}

Identity(Value:t where t:type):t = Value

StartWith<public><constructor>(To:tap)<transacts> := first_pipe. To := To
first_pipe<public> := class(first_side_effect):
    To<public>:tap
    FN<override>()<suspends>:void= To()

Attach<public><constructor>(ActionID:string, Event:awaitable(t) where t:type)<transacts> := action_pipe{ PropertySource := Path(ActionID), Event := Event }
action_pipe<public> := class(attach_side_effect):
    PropertySource<public>:half_path
    Event<public>:awaitable()

Push<public><constructor>(PropertyID:string, To:tap)<transacts> := tap_pipe{ PropertySource := Path(PropertyID), To := To }
Push<public><constructor>(PropertySource:prop_path, To:tap)<transacts> := tap_pipe{ PropertySource := Path(PropertySource), To := To }
tap_pipe<public> := class(tap_side_effect):
    PropertySource<public>:half_path
    To<public>:tap
    FN<override>()<suspends>:void= To()

PushStr<public><constructor>(PropertyID:string, To:str_tap)<transacts> := str_pipe{ PropertySource := Path(PropertyID), To := To }
PushStr<public><constructor>(PropertyID:string, From:str_map, To:str_tap)<transacts> := str_pipe{ PropertySource := Path(PropertyID), From := From, To := To }
PushStr<public><constructor>(PropertySource:prop_path, To:str_tap)<transacts> := str_pipe{ PropertySource := Path(PropertySource), To := To }
PushStr<public><constructor>(PropertySource:prop_path, From:str_map, To:str_tap)<transacts> := str_pipe{ PropertySource := Path(PropertySource), From := From, To := To }
str_pipe<public> := class(str_side_effect):
    PropertySource<public>:half_path
    To<public>:str_tap
    From<public>:str_map = Identity
    FN<override>(Value:string)<suspends>:void= To(From(Value))

PushBool<public><constructor>(PropertyID:string, To:bool_tap)<transacts> := bool_pipe{ PropertySource := Path(PropertyID), To := To }
PushBool<public><constructor>(PropertySource:prop_path, To:bool_tap)<transacts> := bool_pipe{ PropertySource := Path(PropertySource), To := To }
bool_pipe<public> := class(bool_side_effect):
    PropertySource<public>:half_path
    To<public>:bool_tap
    FN<override>(Value:logic)<suspends>:void= To(Value)

PushFloat<public><constructor>(PropertyID:string, To:float_tap)<transacts> := float_pipe{ PropertySource := Path(PropertyID), To := To }
PushFloat<public><constructor>(PropertyID:string, From:float_map, To:float_tap)<transacts> := float_pipe{ PropertySource := Path(PropertyID), From := From, To := To }
PushFloat<public><constructor>(PropertySource:prop_path, To:float_tap)<transacts> := float_pipe{ PropertySource := Path(PropertySource), To := To }
PushFloat<public><constructor>(PropertySource:prop_path, From:float_map, To:float_tap)<transacts> := float_pipe{ PropertySource := Path(PropertySource), From := From, To := To }
float_pipe<public> := class(float_side_effect):
    PropertySource<public>:half_path
    To<public>:float_tap
    From<public>:float_map = Identity
    FN<override>(Value:float)<suspends>:void= To(From(Value))

PushVec3<public><constructor>(PropertyID:string, To:vec3_tap)<transacts> := vec3_pipe{ PropertySource := Path(PropertyID), To := To }
PushVec3<public><constructor>(PropertyID:string, From:vec3_map, To:vec3_tap)<transacts> := vec3_pipe{ PropertySource := Path(PropertyID), From := From, To := To }
PushVec3<public><constructor>(PropertySource:prop_path, To:vec3_tap)<transacts> := vec3_pipe{ PropertySource := Path(PropertySource), To := To }
PushVec3<public><constructor>(PropertySource:prop_path, From:vec3_map, To:vec3_tap)<transacts> := vec3_pipe{ PropertySource := Path(PropertySource), From := From, To := To }
vec3_pipe<public> := class(vec3_side_effect):
    PropertySource<public>:half_path
    To<public>:vec3_tap
    From<public>:vec3_map = Identity
    var Latest:?vector3 = false
    FN<override>(Value:vector3)<suspends>:void=
        if ((not Latest?) or (not IsAlmostEqual[Value, Latest?, 0.01])):
            To(From(Value))
            set Latest = option. Value

PushMsg<public><constructor>(PropertyID:string, To:msg_tap)<transacts> := msg_pipe{ PropertySource := Path(PropertyID), To := To }
PushMsg<public><constructor>(PropertyID:string, From:str_map, To:msg_tap)<transacts> := msg_pipe{ PropertySource := Path(PropertyID), To := To, From := From }
# REQUEST - Supported by parametrics... message->t
msg_pipe<public> := class(str_side_effect):
    PropertySource<public>:half_path
    To<public>:msg_tap
    From<public>:str_map = Identity
    FN<override>(Value:string)<suspends>:void= To(Str2Msg(From(Value)))

Debug<public><constructor>(PropertyID:string)<transacts> := debug_pipe{ PropertySource := Path(PropertyID) }
Debug<public><constructor>(PropertySource:prop_path)<transacts> := debug_pipe. PropertySource := Path(PropertySource)
Debug<public><constructor>(PropertyID:string, Label:string)<transacts> := debug_pipe{ PropertySource := Path(PropertyID), Label := option. Label }
debug_pipe<public> := class(str_side_effect):
    PropertySource<public>:half_path
    Label<public>:?string = false
    var Latest:?string = false
    FN<override>(Value:string)<suspends>:void=
        if ((not Latest?) or (L := Latest?, L <> Value)):
            FinalLabel := Label? or PropertySource.GetKey()
            Print("[{FinalLabel}] {Value}")
            set Latest = option. Value

<#>
    New Side Effects that are subclasses

SpawnVFX<public><constructor>(VFX:?particle_system, Location:vector3)<transacts> := spawn_vfx_fn{ VFX := VFX, Location := Location }
spawn_vfx_fn<public> := class():
    VFX<public>:?particle_system = false
    Location<public>:vector3 = vector3{}
    FN<public>()<suspends>:void= if (V := VFX?). SpawnParticleSystem(V, Location)

tex_tap := type{_(:texture):void}
SetTexture<public><constructor>(Setter:tex_tap, TexMap:[string]texture, Default:texture)<transacts> := set_texture_fn{ Setter := Setter, TexMap := TexMap, Default := Default }
set_texture_fn<public> := class():
    Setter<public>:tex_tap
    TexMap<public>:[string]texture
    Default<public>:texture
    FN<public>(Key:string):void= Setter(TexMap[Key] or Default)

SetText<public><constructor>(Text:text_base)<transacts> := set_text. Text := Text
set_text<public> := class():
    Text<public>:text_base
    FN<public>(Value:message):void= Text.SetText(Value)

SetText<public><constructor>(Billboard:billboard_device)<transacts> := set_billboard_text. Billboard := Billboard
set_billboard_text<public> := class():
    Billboard<public>:billboard_device
    FN<public>(Value:message):void= Billboard.SetText(Value)

SetVisibility<public><constructor>(Widget:widget)<transacts> := set_visibility. Widget:= Widget
set_visibility<public> := class():
    Widget<public>:widget
    FN<public>(Value:logic):void=
        Visibility := if (Value?). widget_visibility.Visible else. widget_visibility.Collapsed
        Widget.SetVisibility(Visibility)

SetEnabled<public><constructor>(Widget:widget)<transacts> := set_enabled. Widget:= Widget
set_enabled<public> := class():
    Widget<public>:widget
    FN<public>(Value:logic):void= Widget.SetEnabled(Value)

AddCamera<public><constructor>(Agent:?agent, Camera:?gameplay_camera_device)<transacts> := add_camera_fn{ Agent := Agent, Camera := Camera }
add_camera_fn := class():
    Agent:?agent
    Camera:?gameplay_camera_device
    FN<public>(Value:logic):void= if (C := Camera?, A := Agent?):
        if (Value?). C.AddTo(A) else. C.RemoveFrom(A)

<#>
    Side Effect Modifiers

Wait<public><constructor>(Time:float)<transacts> := wait. Time := Time
wait<public> := class():
    Time<public>:float
    FN<public>(Value:t where t:type)<suspends>:t= { Sleep(Time); return Value; }

Offsetter<public><constructor>(Amount:vector3)<transacts> := vec3_offsetter. Amount := Amount
vec3_offsetter<public> := class():
    Amount<public>:vector3
    FN<public>(Value:vector3):vector3= Value + Amount

Offsetter<public><constructor>(Amount:float)<transacts> := float_offsetter. Amount := Amount
float_offsetter<public> := class():
    Amount<public>:float
    FN<public>(Value:float):float= Value + Amount
