
using. /UnrealEngine.com/Temporary/SpatialMath

transformer_type<public> := enum{ Move, Rotate, Scale }
transformer<public> := interface:
    GetType<public>()<computes>:transformer_type
    Transform<public>(Base:vector3)<computes>:vector3

MoveXBy<public><constructor>(X:float)<transacts> := move_by. X := X
MoveYBy<public><constructor>(Y:float)<transacts> := move_by. Y := Y
MoveZBy<public><constructor>(Z:float)<transacts> := move_by. Z := Z
move_by<public> := class(transformer):
    X<public>:float = 0.0
    Y<public>:float = 0.0
    Z<public>:float = 0.0

    GetType<override>()<computes>:transformer_type= transformer_type.Move
    Transform<override>(Base:vector3)<computes>:vector3= vector3{ X:=X, Y:=Y, Z:=Z }

RotateYawBy<public><constructor>(Yaw:float)<transacts> := rotate_by. Yaw := Yaw
RotatePitchBy<public><constructor>(Pitch:float)<transacts> := rotate_by. Pitch := Pitch
RotateRollBy<public><constructor>(Roll:float)<transacts> := rotate_by. Roll := Roll
rotate_by<public> := class(transformer):
    Yaw<public>:float = 0.0
    Pitch<public>:float = 0.0
    Roll<public>:float = 0.0

    GetType<override>()<computes>:transformer_type= transformer_type.Rotate
    Transform<override>(Base:vector3)<computes>:vector3= vector3{ X:=Yaw, Y:=Pitch, Z:=Roll }

ScaleBy<public><constructor>(All:float)<transacts> := scale_by{ X := All, Y := All, Z := All }
ScaleXBy<public><constructor>(X:float)<transacts> := scale_by. X := X
ScaleYBy<public><constructor>(Y:float)<transacts> := scale_by. Y := Y
ScaleZBy<public><constructor>(Z:float)<transacts> := scale_by. Z := Z
scale_by<public> := class(transformer):
    X<public>:float = 1.0
    Y<public>:float = 1.0
    Z<public>:float = 1.0

    GetType<override>()<computes>:transformer_type= transformer_type.Scale
    Transform<override>(Base:vector3)<computes>:vector3= vector3:
        X := X
        Y := Y
        Z := Z

MoveTo<public><constructor>()<transacts> := move_to{ X := option. 0.0, Y := option. 0.0, Z := option. 0.0 }
MoveTo<public><constructor>(All:vector3)<transacts> := move_to{ X := option. All.X, Y := option. All.Y, Z := option. All.Z }
MoveXTo<public><constructor>(X:float)<transacts> := move_to. X := option. X
MoveYTo<public><constructor>(Y:float)<transacts> := move_to. Y := option. Y
MoveZTo<public><constructor>(Z:float)<transacts> := move_to. Z := option. Z
move_to<public> := class(transformer):
    X<public>:?float = false
    Y<public>:?float = false
    Z<public>:?float = false

    GetType<override>()<computes>:transformer_type= transformer_type.Move
    Transform<override>(Base:vector3)<computes>:vector3= vector3:
        X := if (YesX := X?). YesX - Base.X else. 0.0
        Y := if (YesY := Y?). YesY - Base.Y else. 0.0
        Z := if (YesZ := Z?). YesZ - Base.Z else. 0.0

RotateTo<public><constructor>()<transacts> := rotate_to{ Yaw := option. 0.0, Pitch := option. 0.0, Roll := option. 0.0 }
RotateTo<public><constructor>(All:vector3)<transacts> := rotate_to{ Yaw := option. All.X, Pitch := option. All.Y, Roll := option. All.Z }
RotateYawTo<public><constructor>(Yaw:float)<transacts> := rotate_to. Yaw := option. Yaw
RotatePitchTo<public><constructor>(Pitch:float)<transacts> := rotate_to. Pitch := option. Pitch
RotateRollTo<public><constructor>(Roll:float)<transacts> := rotate_to. Roll := option. Roll
rotate_to<public> := class(transformer):
    Yaw<public>:?float = false
    Pitch<public>:?float = false
    Roll<public>:?float = false

    GetType<override>()<computes>:transformer_type= transformer_type.Rotate
    # TODO: This is almost definitely not fully right
    Transform<override>(Base:vector3)<computes>:vector3= vector3:
        X := if (YesYaw := Yaw?). YesYaw - Base.X else. 0.0
        Y := if (YesPitch := Pitch?). YesPitch - Base.Y else. 0.0
        Z := if (YesRoll := Roll?). YesRoll - Base.Z else. 0.0

ScaleTo<public><constructor>()<transacts> := scale_to{ X := option. 1.0, Y := option. 1.0, Z := option. 1.0 }
ScaleTo<public><constructor>(All:vector3)<transacts> := scale_to{ X := option. All.X, Y := option. All.Y, Z := option. All.Z }
ScaleTo<public><constructor>(All:float)<transacts> := scale_to{ X := option. All, Y := option. All, Z := option. All }
ScaleXTo<public><constructor>(X:float)<transacts> := scale_to. X := option. X
ScaleYTo<public><constructor>(Y:float)<transacts> := scale_to. Y := option. Y
ScaleZTo<public><constructor>(Z:float)<transacts> := scale_to. Z := option. Z
scale_to<public> := class(transformer):
    X<public>:?float = false
    Y<public>:?float = false
    Z<public>:?float = false

    GetType<override>()<computes>:transformer_type= transformer_type.Scale
    Transform<override>(Base:vector3)<computes>:vector3= vector3:
        X := if (YesX := X?). YesX / Base.X else. 1.0
        Y := if (YesY := Y?). YesY / Base.Y else. 1.0
        Z := if (YesZ := Z?). YesZ / Base.Z else. 1.0
