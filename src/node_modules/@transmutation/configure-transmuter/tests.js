/* eslint-disable max-nested-callbacks */
import describe from 'tape-bdd'
import transmute from 'transmutation'

const promise = new Promise(res => res({ test: 'promise' }))

describe('Transmute', it => {
    it('does not change a null value', assert =>
        transmute(null).then(value => assert.deepEqual(value, null)))

    it('does not change an integer', assert =>
        transmute(5).then(value => assert.deepEqual(value, 5)))

    it('does not change a string', assert =>
        transmute('roar').then(value => assert.deepEqual(value, 'roar')))

    it('does not change an object', assert =>
        transmute({ test: 'roar' }).then(value =>
            assert.deepEqual(value, { test: 'roar' })
        ))

    it('does not change an array', assert =>
        transmute([0, 'ten']).then(value =>
            assert.deepEqual(value, [0, 'ten'])
        ))

    it('handles the result of a promise', assert =>
        transmute(promise).then(value =>
            assert.deepEqual(value, { test: 'promise' })
        ))

    it('recursively handles transmuted values', assert =>
        transmute(transmute(promise)).then(value =>
            assert.deepEqual(value, { test: 'promise' })
        ))

    it('prepares a pipeline for data', assert => {
        const pipeline = transmute().extend({ roar: 'hello' })

        return pipeline({ test: 'stuff' }).then(value =>
            assert.deepEqual(value, {
                test: 'stuff',
                roar: 'hello',
            })
        )
    })

    it('prepares a pipeline that can be extended later', assert => {
        const pipeline = transmute()
        const newPipeline = pipeline.extend({ roar: 'hello' })
        const newerPipeline = newPipeline.extend({ stuff: 'another' })

        return newerPipeline({ test: 'stuff' }).then(value =>
            assert.deepEqual(value, {
                test: 'stuff',
                roar: 'hello',
                stuff: 'another',
            })
        )
    })

    it.skip('catches a normal promise error', assert =>
        transmute('roar')
            .extend(() => {
                throw new Error('trap')
            })
            .then()
            .catch(err => assert.deepEqual(err.message, 'trap')))

    it.skip('catches a normal promise error, with value at the time', assert =>
        transmute('roar')
            .extend(() => {
                throw new Error('trap')
            })
            .then()
            .catch(err => assert.deepEqual(err.value, 'roar')))

    it('catches a normal promise error, with value at the time after extending', assert =>
        transmute({ test: 'roar' })
            .extend({ roar: 'test' })
            .extend(() => {
                throw new Error('trap')
            })
            .then()
            .catch(err =>
                assert.deepEqual(err.value, { test: 'roar', roar: 'test' })
            ))

    // TODO: Figure out how to handle an already rejected promise
    it.skip('catches a promise error in an extend', assert =>
        transmute({ test: 'roar' })
            .extend(
                promise.then(() => {
                    throw new Error('trap')
                })
            )
            .then()
            .catch(err => assert.deepEqual(err.value, { test: 'roar' })))

    // TODO: Figure out how to handle an already rejected promise
    it.skip('catches a promise error in an extend with a path', assert =>
        transmute({ test: 'roar' })
            .extend(
                'testing.stuff',
                promise.then(() => {
                    throw new Error('trap')
                })
            )
            .then()
            .catch(err => assert.deepEqual(err.value, { test: 'roar' })))

    it.skip('catches a transmutation error in an extend', assert =>
        transmute({ test: 'roar' })
            .extend(p =>
                transmute(p).extend(() => {
                    throw new Error('trap')
                })
            )
            .then()
            .catch(err => assert.deepEqual(err.value, { test: 'roar' })))

    it.skip('catches a normal promise error', assert =>
        transmute('roar')
            .extend(() => {
                throw new Error('trap')
            })
            .then()
            .catch(err => assert.deepEqual(err.message, 'trap')))

    it.skip('catches a normal promise error, with value at the time', assert =>
        transmute('roar')
            .extend(() => {
                throw new Error('trap')
            })
            .then()
            .catch(err => assert.deepEqual(err.value, 'roar')))

    it('catches a normal promise error, with value at the time after extending', assert =>
        transmute({ test: 'roar' })
            .extend({ roar: 'test' })
            .extend(() => {
                throw new Error('trap')
            })
            .then()
            .catch(err =>
                assert.deepEqual(err.value, { test: 'roar', roar: 'test' })
            ))

    // TODO: Figure out how to handle an already rejected promise
    it.skip('catches a promise error in an extend', assert =>
        transmute({ test: 'roar' })
            .extend(
                promise.then(() => {
                    throw new Error('trap')
                })
            )
            .then()
            .catch(err => assert.deepEqual(err.value, { test: 'roar' })))

    // TODO: Figure out how to handle an already rejected promise
    it.skip('catches a promise error in an extend with a path', assert =>
        transmute({ test: 'roar' })
            .extend(
                'testing.stuff',
                promise.then(() => {
                    throw new Error('trap')
                })
            )
            .then()
            .catch(err => assert.deepEqual(err.value, { test: 'roar' })))

    it.skip('catches a transmutation error in an extend', assert =>
        transmute({ test: 'roar' })
            .extend(p =>
                transmute(p).extend(() => {
                    throw new Error('trap')
                })
            )
            .then()
            .catch(err => assert.deepEqual(err.value, { test: 'roar' })))
})
