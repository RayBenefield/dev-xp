local expect, printed = require'rx-test'()
local rx, _ = require'rx'()

describe('Remember Operator', function()
    describe('remember()', function()

        it('is included in rx object', function()
            assert.no.is_nil(_.remember)
        end)

        it('continues to work normally', function()
            local test_ = rx.of('hello')
                .pipe(_.remember())
            --
            expect(test_).to.produce('hello')
        end)

        it('returns last value even when complete', function()
            local test_ = rx.of('hello')
                .pipe(_.remember())
            --
            expect(test_).to.produce('hello')
            expect(test_).to.produce('hello')
        end)

        it('returns ONLY last value after completion', function()
            local test_ = rx.from({'hello', 'world', 'win'})
                .pipe(_.remember())
            --
            expect(test_).to.produce('hello', 'world', 'win')
            expect(test_).to.produce('win')
        end)

        it('returns first value after completion when taking 1', function()
            local test_ = rx.from({'hello', 'world', 'win'})
                .pipe(_.take(1), _.remember())
            --
            expect(test_).to.produce('hello')
            expect(test_).to.produce('hello')
        end)

        it('returns third value after completion when taking 3', function()
            local test_ = rx.from({'hello', 'world', 'win', 'fail', 'lose'})
                .pipe(_.take(3), _.remember())
            --
            expect(test_).to.produce('hello', 'world', 'win')
            expect(test_).to.produce('win')
        end)

        it('caches last value, without recalculation no matter number of listeners', function()
            local double = function(x) return x * 2 end
            local test_ = rx.of(5).pipe({
                _.map(double),
                _.map(double),
                _.map(double),
                _.map(double),
                _.map(double),
                _.map(double),
                _.map(double),
                _.map(double),
                _.map(double),
                _.map(double),
                _.log(),
                _.remember(),
            })
            --
            expect(test_).to.produce(5120)
            expect(test_).to.produce(5120)
            expect(test_).to.produce(5120)
            expect(test_).to.produce(5120)
            expect(test_).to.produce(5120)
            expect(test_).to.produce(5120)
            expect(test_).to.produce(5120)
            expect(test_).to.produce(5120)
            expect(test_).to.produce(5120)
            expect(test_).to.produce(5120)
            printed(1)
        end)

        it('handles a ridiculous merge hierarchy, with caching', function()
            local firstThree_ = rx.from({'one', 'two', 'three'}).pipe(_.log(), _.remember())
            local secondThree_ = rx.from({'four', 'five', 'six'}).pipe(_.log(), _.remember())
            local onlyFirst_ = rx.merge(firstThree_)
            local both_ = rx.merge(onlyFirst_, secondThree_)
            local another_ = rx.merge(secondThree_, firstThree_)
            local test_ = rx.merge(both_, firstThree_, another_)
            --
            expect(test_).to.produce('one', 'two', 'three', 'four', 'five', 'six', 'three', 'six', 'three')
            printed(6)
        end)

        it('handles a ridiculous merge hierarchy, with caching and without late log breaking', function()
            local firstThree_ = rx.from({'one', 'two', 'three'}).pipe(_.log(), _.remember())
            local secondThree_ = rx.from({'four', 'five', 'six'}).pipe(_.log(), _.remember())
            local onlyFirst_ = rx.merge(firstThree_)
            local both_ = rx.merge(onlyFirst_, secondThree_)
            local another_ = rx.merge(secondThree_, firstThree_)
            local test_ = rx.merge(both_, firstThree_, another_).pipe(_.log())
            --
            expect(test_).to.produce('one', 'two', 'three', 'four', 'five', 'six', 'three', 'six', 'three')
            printed(15)
        end)

    end)
end)
