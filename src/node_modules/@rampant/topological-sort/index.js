const createEdges = sources =>
    [].concat(
        ...Object.entries(sources).map(([source, dependencies]) =>
            dependencies.map(dependency => [dependency, source])
        )
    )

export default sources => {
    const edges = createEdges(sources)
    const sorted = []
    const visited = {}

    const nodes = edges.reduce((allNodes, [from, to]) => {
        const newFrom = !allNodes[from]
            ? { [from]: { id: from, afters: [to] } }
            : { [from]: { id: from, afters: [...allNodes[from].afters, to] } }

        const newTo = !allNodes[to] ? { [to]: { id: to, afters: [] } } : false

        return {
            ...allNodes,
            ...newFrom,
            ...newTo,
        }
    }, {})

    Object.keys(nodes).forEach(function visit(idstr, ancestors) {
        const node = nodes[idstr]
        const id = node.id

        if (visited[idstr]) return
        if (!Array.isArray(ancestors)) ancestors = []

        ancestors.push(id)
        visited[idstr] = true
        node.afters.forEach(afterID => {
            if (ancestors.indexOf(afterID) >= 0)
                throw new Error(`closed chain : ${afterID} is in ${id}`)
            visit(afterID.toString(), ancestors.map(v => v))
        })
        sorted.unshift(id)
    })

    return sorted
}
