/* eslint-disable no-return-assign */
import argv from 'argv'
import { filter } from 'fuzzy'
import inquirer from 'inquirer'
import { config } from 'dotenv'
import { db } from '@rampant/ai'
import { mergeMap } from 'rxjs/operators'
import { firestore } from 'firebase-admin'
import { from, defer, concat } from 'rxjs'
import createWit from '@rampant-wit/plugin'
import sanitize from '@rampant-wit/sanitize'
import autocomplete from 'inquirer-autocomplete-prompt'

config()
const { WIT_TOKEN } = process.env

argv.version('v0.0.0')
argv.info('Go through untrained samples and train them.')

inquirer.registerPrompt('autocomplete', autocomplete)
const { raw: store } = db
const { prompt } = inquirer

argv.option([
    {
        name: 'name',
        short: 'n',
        type: 'string',
        description: 'Name of the project to train',
        example: '--name=channel-name',
    },
    {
        name: 'limit',
        short: 'l',
        type: 'number',
        description: 'How many to fetch at one time',
        example: '--limit=50',
    },
])

const { options: { name, limit = 50 } } = argv.run()
const wit = createWit({ token: WIT_TOKEN, projectId: name, db })
const { FieldPath } = firestore

const getPage = start => {
    const query = start
        ? store
              .collection(`projects/${name}/untrained`)
              .limit(limit)
              .orderBy(FieldPath.documentId())
              .startAfter(start)
              .get()
        : store
              .collection(`projects/${name}/untrained`)
              .limit(limit)
              .get()

    return query.then(snapshots => {
        const collection = []
        snapshots.forEach(snapshot => {
            collection.push({
                id: snapshot.id,
                sample: sanitize(snapshot.id),
                entities: snapshot.data(),
            })
        })
        return collection
    })
}

const searchIntents = intents => (answer, input = '') =>
    Promise.resolve(
        filter(input, intents).map(result => result.original || result)
    )

let otherIntents = []

const chooseOther = payload => {
    const { train } = payload

    if (train === '-other-')
        return prompt([
            {
                type: 'autocomplete',
                name: 'intent',
                message: 'Which intent is this sample for?',
                source: searchIntents([...otherIntents, '-new-', '-cancel-']),
            },
        ]).then(({ intent }) => ({ ...payload, train: intent }))

    return payload
}

const createNew = payload => {
    const { sample, train } = payload

    if (train === '-cancel-') return { ...payload, train: null }

    if (train === '-new-')
        return prompt([
            {
                type: 'input',
                name: 'intentName',
                message: 'What is the name of the new intent?',
            },
            {
                type: 'input',
                name: 'response',
                message: 'What should we respond with?',
            },
        ]).then(({ intentName, response }) =>
            db
                .set(`projects/${name}/intents/${intentName}`, {
                    name: intentName,
                    sources: [{ name: 'combined' }],
                    samples: [sample],
                    effects: response
                        ? /* eslint-disable indent */
                          [
                              {
                                  text: response,
                                  type: 'whisper',
                                  channelId: '32051535',
                                  userId: 'raybenefield',
                              },
                              {
                                  userId: 'raybenefield',
                                  type: 'mixer-delete',
                                  messageId: '{$.params.id}',
                                  channelId: '32051535',
                              },
                          ]
                        : [],
                })
                .then(() =>
                    db.set(`projects/${name}/training/${intentName}`, {
                        samples: [],
                    })
                )
                .then(() => (otherIntents = [...otherIntents, intentName]))
                .then(() => ({ ...payload, train: intentName }))
        )

    return payload
}

const promptIntent = ({ id, sample, entities: { intent = [] } }) =>
    prompt([
        {
            type: 'list',
            name: 'train',
            message: sample,
            choices: [
                {
                    name: 'Skip',
                    value: null,
                },
                ...intent.map(({ value, confidence }) => ({
                    name: `${value} (${Math.round(confidence * 100 * 100) /
                        100}% confident)`,
                    value,
                    short: value,
                })),
                {
                    name: 'Nothing',
                    value: undefined,
                },
                {
                    name: 'Other...',
                    value: '-other-',
                },
            ],
        },
    ])
        .then(results => ({ ...results, sample, id }))
        .then(chooseOther)
        .then(createNew)

const trainIntent = ({ train, sample, id }) => {
    if (train === null) return Promise.resolve()

    return Promise.all([
        wit.trainSamples([sample], train),
        db.remove(`projects/${name}/untrained/${id}`),
    ])
}

const getItems = start =>
    defer(() => from(getPage(start))).pipe(
        mergeMap(collection => {
            const items$ = from(collection).pipe(
                mergeMap(promptIntent, 1),
                mergeMap(trainIntent)
            )

            const next$ = getItems(collection[collection.length - 1].sample)
            return concat(items$, next$)
        })
    )

db
    .get(`projects/${name}/intents`)
    .then(intents => Object.keys(intents))
    .then(intents => (otherIntents = intents))
    .then(() => getItems().subscribe())
