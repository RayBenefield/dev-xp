
using. /Verse.org/Assets
using. /Verse.org/Simulation
using. /Fortnite.com/Devices
using. /Verse.org/Concurrency
using. /Fortnite.com/Devices/CreativeAnimation
using. /UnrealEngine.com/Temporary/SpatialMath

using. Anima
using. Tableau

(Awaitables:[]awaitable(t) where t:type).Sync<public>()<suspends>:[]t=
    SyncAwaitables(Awaitables, 0)

SyncAwaitables<internal>(Awaitables:[]awaitable(t), Index:int where t:type)<suspends>:[]t=
    if (Awaitable := Awaitables[Index]):
        Result:tuple(t, []t) = sync:
            Awaitable.Await()
            SyncAwaitables(Awaitables, Index + 1)
        array{Result(0)} + Result(1)
    else:
        array{}

JustAwait<public>(Awaitable:awaitable(t) where t:type)<suspends>:t= Awaitable.Await()
(Awaitables:[]awaitable(t) where t:type).Race<public>()<suspends>:t= MapRace(Awaitables, JustAwait)
MapRace<public>(Array:[]t, Function(Element:t)<suspends>:u where t:type, u:type)<suspends>:u=
    if(Array.Length > 2):
        MedianElement := Floor(Array.Length/2 or Err())
        LeftArray := Array.Slice[0, MedianElement] or Err()
        RightArray := Array.Slice[MedianElement] or Err()
        race:
            MapRace(LeftArray, Function)
            MapRace(RightArray, Function)
    else if(First := Array[0]):
        if(Second := Array[1])
        then race{Function(First), Function(Second)}
        else Function(First)
    else:
        # A race with no subtasks never completes!
        Sleep(Inf)
        Err()

MapSync<public>(Array:[]t, Function(Element:t)<suspends>:u where t:type, u:type)<suspends>:[]u=
    if(Array.Length > 2):
        MedianElement := Floor(Array.Length/2 or Err())
        LeftArray := Array.Slice[0, MedianElement] or Err()
        RightArray := Array.Slice[MedianElement] or Err()
        Tuple := sync{MapSync(LeftArray, Function), MapSync(RightArray, Function)}
        Tuple(0) + Tuple(1)
    else if(First := Array[0]):
        if(Second := Array[1])
        then sync{Function(First), Function(Second)}
        else array{Function(First)}
    else:
        array{}

FilterOptions<public>(Arr:[]?t where t:type):[]t= for (Element:Arr, Value := Element?). Value

mapper(t:type, u:type) := class():
    Transformer:type{_(:t)<transacts>:u}
    FN(Item:t, Items:[]u)<transacts>:[]u= Items + array. Transformer(Item)

(Array:[]t where t:type).Map<public>(Transformer:type{_(:t)<transacts>:u} where u:type)<transacts>:[]u=
    Results:[]u = array{}
    Mapper := mapper(t, u). Transformer := Transformer
    Array.Reduce(Mapper.FN, Results)

filterer(t:type) := class():
    Predicate:type{_(:t)<decides><transacts>:void}
    FN(Item:t, Items:[]t)<transacts>:[]t= if (Predicate[Item]). Items + array. Item else. Items

(Array:[]t where t:type).Filter<public>(Predicate:type{_(:t)<decides><transacts>:void})<transacts>:[]t=
    Results:[]t = array{}
    Filterer := filterer(t). Predicate := Predicate
    Array.Reduce(Filterer.FN, Results)

(Array:[]t1 where t1:type, t2:type).Reduce<public>(CallbackFn:type{_(:t1, :t2)<transacts>:t2}, InitialValue:t2)<transacts>:t2=
    var LatestValue:t2 = InitialValue
    for (Element:Array). set LatestValue = CallbackFn(Element, LatestValue)
    LatestValue

(Array:[]t where t:type).Reverse<public>()<computes>:[]t=
    for (Index->Unused:Array, Element := Array[Array.Length - Index - 1]). Element

(StringMap:[string]t where t:type).Keys<public>()<computes>:[]string= for (Key->V:StringMap). Key

# REQUEST: Wrapped workaround due to "References to overloaded, super qualified, and intrinsic functions are not yet implemented."
MapConcatenate<public>(First:[t]u, Second:[t]u where t:subtype(comparable), u:type)<transacts>:[t]u= ConcatenateMaps(First, Second)
CombineAll<public>(Mappables:[][t]u where t:subtype(comparable), u:type):[t]u= Mappables.Reduce(MapConcatenate, map{})

ReverseConcatenate<public>(First:[]t, Second:[]t where t:type)<transacts>:[]t= Concatenate(Second, First)
CombineAllArrays<public>(Arrays:[][]t where t:type):[]t= Arrays.Reduce(ReverseConcatenate, array{})

(Map:[t]u where t:subtype(comparable), u:type).CombineWithAll<public>(NewMap:[t]u):[t]u = ConcatenateMaps(Map, NewMap)

AddToGroup<public>(Pair:tuple(t, u), All:[t][]u where t:subtype(comparable), u:type)<transacts>:[t][]u=
    NewArray := if(Old := All[Pair(0)]). Concatenate(Old, array{Pair(1)}) else. array{Pair(1)}
    ConcatenateMaps(All, map{ Pair(0) => NewArray })
(Map:[t]u where t:subtype(comparable), u:subtype(comparable)).GroupByValue<public>():[u][]t=
    Remapped := for(ID->Value:Map). (Value, ID)
    Remapped.Reduce(AddToGroup, map{})

AddToMap<public>(Entry:tuple(t,u), OldMap:[t]u where t:subtype(comparable), u:type)<transacts>:[t]u=
    ConcatenateMaps(OldMap, map{ Entry(0) => Entry(1) })
CreateMap<public>(Mappable:[]tuple(t, u) where t:subtype(comparable), u:type):[t]u=
    Mappable.Reduce(AddToMap, map{})

(Value:float).ToInt<public>()<transacts>:int = if (Result:= Floor[Value]). Result else. 0

NOOP<public>():void= {}
BLANK<public> := class(){}

Spawn<public>(Asset:?creative_prop_asset):?creative_prop = if (A := Asset?). Spawn(A, V3(), R3(), V3One(), option. material[BLANK{}]) else. false
Spawn<public>(Asset:creative_prop_asset):?creative_prop = Spawn(Asset, V3(), R3(), V3One(), option. material[BLANK{}])
Spawn<public>(Asset:creative_prop_asset, Translation:vector3):?creative_prop = Spawn(Asset, Translation, R3(), V3One(), option. material[BLANK{}])
Spawn<public>(Asset:creative_prop_asset, Translation:vector3, Scale:vector3):?creative_prop = Spawn(Asset, Translation, R3(), Scale, option. material[BLANK{}])
Spawn<public>(Asset:creative_prop_asset, Translation:vector3, Rotation:rotation):?creative_prop = Spawn(Asset, Translation, Rotation, V3One(), option. material[BLANK{}])
Spawn<public>(Asset:creative_prop_asset, Translation:vector3, Rotation:rotation, Scale:vector3):?creative_prop = Spawn(Asset, Translation, Rotation, Scale, option. material[BLANK{}])
Spawn<public>(Asset:creative_prop_asset, Translation:vector3, Rotation:rotation, Scale:vector3, Material:?material):?creative_prop=
    MaybeProp := SpawnProp(Asset, Translation, Rotation)(0)
    if (P := MaybeProp?, Anim := P.GetAnimationController[]):
        if (M := Material?). P.SetMaterial(M)
        Frames := array. Frame(ScaleTo(Scale)).SetTime(0.0)
        Anim.SetAnimation(Frames.Deltas(P.GetTransform()), ?Mode := animation_mode.OneShot)
        Anim.Play()
    return MaybeProp

OneShot<public>(Prop:?creative_prop, Anim:frame):void= OneShot(Prop, array. Anim)
OneShot<public>(Prop:?creative_prop, Anim:[]frame):void=
    if (P := Prop?, A := P.GetAnimationController[]):
        A.SetAnimation(Anim.Deltas(P.GetTransform()), ?Mode := animation_mode.OneShot)
        A.Play()

SetupOneShot<public>(Prop:?creative_prop, Anim:[]frame):void=
    if (P := Prop?, A := P.GetAnimationController[]):
        A.SetAnimation(Anim.Deltas(P.GetTransform()), ?Mode := animation_mode.OneShot)

PingPong<public>(Prop:?creative_prop, Anim:[]frame):void=
    if (P := Prop?, A := P.GetAnimationController[]):
        A.SetAnimation(Anim.Deltas(P.GetTransform()), ?Mode := animation_mode.PingPong)
        A.Play()

SetupPingPong<public>(Prop:?creative_prop, Anim:[]frame):void=
    if (P := Prop?, A := P.GetAnimationController[]):
        A.SetAnimation(Anim.Deltas(P.GetTransform()), ?Mode := animation_mode.PingPong)

V2<public>()<computes>:vector2= vector2{}
V2<public>(X:float, Y:float)<computes>:vector2= vector2{ X := X, Y := Y }
V2X<public>(X:float)<computes>:vector2= vector2{ X := X, Y := 0.0 }
V2Y<public>(Y:float)<computes>:vector2= vector2{ X := 0.0, Y := Y }

V3<public>()<computes>:vector3= vector3{}
V3One<public>()<computes>:vector3= V3(1.0, 1.0, 1.0)
V3X<public>(X:float)<computes>:vector3= V3(X, 0.0, 0.0)
V3Y<public>(Y:float)<computes>:vector3= V3(0.0, Y, 0.0)
V3Z<public>(Z:float)<computes>:vector3= V3(0.0, 0.0, Z)
V3<public>(X:float, Y:float, Z:float)<computes>:vector3= vector3{ X := X, Y := Y, Z := Z }

R3<public>()<transacts>:rotation= IdentityRotation()
R3<public>(XYZ:vector3)<transacts>:rotation= R3(XYZ.X, XYZ.Y, XYZ.Z)
R3Yaw<public>(Yaw:float)<transacts>:rotation= R3(Yaw, 0.0, 0.0)
R3Pitch<public>(Pitch:float)<transacts>:rotation= R3(0.0, Pitch, 0.0)
R3Roll<public>(Roll:float)<transacts>:rotation= R3(0.0, 0.0, Roll)
R3<public>(X:float, Y:float, Z:float)<transacts>:rotation= MakeRotationFromYawPitchRollDegrees(X, Y, Z)

S3<public>()<computes>:vector3= V3One()
S3<public>(All:float)<computes>:vector3= V3(All, All, All)
S3X<public>(X:float)<computes>:vector3= V3(X, 1.0, 1.0)
S3Y<public>(Y:float)<computes>:vector3= V3(1.0, Y, 1.0)
S3Z<public>(Z:float)<computes>:vector3= V3(1.0, 1.0, Z)

T<public>()<transacts>:transform= transform{}
T<public>(Translation:vector3)<transacts>:transform= T(Translation, R3(), S3())
T<public>(Translation:vector3, Scale:vector3)<transacts>:transform= T(Translation, R3(), Scale)
T<public>(Translation:vector3, Rotation:rotation)<transacts>:transform= T(Translation, Rotation, S3())
T<public>(Translation:vector3, Rotation:rotation, Scale:vector3)<transacts>:transform= transform{ Translation := Translation, Rotation := Rotation, Scale := Scale }

# # Usage: DeviceArray := GatherWithTag(device_tag{}, device_type)
# GatherWithTag<public>(Tag:tag, t:type):[]t =
#     TaggedObjects := GetCreativeObjectsWithTag(Tag)
#     for(Tagged : TaggedObjects, Casted := t[Tagged]). Casted