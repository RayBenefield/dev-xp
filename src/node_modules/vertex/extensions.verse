
using. /Verse.org/Assets
using. /Verse.org/Simulation
using. /Fortnite.com/Devices
using. /Verse.org/Concurrency
using. /Fortnite.com/Devices/CreativeAnimation
using. /UnrealEngine.com/Temporary/SpatialMath

using. Anima
using. Tableau

(Awaitables:[]awaitable(t) where t:type).Race<public>()<suspends>:?t=
    RaceAwaitables(Awaitables, 0)

RaceAwaitables<internal>(Awaitables:[]awaitable(t), Index:int where t:type)<suspends>:?t=
    if (Awaitable := Awaitables[Index]):
        race:
            RaceAwaitables(Awaitables, Index + 1)
            block:
                Result:t = Awaitable.Await()
                option{Result}
    else:
        if (Awaitables.Length > 0):
            Sleep(Inf)
        false

(Awaitables:[]awaitable(t) where t:type).Sync<public>()<suspends>:[]t=
    SyncAwaitables(Awaitables, 0)

SyncAwaitables<internal>(Awaitables:[]awaitable(t), Index:int where t:type)<suspends>:[]t=
    if (Awaitable := Awaitables[Index]):
        Result:tuple(t, []t) = sync:
            Awaitable.Await()
            SyncAwaitables(Awaitables, Index + 1)
        array{Result(0)} + Result(1)
    else:
        array{}

MapRace<public>(Array:[]t, Function(Element:t)<suspends>:u where t:type, u:type)<suspends>:u=
    if(Array.Length > 2):
        MedianElement := Floor(Array.Length/2 or Err())
        LeftArray := Array.Slice[0, MedianElement] or Err()
        RightArray := Array.Slice[MedianElement] or Err()
        race:
            MapRace(LeftArray, Function)
            MapRace(RightArray, Function)
    else if(First := Array[0]):
        if(Second := Array[1])
        then race{Function(First), Function(Second)}
        else Function(First)
    else:
        # A race with no subtasks never completes!
        Sleep(Inf)
        Err()

MapSync<public>(Array:[]t, Function(Element:t)<suspends>:u where t:type, u:type)<suspends>:[]u=
    if(Array.Length > 2):
        MedianElement := Floor(Array.Length/2 or Err())
        LeftArray := Array.Slice[0, MedianElement] or Err()
        RightArray := Array.Slice[MedianElement] or Err()
        Tuple := sync{MapSync(LeftArray, Function), MapSync(RightArray, Function)}
        Tuple(0) + Tuple(1)
    else if(First := Array[0]):
        if(Second := Array[1])
        then sync{Function(First), Function(Second)}
        else array{Function(First)}
    else:
        array{}

mapper(t:type, u:type) := class():
    Transformer:type{_(:t)<computes>:u}
    FN(Item:t, Items:[]u)<computes>:[]u= Items + array. Transformer(Item)

(Array:[]t where t:type).Map<public>(Transformer:type{_(:t)<computes>:u} where u:type)<transacts>:[]u=
    Results:[]u = array{}
    Mapper := mapper(t, u). Transformer := Transformer
    Array.Reduce(Mapper.FN, Results)

filterer(t:type) := class():
    Predicate:type{_(:t)<decides><transacts>:void}
    FN(Item:t, Items:[]t)<transacts>:[]t= if (Predicate[Item]). Items + array. Item else. Items

(Array:[]t where t:type).Filter<public>(Predicate:type{_(:t)<decides><transacts>:void})<transacts>:[]t=
    Results:[]t = array{}
    Filterer := filterer(t). Predicate := Predicate
    Array.Reduce(Filterer.FN, Results)

(Array:[]t1 where t1:type, t2:type).Reduce<public>(CallbackFn:type{_(:t1, :t2)<transacts>:t2}, InitialValue:t2)<transacts>:t2=
    var Value:t2 = InitialValue
    for (Element : Array):
        set Value = CallbackFn(Element, Value)
    Value

(Array:[]t where t:type).Reverse<public>()<computes>:[]t=
    for (Index->Unused:Array, Element := Array[Array.Length - Index - 1]). Element

(StringMap:[string]t where t:type).Keys<public>()<computes>:[]string= for (Key->V:StringMap). Key

(Number:float).ToInt<public>()<transacts>:int = if (Num := Floor[Number]). Num else. 0

NOOP<public>():void= {}

# Spawn<public>(Asset:creative_prop_asset):?creative_prop = Spawn(Asset, V3(), V3(), V3(), false)
Spawn<public>(Asset:creative_prop_asset, Translation:vector3, Rotation:rotation, Scale:vector3, Material:?material):?creative_prop=
    MaybeProp := SpawnProp(Asset, Translation, Rotation)(0)
    if (P := MaybeProp?, Anim := P.GetAnimationController[]):
        if (M := Material?). P.SetMaterial(M)
        Frames := array. Frame(ScaleTo(Scale)).SetTime(0.0)
        Anim.SetAnimation(Frames.Deltas(P.GetTransform()), ?Mode := animation_mode.OneShot)
        Anim.Play()
    return MaybeProp

PingPong<public>(Prop:?creative_prop, Anim:[]frame):void=
    if (P := Prop?, A := P.GetAnimationController[]):
        A.SetAnimation(Anim.Deltas(P.GetTransform()), ?Mode := animation_mode.PingPong)
        A.Play()

V2<public>(X:float, Y:float)<computes>:vector2= vector2{ X := X, Y := Y }
V2X<public>(X:float)<computes>:vector2= vector2{ X := X, Y := 0.0 }
V2Y<public>(Y:float)<computes>:vector2= vector2{ X := 0.0, Y := Y }

V3<public>()<computes>:vector3= vector3{}
V3One<public>()<computes>:vector3= vector3{ X := 1.0, Y := 1.0, Z := 1.0 }
V3<public>(X:float, Y:float, Z:float)<computes>:vector3= vector3{ X := X, Y := Y, Z := Z }
V3X<public>(X:float)<computes>:vector3= vector3{ X := X, Y := 0.0, Z := 0.0 }
V3Y<public>(Y:float)<computes>:vector3= vector3{ X := 0.0, Y := Y, Z := 0.0 }
V3Z<public>(Z:float)<computes>:vector3= vector3{ X := 0.0, Y := 0.0, Z := Z }

R3<public>()<transacts>:rotation= IdentityRotation()
R3<public>(XYZ:vector3)<transacts>:rotation= MakeRotationFromYawPitchRollDegrees(XYZ.X, XYZ.Y, XYZ.Z)
R3<public>(X:float, Y:float, Z:float)<transacts>:rotation= MakeRotationFromYawPitchRollDegrees(X, Y, Z)
R3Yaw<public>(Yaw:float)<transacts>:rotation= MakeRotationFromYawPitchRollDegrees(Yaw, 0.0, 0.0)
R3Pitch<public>(Pitch:float)<transacts>:rotation= MakeRotationFromYawPitchRollDegrees(0.0, Pitch, 0.0)
R3Roll<public>(Roll:float)<transacts>:rotation= MakeRotationFromYawPitchRollDegrees(0.0, 0.0, Roll)

# # Usage: DeviceArray := GatherWithTag(device_tag{}, device_type)
# GatherWithTag<public>(Tag:tag, t:type):[]t =
#     TaggedObjects := GetCreativeObjectsWithTag(Tag)
#     for(Tagged : TaggedObjects, Casted := t[Tagged]). Casted