using { /Verse.org/Simulation }
using { /Verse.org/Concurrency }

(Awaitables:[]awaitable(t) where t:type).Race<public>()<suspends>:?t=
    RaceAwaitables(Awaitables, 0)

RaceAwaitables<internal>(Awaitables:[]awaitable(t), Index:int where t:type)<suspends>:?t=
    if (Awaitable := Awaitables[Index]):
        race:
            RaceAwaitables(Awaitables, Index + 1)
            block:
                Result:t = Awaitable.Await()
                option{Result}
    else:
        if (Awaitables.Length > 0):
            Sleep(Inf)
        false

(Awaitables:[]awaitable(t) where t:type).Sync<public>()<suspends>:[]t=
    SyncAwaitables(Awaitables, 0)

SyncAwaitables<internal>(Awaitables:[]awaitable(t), Index:int where t:type)<suspends>:[]t=
    if (Awaitable := Awaitables[Index]):
        Result:tuple(t, []t) = sync:
            Awaitable.Await()
            SyncAwaitables(Awaitables, Index + 1)
        array{Result(0)} + Result(1)
    else:
        array{}

MapRace<public>(Array:[]t, Function(Element:t)<suspends>:u where t:type, u:type)<suspends>:u=
    if(Array.Length > 2):
        MedianElement := Floor(Array.Length/2 or Err())
        LeftArray := Array.Slice[0, MedianElement] or Err()
        RightArray := Array.Slice[MedianElement] or Err()
        race:
            MapRace(LeftArray, Function)
            MapRace(RightArray, Function)
    else if(First := Array[0]):
        if(Second := Array[1])
        then race{Function(First), Function(Second)}
        else Function(First)
    else:
        # A race with no subtasks never completes!
        Sleep(Inf)
        Err()

MapSync<public>(Array:[]t, Function(Element:t)<suspends>:u where t:type, u:type)<suspends>:[]u=
    if(Array.Length > 2):
        MedianElement := Floor(Array.Length/2 or Err())
        LeftArray := Array.Slice[0, MedianElement] or Err()
        RightArray := Array.Slice[MedianElement] or Err()
        Tuple := sync{MapSync(LeftArray, Function), MapSync(RightArray, Function)}
        Tuple(0) + Tuple(1)
    else if(First := Array[0]):
        if(Second := Array[1])
        then sync{Function(First), Function(Second)}
        else array{Function(First)}
    else:
        array{}

ConcatenateMessages<localizes><public>(Message1:message, Message2:message):message=
    "{Message1}{Message2}"

operator'+'<public>(Lhs:message, Rhs:message):message=
    ConcatenateMessages(Lhs, Rhs)

NL<localizes><public>():message := "\n"

filterer(t:type) := class():
    Predicate:type{_(:t)<decides><transacts>:void}
    FN(Item:t, Items:[]t):[]t= if (Predicate[Item]). Items + array. Item else. Items

(Array:[]t where t:type).Filter<public>(Predicate:type{_(:t)<decides><transacts>:void}):[]t=
    Results:[]t = array{}
    Filterer:filterer(t) = filterer(t). Predicate := Predicate
    Array.Reduce(Filterer.FN, Results)

(Array:[]t1 where t1:type).Reduce<public>(CallbackFn:tuple(t1, t2)->t2, InitialValue:t2 where t2:type):t2=
    var Value:t2 = InitialValue
    for (Element : Array):
        set Value = CallbackFn(Element, Value)
    Value

(Array:[]t where t:type).Reverse<public>()<computes>:[]t=
    for (Index->Unused:Array, Element := Array[Array.Length - Index - 1]). Element

(Number:float).ToInt<public>():int = if (Num := Floor[Number]). Num else. 0

Str2Msg<localizes><public>(Str:string):message := "{Str}"

NOOP<public>():void= {}

# # Usage: DeviceArray := GatherWithTag(device_tag{}, device_type)
# GatherWithTag<public>(Tag:tag, t:type):[]t =
#     TaggedObjects := GetCreativeObjectsWithTag(Tag)
#     for(Tagged : TaggedObjects, Casted := t[Tagged]). Casted