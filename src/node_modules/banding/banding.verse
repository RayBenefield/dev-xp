
Str2Msg<localizes><public>(Str:string):message := "{Str}"

(Array:[]string).Join<public>(Joiner:string)<computes>:string = Join(Array, Joiner)

ConcatenateMessages<localizes><public>(Message1:message, Message2:message):message=
    "{Message1}{Message2}"

operator'+'<public>(Lhs:message, Rhs:message):message=
    ConcatenateMessages(Lhs, Rhs)

NL<localizes><public>():message := "\n"

# ToString<public>(Strs:[]string):string= Strs.DebugString("ARRAY")
(Strs:[]string).ToString<public>():string= Strs.DebugString("ARRAY")
(Strs:[]string).DebugString<public>(Label:string):string=
    if (Strs.Length <= 0). return "[EMPTY {Label}]"
    var Full:string = Tab("[{Label}]")
    for (I->Str:Strs). set Full += WithIndent("[{I}] {Str}")
    Full + EndTab()

pairs<public> := enum{ Square, Curly, Parens, Angle }
Encloser<public><constructor>(Pair:pairs) := encompasser. Pair := Pair
Encompass<public>(Before:string, Item:string, After:string)<computes>:string = "{Before}{Item}{After}"
encompasser<public> := class():
    Pair<public>:pairs
    FN<public>(Item:string)<computes>:string = case(Pair):
        pairs.Square => Encompass("[", Item, "]")
        pairs.Curly => Encompass("\{", Item, "\}")
        pairs.Parens => Encompass("(", Item, ")")
        pairs.Angle => Encompass("<", Item, ">")

Prefixer<public><constructor>(Before:string) := joiner. Before := Before
Suffixer<public><constructor>(After:string) := joiner. After := After
Surrounder<public><constructor>(Surrounding:string) := joiner{ Before := Surrounding, After := Surrounding }
joiner<public> := class():
    Before<public>:string = ""
    After<public>:string = ""
    FN<public>(Item:string)<computes>:string = Encompass(Before, Item, After)
