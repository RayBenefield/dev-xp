-- Game.playerJoinedEvent:Connect(function(player) player:ActivateFlying() end)
local ABGS = require(script:GetCustomProperty("API"))
local rx, _ = require(script:GetCustomProperty("rx"))()
local weapon = script:GetCustomProperty("weapon"):WaitForObject()
local minotaurSettings = script:GetCustomProperty("minotaurSettings"):WaitForObject()
local defaultSettings = script:GetCustomProperty("defaultSettings"):WaitForObject()
local nameplates = script:GetCustomProperty("nameplates"):WaitForObject()
local mazeSize = script:GetCustomProperties("mazeSize").mazeSize
local tileSize = script:GetCustomProperties("tileSize").tileSize
local templatesList = script:GetCustomProperty("templates")

local minotaur
local rng = RandomStream.New()
local seed = rng:GetInitialSeed()
local templateFolder = World.SpawnAsset(templatesList, {position = Vector3.New(0,0,0), parent = script.parent})
local templates = templateFolder:GetChildren()
local templateId = rng:GetInteger(1, #templates)
local template = templates[templateId]

local endCell_ = rx.of({ x = mazeSize - 1, y = mazeSize - 1 })

local calculatePosition = function(tile)
    local x = tile['x']
    local y = tile['y']
    return Vector3.New(x*tileSize, y*tileSize, 0)
end

rx.merge(endCell_).pipe({
    _.map(calculatePosition),
    _.map(function(trans) weapon:SetWorldPosition(trans) end),
}).subscribe()

Events.ConnectForPlayer('ready', function(player)
    print(player, ' player is ready')
    print('sending maze data to player...')
    Events.BroadcastToPlayer(player, 'maze-data', seed, mazeSize, tileSize, template.name)
end)

function awardPlacementPoints()
    for _, player in ipairs(Game.GetPlayers({ignoreDead = true})) do
        local points = player:GetResource('points')
        player:SetResource('points', points + 1)
    end
end

Game.playerJoinedEvent:Connect(function(player)
    player:SetResource('points', 0)
    player.diedEvent:Connect(awardPlacementPoints)
end)

local data = {
    seed = seed,
    mazeSize = mazeSize,
    tileSize = tileSize,
    template = template.name,
}

print('Maze Data')
print('    seed: ', data.seed)
print('    mazeSize: ', data.mazeSize)
print('    tileSize: ', data.tileSize)
print('    template: ', data.template)

print('generating server maze...')
Events.Broadcast('generate-maze', data)

local swordTrigger = nil
Events.Connect('weapon-spawned', function(weaponRef)
    local weapon = weaponRef:WaitForObject()
    swordTrigger = weapon:FindChildByName('Pickup Trigger')
    swordTrigger.isInteractable = false
    Events.BroadcastToAllPlayers('sword-spawned', weaponRef)
    weapon.equippedEvent:Connect(function(equipment, player)
        Events.Broadcast('minotaur-phase', player)
        Events.BroadcastToAllPlayers('minotaur-phase', player)
    end)
end)

Events.Connect('minotaur-phase', function(player)
    minotaur = player
    minotaurSettings:ApplyToPlayer(minotaur)
    nameplates:SetNetworkedCustomProperty('minotaur', minotaur.id)
end)

Events.Connect('GameStateChanged', function(oldState, newState, hasDuration, endTime)
    if newState == ABGS.GAME_STATE_ROUND and oldState ~= ABGS.GAME_STATE_ROUND and swordTrigger ~= nil then
        swordTrigger.isInteractable = true
        rng:Mutate()
        data['seed'] = rng.seed
        local newTemplate = templates[rng:GetInteger(1, #templates)]
        data['template'] = newTemplate.name
        Events.Broadcast('generate-maze', data)
        Events.BroadcastToAllPlayers('maze-data', data['seed'], data['mazeSize'], data['tileSize'], data['template'])
    end

    if minotaur ~= nil then
        defaultSettings:ApplyToPlayer(minotaur)
        local equipment = minotaur:GetEquipment()
        for _, equipment in ipairs(minotaur:GetEquipment()) do
            equipment:Unequip()
        end
        nameplates:SetNetworkedCustomProperty('minotaur', '')
        minotaur = nil
    end
end)
