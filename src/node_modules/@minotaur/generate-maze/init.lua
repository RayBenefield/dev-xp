local rx, _, util = require(script:GetCustomProperty("rx"))()
local mazeGroup = script:GetCustomProperty("maze_group")
local maze = script:GetCustomProperty("maze"):WaitForObject()
local weapon = script:GetCustomProperty("weapon")
local templatesList = script:GetCustomProperty("templates")

local bufferSize = 100
local buildDelay = 0.00001

local FRONT = 'front'
local BACK = 'back'
local LEFT = 'left'
local RIGHT = 'right'

local parent = nil
local templates = World.SpawnAsset(templatesList, {position = Vector3.New(0,0,0), parent = script.parent})

local function bind(t, k)
    return function(...) return t[k](t, ...) end
end

print('preparing for maze generation')
local generateMaze_ = rx.fromEvent('generate-maze')
.pipe({
    _.tap(function(data)
        print('generating maze with:')
        print('    seed: ', data.seed)
        print('    mazeSize: ', data.mazeSize)
        print('    tileSize: ', data.tileSize)
        print('    template: ', data.template)

        if (parent ~= nil) then
            parent:Destroy()
        end
        parent = World.SpawnAsset(mazeGroup, {name = 'maze-architecture', position = Vector3.New(0,0,0), parent = maze})
    end),
})

local removeDuplicateCells = function(includeWhich)
    local cellKey = function(cell)
        local key = cell.x..cell.y
        key = includeWhich and key..cell.which or key
        return key
    end

    return function(source)
        return source.pipe(_.distinct(cellKey))
    end
end

local mazeGenerator_ = generateMaze_
.pipe({
    _.mergeMap(function(data)
        local rng = RandomStream.New(data.seed)
        local mazeSize = data.mazeSize
        local tileSize = data.tileSize
        local template = templates:FindDescendantByName(data.template)
        local wall = template:GetCustomProperty("wall")
        local column = template:GetCustomProperty("column")
        local floor = template:GetCustomProperty("floor")
        print('making the maze')

        local ring = function(positive, negative, include, randomWhich)
            local allowedDirections = {
                {FRONT, LEFT},
                {FRONT, RIGHT},
                {BACK, LEFT},
                {BACK, RIGHT},
            }

            local filterDirections = function(want)
                return util.filter(allowedDirections, function(dir)
                    local wants = util.intersect({dir, include})
                    if (#wants > 0) then return true end
                end)
            end

            local directions = include
                and filterDirections(include)
                or filterDirections({BACK, FRONT})

            return rx.from(directions)
            .pipe({
                _.mergeMap(function(direction)
                    local frontBack = direction[1]
                    local leftRight = direction[2]

                    return rx.range(positive, negative, -1, true)
                    .pipe({
                        _.map(function(val)
                            local limit = frontBack == FRONT and positive or negative
                            local determineWhich = function()
                                if (not randomWhich) then
                                    return leftRight == LEFT and 1 or 0
                                else
                                    return rng:GetInteger(0, 1)
                                end
                            end

                            return {
                                x = leftRight == LEFT and limit or val,
                                y = leftRight == RIGHT and limit or val,
                                which = determineWhich()
                            }
                        end),
                    })
                end)
            })
        end

        local mainMaze_ = function(randomWhich)
            return rx.range(0, mazeSize)
            .pipe({
                _.mergeMap(function(ringNumber)
                    return ring(ringNumber, 0, nil, randomWhich)
                end),
                removeDuplicateCells(),
            })
        end

        local startingArea_ = rx.merge(ring(mazeSize - 1, -2, {BACK}), ring(mazeSize - 1, -1, {BACK}))

        local columnBounds_ = ring(mazeSize, -2)

        local isNotFarCell = function(cell)
            return cell.x ~= mazeSize or cell.y ~= mazeSize
        end

        local wallBounds_ = rx.merge(
            ring(mazeSize - 1, -2, {BACK}),
            ring(mazeSize, -2, {FRONT}).pipe(_.filter(isNotFarCell))
        )

        local calculatePosition = function(data)
            local x = data['x']
            local y = data['y']
            local trans = {
                position = Vector3.New(x*tileSize, y*tileSize, 0),
                parent = parent,
                which = data['which'],
            }
            return trans
        end

        local calculateRotation = function(data)
            local which = data['which']
            data['rotation'] = Rotation.New(0, 0, which*90)
            return data
        end

        local batchSpawn = function(asset, delay)
            delay = delay or true
            return function(trans)
                Task.Wait(buildDelay)
                for index, val in ipairs(trans) do
                    World.SpawnAsset(asset, val)
                end
            end
        end

        local generateFloor_ = rx.merge(mainMaze_(), startingArea_)
        .pipe({
            removeDuplicateCells(),
            _.map(calculatePosition),
            _.buffer(bufferSize),
            _.tap(batchSpawn(floor, false)),
        })

        local generateWalls_ = rx.merge(mainMaze_(true), wallBounds_)
        .pipe({
            removeDuplicateCells(true),
            _.map(calculatePosition),
            _.map(calculateRotation),
            _.buffer(bufferSize),
            _.tap(batchSpawn(wall)),
        })

        local generateColumns_ = rx.merge(mainMaze_(), columnBounds_)
        .pipe({
            removeDuplicateCells(),
            _.map(calculatePosition),
            _.buffer(bufferSize/4),
            _.tap(batchSpawn(column)),
        })

        return rx.merge(generateFloor_, generateWalls_, generateColumns_)
    end),
})
.subscribe(function() end, print, function() end)
