
using. /Verse.org/Simulation
using. /UnrealEngine.com/Temporary/SpatialMath

using. Numb
using. Vertex
using. Tableau

goo<public>(t:type) := class:
    Init<public>(Default:t)<suspends>:void =
        var Value:t = Default
        Updated.Signal(Default)
        sync:
            loop:
                GetEvent.Await()
                Getted.Signal(Value)
            loop:
                set Value = Updated.Await()

    Updated:event(t) = event(t){}
    Getted:event(t) = event(t){}
    UpdatedEvent<public>():event(t) = Updated
    Set<public>(NewValue:t):void=
        Getted.Signal(NewValue)
        Updated.Signal(NewValue)

    GetEvent:event() = event(){}
    Get<public>()<suspends>:t =
        race:
            ReturnValue := Getted.Await()
            loop:
                GetEvent.Signal()
                Sleep(0.0)
        return ReturnValue

Once<public>(VM:goo(t) where t:type):goo(t)=
    ResultVM:goo(t) = goo(t){}
    spawn. JustOnce(VM, ResultVM)
    return ResultVM

JustOnce<public>(VM:goo(t), ResultVM:goo(t) where t:type)<suspends>:void=
    var Value:t = VM.Get()
    spawn. ResultVM.Init(Value)

Affect<public>(VM1:goo(tuple()), FN:type{_()<suspends>:?string}):goo(tuple())=
    ResultVM:goo(tuple()) = goo(tuple()){}
    spawn. AffectIt(VM1, FN, ResultVM)
    return ResultVM

AffectIt<public>(VM:goo(tuple()), FN:type{_()<suspends>:?string}, ResultVM:goo(tuple()))<suspends>:void=
    spawn. ResultVM.Init()
    loop:
        VM.UpdatedEvent().Await()
        Result := FN()
        if (Reason := Result?):
            # Print("[BAILED] {Reason}")
        else:
            ResultVM.Set()

Computed<public>(VM1:goo(t), VM2:goo(u), Transform:type{_(:t, :u):v} where t:type, u:type, v:type):goo(v)=
    ResultVM:goo(v) = goo(v){}
    spawn. Combine(VM1, VM2, Transform, ResultVM)
    return ResultVM

Combine<public>(VM1:goo(t), VM2:goo(u), Transform:type{_(:t, :u):v}, ResultVM:goo(v) where t:type, u:type, v:type)<suspends>:void=
    var First:t = VM1.Get()
    var Second:u = VM2.Get()

    spawn. ResultVM.Init(Transform(First, Second))
    loop:
        NewPair := race:
            block:
                set First = VM1.UpdatedEvent().Await()
                (First, Second)
            block:
                set Second = VM2.UpdatedEvent().Await()
                (First, Second)
        Transformed := Transform(NewPair)
        ResultVM.Set(Transformed)

SwitchMap<public>(VM:goo(t), Finder:type{_(:t)<suspends>:goo(u)} where t:type, u:type):goo(u)=
    ResultVM:goo(u) = goo(u){}
    spawn. Switcher(VM, Finder, ResultVM)
    return ResultVM

Switcher<public>(VM:goo(t), Finder:type{_(:t)<suspends>:goo(u)}, ResultVM:goo(u) where t:type, u:type)<suspends>:void=
    var Key:t = VM.Get()
    var NewVM:goo(u) = Finder(Key)
    var Value:u = NewVM.Get()

    spawn. ResultVM.Init(Value)
    loop:
        race:
            block:
                loop:
                    set Value = NewVM.UpdatedEvent().Await()
                    ResultVM.Set(Value)
            block:
                set Key = VM.UpdatedEvent().Await()
                set NewVM = Finder(Key)
                set Value = NewVM.Get()
                ResultVM.Set(Value)

Map<public>(VM:goo(t), Transform:type{_(:t):u} where t:type, u:type):goo(u)=
    ResultVM:goo(u) = goo(u){}
    spawn. MapTransformer(VM, Transform, ResultVM)
    return ResultVM

MapTransformer<public>(VM:goo(t), Transform:type{_(:t):u}, ResultVM:goo(u) where t:type, u:type)<suspends>:void=
    var Value:t = VM.Get()

    spawn. ResultVM.Init(Transform(Value))
    loop:
        set Value = VM.UpdatedEvent().Await()
        Transformed := Transform(Value)
        ResultVM.Set(Transformed)

EventGoo<public>(NewVM:goo(tuple())):event_goo= event_goo. VM := NewVM
EventGoo<public>():event_goo=
    VM := event_goo{}
    spawn. VM.Init()
    VM
event_goo<public> := class(goo(tuple())):
    VM<public>:goo(tuple()) = goo(tuple()){}
    Init<override>()<suspends>:void= spawn. VM.Init()
    Set<override>():void= VM.Set()
    Get<override>()<suspends>:tuple()= VM.Get()
    UpdatedEvent<override>():event(tuple())= VM.Updated

# [BUG] Can't do this cuz overloading thinks this is the same as a string argument
# StrGoo<public>():string_goo= StrGoo("")
StrGoo<public>(NewVM:goo(string)):string_goo= string_goo. VM := NewVM
StrGoo<public>(Default:string):string_goo=
    VM := string_goo{}
    spawn. VM.Init(Default)
    VM
string_goo<public> := class(goo(string)):
    VM<public>:goo(string) = goo(string){}
    var Latest:string = ""
    Init<override>(Default:string)<suspends>:void=
        set Latest = Default
        spawn. VM.Init(Default)
    Set<override>(NewValue:string):void=
        if (NewValue <> Latest):
            set Latest = NewValue
            VM.Set(NewValue)
    Get<override>()<suspends>:string = VM.Get()
    UpdatedEvent<override>():event(string) = VM.Updated

IntGoo<public>(NewVM:goo(int)):int_goo= int_goo. VM := NewVM
IntGoo<public>():int_goo= IntGoo(0)
IntGoo<public>(Default:int):int_goo=
    VM := int_goo{}
    spawn. VM.Init(Default)
    VM
int_goo<public> := class(goo(int)):
    VM<public>:goo(int) = goo(int){}
    var Latest:int = 0
    Init<override>(Default:int)<suspends>:void=
        set Latest = Default
        spawn. VM.Init(Default)
    Set<override>(NewValue:int):void=
        if (NewValue <> Latest):
            set Latest = NewValue
            VM.Set(NewValue)
    Get<override>()<suspends>:int = VM.Get()
    UpdatedEvent<override>():event(int) = VM.Updated

FloatGoo<public>(NewVM:goo(float)):float_goo= float_goo. VM := NewVM
FloatGoo<public>():float_goo= FloatGoo(0.0)
FloatGoo<public>(Default:float):float_goo=
    VM := float_goo{}
    spawn. VM.Init(Default)
    VM
float_goo<public> := class(goo(float)):
    VM<public>:goo(float) = goo(float){}
    var Latest:float = 0.0
    Init<override>(Default:float)<suspends>:void=
        set Latest = Default
        spawn. VM.Init(Default)
    Set<override>(NewValue:float):void=
        if (NewValue <> Latest):
            set Latest = NewValue
            VM.Set(NewValue)
    Get<override>()<suspends>:float = VM.Get()
    UpdatedEvent<override>():event(float) = VM.Updated

# [BUG] Can't do this cuz overloading thinks this is the same as an optional argument or parametric?
# AgentGoo<public>():agent_goo= AgentGoo(false)
AgentGooVM<public>(NewVM:goo(?agent)):agent_goo= agent_goo. VM := NewVM
AgentGoo<public>(Default:?agent):agent_goo=
    VM := agent_goo{}
    spawn. VM.Init(Default)
    VM
agent_goo<public> := class(goo(?agent)):
    VM<public>:goo(?agent) = goo(?agent){}
    var Latest:?agent = false
    Init<override>(Default:?agent)<suspends>:void=
        set Latest = Default
        spawn. VM.Init(Default)
    Set<override>(NewValue:?agent):void =
        if (NewValue <> Latest):
            set Latest = NewValue
            VM.Set(NewValue)
    Get<override>()<suspends>:?agent = VM.Get()
    UpdatedEvent<override>():event(?agent) = VM.Updated

NumGoo<public>(NewVM:goo(num)):num_goo = num_goo. VM := NewVM
NumGoo<public>():num_goo= NumGoo(num{})
NumGoo<public>(Default:float):num_goo= NumGoo(num. Value := Default)
NumGoo<public>(Default:num):num_goo=
    VM := num_goo{}
    spawn. VM.Init(Default)
    VM
num_goo<public> := class(goo(num)):
    VM<public>:goo(num) = goo(num){}
    var Latest:num = num{}
    Init<override>(Default:num)<suspends>:void=
        set Latest = Default
        spawn. VM.Init(Default)
    Set<override>(NewValue:num):void =
        if (not NewValue.Equals[Latest]):
            set Latest = NewValue
            VM.Set(NewValue)
    Get<override>()<suspends>:num = VM.Get()
    UpdatedEvent<override>():event(num) = VM.Updated

BoolGoo<public>(NewVM:goo(logic)):bool_goo = bool_goo. VM := NewVM
BoolGoo<public>(Default:logic):bool_goo=
    VM := bool_goo{}
    spawn. VM.Init(Default)
    VM
bool_goo<public> := class(goo(logic)):
    VM<public>:goo(logic) = goo(logic){}
    var Latest:logic = false
    Init<override>(Default:logic)<suspends>:void=
        set Latest = Default
        spawn. VM.Init(Default)
    Set<override>(NewValue:logic):void =
        if (NewValue <> Latest):
            set Latest = NewValue
            VM.Set(NewValue)
    Get<override>()<suspends>:logic = VM.Get()
    UpdatedEvent<override>():event(logic) = VM.Updated

Vec2Goo<public>(NewVM:goo(vector2)):vec2_goo= vec2_goo. VM := NewVM
Vec2Goo<public>():vec2_goo= Vec2Goo(vector2{})
Vec2Goo<public>(Default:vector2):vec2_goo=
    VM := vec2_goo{}
    spawn. VM.Init(Default)
    VM
vec2_goo<public> := class(goo(vector2)):
    VM<public>:goo(vector2) = goo(vector2){}
    var Latest:vector2 = vector2{}
    Init<override>(Default:vector2)<suspends>:void=
        set Latest = Default
        spawn. VM.Init(Default)
    Set<override>(NewValue:vector2):void =
        if (not IsAlmostEqual[NewValue, Latest, 0.01]):
            set Latest = NewValue
            VM.Set(NewValue)
    Get<override>()<suspends>:vector2 = VM.Get()
    UpdatedEvent<override>():event(vector2) = VM.Updated

Vec3Goo<public>(NewVM:goo(vector3)):vec3_goo= vec3_goo. VM := NewVM
Vec3Goo<public>():vec3_goo= Vec3Goo(vector3{})
Vec3Goo<public>(Default:vector3):vec3_goo=
    VM := vec3_goo{}
    spawn. VM.Init(Default)
    VM
vec3_goo<public> := class(goo(vector3)):
    VM<public>:goo(vector3) = goo(vector3){}
    var Latest:vector3 = vector3{}
    Init<override>(Default:vector3)<suspends>:void=
        set Latest = Default
        spawn. VM.Init(Default)
    Set<override>(NewValue:vector3):void =
        if (not IsAlmostEqual[NewValue, Latest, 0.01]):
            set Latest = NewValue
            VM.Set(NewValue)
    Get<override>()<suspends>:vector3 = VM.Get()
    UpdatedEvent<override>():event(vector3) = VM.Updated

GTE(First:num, Second:num)<transacts>:logic= if (First.GreaterThanOrEqual[Second]). true else. false
CompGTE<public>(First:half_path,FirstGetter:type{_(:half_path):goo(num)},Second:half_path,SecondGetter:type{_(:half_path):goo(num)}):goo(logic)=
    Computed(FirstGetter(First), SecondGetter(Second), GTE)

NumEquals(First:num, Second:num)<transacts>:logic= if (First.Equals[Second]). true else. false
CompNumEquals<public>(First:half_path,FirstGetter:type{_(:half_path):goo(num)},Second:half_path,SecondGetter:type{_(:half_path):goo(num)}):goo(logic)=
    Computed(FirstGetter(First), SecondGetter(Second), NumEquals)

AndBools(First:logic, Second:logic)<transacts>:logic= if (First = true and Second = true). true else. false
CompAnd<public>(First:half_path,FirstGetter:type{_(:half_path):goo(logic)},Second:half_path,SecondGetter:type{_(:half_path):goo(logic)}):goo(logic)=
    Computed(FirstGetter(First), SecondGetter(Second), AndBools)

OrBools(First:logic, Second:logic)<transacts>:logic= if (First = true or Second = true). true else. false
CompOr<public>(First:half_path,FirstGetter:type{_(:half_path):goo(logic)},Second:half_path,SecondGetter:type{_(:half_path):goo(logic)}):goo(logic)=
    Computed(FirstGetter(First), SecondGetter(Second), OrBools)

NotBools(Bool:logic)<transacts>:logic= if (Bool?). false else. true
MapNot<public>(First:half_path,FirstGetter:type{_(:half_path):goo(logic)}):goo(logic)=
    Map(FirstGetter(First), NotBools)

NotEmpty(Str:string)<transacts>:logic= if (Str <> ""). true else. false
MapNotEmpty<public>(First:half_path,FirstGetter:type{_(:half_path):goo(string)}):goo(logic)=
    Map(FirstGetter(First), NotEmpty)

NumMultiply(First:num, Second:num)<transacts>:num= First * Second
CompNumMultiply<public>(First:half_path,FirstGetter:type{_(:half_path):goo(num)},Second:half_path,SecondGetter:type{_(:half_path):goo(num)}):goo(num)=
    Computed(FirstGetter(First), SecondGetter(Second), NumMultiply)

NumPower(First:num, Second:float)<transacts>:num= First.Pow(Second)
CompNumPower<public>(First:half_path,FirstGetter:type{_(:half_path):goo(num)},Second:half_path,SecondGetter:type{_(:half_path):goo(float)}):goo(num)=
    Computed(FirstGetter(First), SecondGetter(Second), NumPower)

NumToFloat<public>(Num:num)<transacts>:float= Num.Value * Pow(10.0, Num.Exponent * 1.0)
MapNumToFloat<public>(First:goo(num)):goo(float)= Map(First, NumToFloat)
MapNumToFloat<public>(First:half_path,FirstGetter:type{_(:half_path):goo(num)}):goo(float)=
    Map(FirstGetter(First), NumToFloat)

AppendStrs(First:string, Second:string)<transacts>:string = "{First}{Second}"
CompAppendStrs<public>(First:half_path,FirstGetter:type{_(:half_path):goo(string)},Second:half_path,SecondGetter:type{_(:half_path):goo(string)}):goo(string)=
    Computed(FirstGetter(First), SecondGetter(Second), AppendStrs)

AppendFloats(X:float, Y:float)<transacts>:vector2= vector2{ X := X, Y := Y }
CompAppendFloats<public>(First:half_path,FirstGetter:type{_(:half_path):goo(float)},Second:half_path,SecondGetter:type{_(:half_path):goo(float)}):goo(vector2)=
    Computed(FirstGetter(First), SecondGetter(Second), AppendFloats)

AppendVec2AndFloat(Vec2:vector2, Z:float)<transacts>:vector3= vector3{ X := Vec2.X, Y := Vec2.Y, Z := Z }
CompAppendVec2AndFloat<public>(First:half_path,FirstGetter:type{_(:half_path):goo(vector2)},Second:half_path,SecondGetter:type{_(:half_path):goo(float)}):goo(vector3)=
    Computed(FirstGetter(First), SecondGetter(Second), AppendVec2AndFloat)

FloatMultiply(First:float, Second:float)<transacts>:float= First * Second
CompFloatMultiply<public>(First:half_path,FirstGetter:type{_(:half_path):goo(float)},Second:half_path,SecondGetter:type{_(:half_path):goo(float)}):goo(float)=
    Computed(FirstGetter(First), SecondGetter(Second), FloatMultiply)

FloatToInt(Float:float)<transacts>:int= Float.ToInt()
MapFloatToInt<public>(First:goo(float)):goo(int)= Map(First, FloatToInt)
MapFloatToInt<public>(First:half_path,FirstGetter:type{_(:half_path):goo(float)}):goo(int)=
    Map(FirstGetter(First), FloatToInt)

FloatToNum(Float:float)<transacts>:num= num. Value := Float
MapFloatToNum<public>(First:goo(float)):goo(num)= Map(First, FloatToNum)
MapFloatToNum<public>(First:half_path,FirstGetter:type{_(:half_path):goo(float)}):goo(num)=
    Map(FirstGetter(First), FloatToNum)

IntAdd(First:int, Second:int)<transacts>:int= First + Second
CompIntAdd<public>(First:half_path,FirstGetter:type{_(:half_path):goo(int)},Second:half_path,SecondGetter:type{_(:half_path):goo(int)}):goo(int)=
    Computed(FirstGetter(First), SecondGetter(Second), IntAdd)

IntToNum(Integer:int)<transacts>:num= num. Value := Integer*1.0
MapIntToNum<public>(First:goo(int)):goo(num)= Map(First, IntToNum)
MapIntToNum<public>(First:half_path,FirstGetter:type{_(:half_path):goo(int)}):goo(num)=
    Map(FirstGetter(First), IntToNum)

IntToFloat(Integer:int)<transacts>:float= Integer*1.0
MapIntToFloat<public>(First:goo(int)):goo(float)= Map(First, IntToFloat)
MapIntToFloat<public>(First:half_path,FirstGetter:type{_(:half_path):goo(int)}):goo(float)=
    Map(FirstGetter(First), IntToFloat)

BoolToStr(Value:logic)<transacts>:string= if (Value?). "true" else. "false"
MapBoolToStr<public>(First:goo(logic)):goo(string)= Map(First, BoolToStr)
MapBoolToStr<public>(First:half_path,FirstGetter:type{_(:half_path):goo(logic)}):goo(string)=
    Map(FirstGetter(First), BoolToStr)

NumToStr(Num:num)<transacts>:string= "{Num}"
MapNumToStr<public>(First:goo(num)):goo(string)= Map(First, NumToStr)
MapNumToStr<public>(First:half_path,FirstGetter:type{_(:half_path):goo(num)}):goo(string)=
    Map(FirstGetter(First), NumToStr)

FloatToStr(Float:float)<transacts>:string= "{Float}"
MapFloatToStr<public>(First:goo(float)):goo(string)= Map(First, FloatToStr)
MapFloatToStr<public>(First:half_path,FirstGetter:type{_(:half_path):goo(float)}):goo(string)=
    Map(FirstGetter(First), FloatToStr)

IntToStr(Integer:int)<transacts>:string= "{Integer}"
MapIntToStr<public>(First:goo(int)):goo(string)= Map(First, IntToStr)
MapIntToStr<public>(First:half_path,FirstGetter:type{_(:half_path):goo(int)}):goo(string)=
    Map(FirstGetter(First), IntToStr)

Vec2ToStr(Vec2:vector2)<transacts>:string= "{Vec2}"
MapVec2ToStr<public>(First:goo(vector2)):goo(string)= Map(First, Vec2ToStr)
MapVec2ToStr<public>(First:half_path,FirstGetter:type{_(:half_path):goo(vector2)}):goo(string)=
    MapVec2ToStr(FirstGetter(First))

Vec3ToStr(Vec3:vector3)<transacts>:string= "{Vec3}"
MapVec3ToStr<public>(First:goo(vector3)):goo(string)= Map(First, Vec3ToStr)
MapVec3ToStr<public>(First:half_path,FirstGetter:type{_(:half_path):goo(vector3)}):goo(string)=
    Map(FirstGetter(First), Vec3ToStr)

AgentToStr(Value:?agent)<transacts>:string= if (Value?). "[HAS AGENT]" else. "[NO AGENT]"
MapAgentToStr<public>(First:goo(?agent)):goo(string)= Map(First, AgentToStr)
MapAgentToStr<public>(First:half_path,FirstGetter:type{_(:half_path):goo(?agent)}):goo(string)=
    Map(FirstGetter(First), AgentToStr)
