
using. /Verse.org/Random
using. /Verse.org/Simulation
using. /Verse.org/Concurrency
using. /UnrealEngine.com/Temporary/SpatialMath

using. Numb
using. Tableau
using. Vertex

goo<public>(t:type) := class:
    Fallback<public>:?t = false
    Init<public>(Default:t)<suspends>:void =
        var Value:t = Default
        Updated.Signal(Default)
        sync:
            loop:
                GetEvent.Await()
                Getted.Signal(Value)
            loop:
                set Value = Updated.Await()

    Updated:event(t) = event(t){}
    Getted:event(t) = event(t){}
    UpdatedEvent<public>():event(t) = Updated
    Update<public>(NewValue:t):void=
        Getted.Signal(NewValue)
        Updated.Signal(NewValue)

    GetEvent:event() = event(){}
    Get<public>()<suspends>:t = race:
        Getted.Await()
        block:
            loop:
                GetEvent.Signal()
                Sleep(0.0)
            Err("Should never hit, used for matching return types")

Affect<public>(VM1:goo(prop_path), FN:type{_(:prop_path)<suspends>:?string}):goo(prop_path)=
    ResultVM:goo(prop_path) = goo(prop_path){}
    spawn. AffectIt(VM1, FN, ResultVM)
    return ResultVM

AffectIt<public>(VM:goo(prop_path), FN:type{_(:prop_path)<suspends>:?string}, ResultVM:goo(prop_path))<suspends>:void=
    spawn. ResultVM.Init(prop_path{})
    loop:
        Value := VM.UpdatedEvent().Await()
        Result := FN(Value)
        if (Reason := Result?):
            # Print("[BAILED] {Reason}")
        else:
            ResultVM.Update(Value)

Computed<public>(VM1:goo(t), VM2:goo(u), Transform:type{_(:t, :u):v} where t:type, u:type, v:type):goo(v)=
    ResultVM:goo(v) = goo(v){}
    spawn. Combine(VM1, VM2, Transform, ResultVM)
    return ResultVM

Combine<public>(VM1:goo(t), VM2:goo(u), Transform:type{_(:t, :u):v}, ResultVM:goo(v) where t:type, u:type, v:type)<suspends>:void=
    var First:t = VM1.Get()
    var Second:u = VM2.Get()

    spawn. ResultVM.Init(Transform(First, Second))
    loop:
        NewPair := race:
            block:
                set First = VM1.UpdatedEvent().Await()
                (First, Second)
            block:
                set Second = VM2.UpdatedEvent().Await()
                (First, Second)
        Transformed := Transform(NewPair)
        ResultVM.Update(Transformed)

SwitchMap<public>(VM:goo(t), Finder:type{_(:t)<suspends>:goo(u)} where t:type, u:type):goo(u)=
    ResultVM:goo(u) = goo(u){}
    spawn. Switcher(VM, Finder, ResultVM)
    return ResultVM

Switcher<public>(VM:goo(t), Finder:type{_(:t)<suspends>:goo(u)}, ResultVM:goo(u) where t:type, u:type)<suspends>:void=
    var Key:t = VM.Get()
    var NewVM:goo(u) = Finder(Key)
    var Value:u = NewVM.Get()

    spawn. ResultVM.Init(Value)
    loop:
        race:
            block:
                loop:
                    set Value = NewVM.UpdatedEvent().Await()
                    ResultVM.Update(Value)
            block:
                set Key = VM.UpdatedEvent().Await()
                set NewVM = Finder(Key)
                set Value = NewVM.Get()
                ResultVM.Update(Value)

Map<public>(VM:goo(t), Transform:type{_(:t):u} where t:type, u:type):goo(u)=
    ResultVM:goo(u) = goo(u){}
    spawn. MapTransformer(VM, Transform, ResultVM)
    return ResultVM

MapTransformer<public>(VM:goo(t), Transform:type{_(:t):u}, ResultVM:goo(u) where t:type, u:type)<suspends>:void=
    var Value:t = VM.Get()

    spawn. ResultVM.Init(Transform(Value))
    loop:
        set Value = VM.UpdatedEvent().Await()
        Transformed := Transform(Value)
        ResultVM.Update(Transformed)

FlatMap<public>(Keys:goo([]string), Fetcher:type{_(:string):goo(logic)}):goo([string]logic)=
    ResultVM := goo([string]logic){}
    spawn. FlatMapFetcher(Keys, Fetcher, ResultVM)
    return ResultVM
FlatMapFetcher<public>(KeysVM:goo([]string), Fetcher:type{_(:string):goo(logic)}, ResultVM:goo([string]logic))<suspends>:void=
    var Keys:[]string = KeysVM.Get()
    var ValueMap:[string]goo(logic) = CreateMap of for(Key:Keys). (Key, Fetcher(Key))
    var CurrentVM:goo([string]logic) = Merge(ValueMap)
    var Value:[string]logic = CurrentVM.Get()

    spawn. ResultVM.Init(Value)
    loop:
        set Value = CurrentVM.UpdatedEvent().Await()
        ResultVM.Update(Value)
    #TODO - Support KeysVM updates

Merge<public>(VMs:[string]goo(logic)):goo([string]logic)=
    ResultVM := goo([string]logic){}
    spawn. MergeAll(VMs, ResultVM)
    return ResultVM
MergeAll<public>(VMs:[string]goo(logic), ResultVM:goo([string]logic))<suspends>:void=
    var Values:[string]logic = CreateMap of for(Key->VM:VMs, Fallback := VM.Fallback?). (Key, Fallback)
    UpdateEvents := for(VM:VMs). VM.UpdatedEvent()

    spawn. ResultVM.Init(Values)
    loop:
        NewEntry := UpdateEvents.Race()
        Sleep(0.0)
        set Values = CreateMap of for(Key->VM:VMs). (Key, VM.Get())
        ResultVM.Update(Values)

EventGoo<public>(NewVM:goo(prop_path)):event_goo= event_goo. VM := NewVM
EventGoo<public>():event_goo=
    VM := event_goo{}
    spawn. VM.Init(prop_path{})
    VM
event_goo<public> := class(goo(prop_path)):
    VM<public>:goo(prop_path) = goo(prop_path). Fallback := option. prop_path{}
    Init<override>(Default:prop_path)<suspends>:void= spawn. VM.Init(Default)
    Update<override>(NewValue:prop_path):void= VM.Update(NewValue)
    Get<override>()<suspends>:prop_path= VM.Get()
    UpdatedEvent<override>():event(prop_path)= VM.Updated

# [BUG] Can't do this cuz overloading thinks this is the same as a string argument
# StrGoo<public>():str_goo= StrGoo("")
StrGoo<public>(NewVM:goo(string)):str_goo= str_goo. VM := NewVM
StrGoo<public>(Default:string):str_goo=
    VM := str_goo{}
    spawn. VM.Init(Default)
    VM
str_goo<public> := class(goo(string)):
    VM<public>:goo(string) = goo(string). Fallback := option. ""
    Init<override>(Default:string)<suspends>:void= spawn. VM.Init(Default)
    Update<override>(NewValue:string):void= VM.Update(NewValue)
    Get<override>()<suspends>:string= VM.Get()
    UpdatedEvent<override>():event(string)= VM.Updated

StrsGoo<public>(NewVM:goo([]string)):strs_goo= strs_goo. VM := NewVM
StrsGoo<public>(Default:[]string):strs_goo=
    VM := strs_goo{}
    spawn. VM.Init(Default)
    VM
strs_goo<public> := class(goo([]string)):
    VM<public>:goo([]string) = goo([]string). Fallback := option. array{}
    Init<override>(Default:[]string)<suspends>:void= spawn. VM.Init(Default)
    Update<override>(NewValue:[]string):void= VM.Update(NewValue)
    Get<override>()<suspends>:[]string= VM.Get()
    UpdatedEvent<override>():event([]string)= VM.Updated

IntGoo<public>(NewVM:goo(int)):int_goo= int_goo. VM := NewVM
IntGoo<public>():int_goo= IntGoo(0)
IntGoo<public>(Default:int):int_goo=
    VM := int_goo{}
    spawn. VM.Init(Default)
    VM
int_goo<public> := class(goo(int)):
    VM<public>:goo(int) = goo(int). Fallback := option. 0
    Init<override>(Default:int)<suspends>:void= spawn. VM.Init(Default)
    Update<override>(NewValue:int):void= VM.Update(NewValue)
    Get<override>()<suspends>:int= VM.Get()
    UpdatedEvent<override>():event(int)= VM.Updated

FloatGoo<public>(NewVM:goo(float)):float_goo= float_goo. VM := NewVM
FloatGoo<public>():float_goo= FloatGoo(0.0)
FloatGoo<public>(Default:float):float_goo=
    VM := float_goo{}
    spawn. VM.Init(Default)
    VM
float_goo<public> := class(goo(float)):
    VM<public>:goo(float) = goo(float). Fallback := option. 0.0
    Init<override>(Default:float)<suspends>:void= spawn. VM.Init(Default)
    Update<override>(NewValue:float):void= VM.Update(NewValue)
    Get<override>()<suspends>:float= VM.Get()
    UpdatedEvent<override>():event(float)= VM.Updated

# [BUG] Can't do this cuz overloading thinks this is the same as an optional argument or parametric?
# AgentGoo<public>():agent_goo= AgentGoo(false)
AgentGooVM<public>(NewVM:goo(?agent)):agent_goo= agent_goo. VM := NewVM
AgentGoo<public>(Default:?agent):agent_goo=
    VM := agent_goo{}
    spawn. VM.Init(Default)
    VM
agent_goo<public> := class(goo(?agent)):
    VM<public>:goo(?agent) = goo(?agent){}
    Init<override>(Default:?agent)<suspends>:void= spawn. VM.Init(Default)
    Update<override>(NewValue:?agent):void= VM.Update(NewValue)
    Get<override>()<suspends>:?agent= VM.Get()
    UpdatedEvent<override>():event(?agent)= VM.Updated

NumGoo<public>(NewVM:goo(num)):num_goo = num_goo. VM := NewVM
NumGoo<public>():num_goo= NumGoo(num{})
NumGoo<public>(Default:float):num_goo= NumGoo(num. Value := Default)
NumGoo<public>(Default:num):num_goo=
    VM := num_goo{}
    spawn. VM.Init(Default)
    VM
num_goo<public> := class(goo(num)):
    VM<public>:goo(num) = goo(num). Fallback := option. num{}
    Init<override>(Default:num)<suspends>:void= spawn. VM.Init(Default)
    Update<override>(NewValue:num):void= VM.Update(NewValue)
    Get<override>()<suspends>:num= VM.Get()
    UpdatedEvent<override>():event(num)= VM.Updated

BoolMapGoo<public>(NewVM:goo([string]logic)):boolmap_goo = boolmap_goo. VM := NewVM
boolmap_goo<public> := class(goo([string]logic)):
    VM<public>:goo([string]logic) = goo([string]logic). Fallback := option. map{}
    Init<override>(Default:[string]logic)<suspends>:void= spawn. VM.Init(Default)
    Update<override>(NewValue:[string]logic):void= VM.Update(NewValue)
    Get<override>()<suspends>:[string]logic= VM.Get()
    UpdatedEvent<override>():event([string]logic)= VM.Updated

BoolGoo<public>(NewVM:goo(logic)):bool_goo = bool_goo. VM := NewVM
BoolGoo<public>(Default:logic):bool_goo=
    VM := bool_goo{}
    spawn. VM.Init(Default)
    VM
bool_goo<public> := class(goo(logic)):
    VM<public>:goo(logic) = goo(logic). Fallback := option. false
    Init<override>(Default:logic)<suspends>:void= spawn. VM.Init(Default)
    Update<override>(NewValue:logic):void= VM.Update(NewValue)
    Get<override>()<suspends>:logic= VM.Get()
    UpdatedEvent<override>():event(logic)= VM.Updated

Vec2Goo<public>(NewVM:goo(vector2)):vec2_goo= vec2_goo. VM := NewVM
Vec2Goo<public>():vec2_goo= Vec2Goo(vector2{})
Vec2Goo<public>(Default:vector2):vec2_goo=
    VM := vec2_goo{}
    spawn. VM.Init(Default)
    VM
vec2_goo<public> := class(goo(vector2)):
    VM<public>:goo(vector2) = goo(vector2). Fallback := option. vector2{}
    Init<override>(Default:vector2)<suspends>:void= spawn. VM.Init(Default)
    Update<override>(NewValue:vector2):void= VM.Update(NewValue)
    Get<override>()<suspends>:vector2= VM.Get()
    UpdatedEvent<override>():event(vector2)= VM.Updated

Vec3Goo<public>(NewVM:goo(vector3)):vec3_goo= vec3_goo. VM := NewVM
Vec3Goo<public>():vec3_goo= Vec3Goo(vector3{})
Vec3Goo<public>(Default:vector3):vec3_goo=
    VM := vec3_goo{}
    spawn. VM.Init(Default)
    VM
vec3_goo<public> := class(goo(vector3)):
    VM<public>:goo(vector3) = goo(vector3). Fallback := option. vector3{}
    Init<override>(Default:vector3)<suspends>:void= spawn. VM.Init(Default)
    Update<override>(NewValue:vector3):void= VM.Update(NewValue)
    Get<override>()<suspends>:vector3= VM.Get()
    UpdatedEvent<override>():event(vector3)= VM.Updated
